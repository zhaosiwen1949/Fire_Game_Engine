// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Animation.serializer.h"

#include <algorithm>

#include "once.h"
#include "coded_stream.h"
#include "wire_format_lite_inl.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

void protobuf_ShutdownFile_Animation_2eproto() {
  delete Curve::default_instance_;
  delete CubicBezier::default_instance_;
  delete RotateAnimationKeyFrame::default_instance_;
  delete RotateAnimationClip::default_instance_;
  delete TranslateAnimationKeyFrame::default_instance_;
  delete TranslateAnimationClip::default_instance_;
  delete ScaleAnimationKeyFrame::default_instance_;
  delete ScaleAnimationClip::default_instance_;
  delete ShearAnimationKeyFrame::default_instance_;
  delete ShearAnimationClip::default_instance_;
  delete SpriteSequenceAnimationKeyFrame::default_instance_;
  delete SpriteSequenceAnimationClip::default_instance_;
  delete ColorAnimationKeyFrame::default_instance_;
  delete ColorAnimationClip::default_instance_;
  delete TwoColorAnimationKeyFrame::default_instance_;
  delete TwoColorAnimationClip::default_instance_;
  delete DrawOrderAnimationKeyFrame::default_instance_;
  delete DrawOrderAnimationClip::default_instance_;
  delete AnimationClip::default_instance_;
  delete Animation::default_instance_;
  delete BakedMeshData::default_instance_;
  delete BakedKeyFrame::default_instance_;
  delete BakedAnimationData::default_instance_;
}

void protobuf_AddDesc_Animation_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Serializer::protobuf_AddDesc_Vector_2eproto();
  ::Serializer::protobuf_AddDesc_Color_2eproto();
  Curve::default_instance_ = new Curve();
  CubicBezier::default_instance_ = new CubicBezier();
  RotateAnimationKeyFrame::default_instance_ = new RotateAnimationKeyFrame();
  RotateAnimationClip::default_instance_ = new RotateAnimationClip();
  TranslateAnimationKeyFrame::default_instance_ = new TranslateAnimationKeyFrame();
  TranslateAnimationClip::default_instance_ = new TranslateAnimationClip();
  ScaleAnimationKeyFrame::default_instance_ = new ScaleAnimationKeyFrame();
  ScaleAnimationClip::default_instance_ = new ScaleAnimationClip();
  ShearAnimationKeyFrame::default_instance_ = new ShearAnimationKeyFrame();
  ShearAnimationClip::default_instance_ = new ShearAnimationClip();
  SpriteSequenceAnimationKeyFrame::default_instance_ = new SpriteSequenceAnimationKeyFrame();
  SpriteSequenceAnimationClip::default_instance_ = new SpriteSequenceAnimationClip();
  ColorAnimationKeyFrame::default_instance_ = new ColorAnimationKeyFrame();
  ColorAnimationClip::default_instance_ = new ColorAnimationClip();
  TwoColorAnimationKeyFrame::default_instance_ = new TwoColorAnimationKeyFrame();
  TwoColorAnimationClip::default_instance_ = new TwoColorAnimationClip();
  DrawOrderAnimationKeyFrame::default_instance_ = new DrawOrderAnimationKeyFrame();
  DrawOrderAnimationClip::default_instance_ = new DrawOrderAnimationClip();
  AnimationClip::default_instance_ = new AnimationClip();
  Animation::default_instance_ = new Animation();
  BakedMeshData::default_instance_ = new BakedMeshData();
  BakedKeyFrame::default_instance_ = new BakedKeyFrame();
  BakedAnimationData::default_instance_ = new BakedAnimationData();
  Curve::default_instance_->InitAsDefaultInstance();
  CubicBezier::default_instance_->InitAsDefaultInstance();
  RotateAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  RotateAnimationClip::default_instance_->InitAsDefaultInstance();
  TranslateAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  TranslateAnimationClip::default_instance_->InitAsDefaultInstance();
  ScaleAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  ScaleAnimationClip::default_instance_->InitAsDefaultInstance();
  ShearAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  ShearAnimationClip::default_instance_->InitAsDefaultInstance();
  SpriteSequenceAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  SpriteSequenceAnimationClip::default_instance_->InitAsDefaultInstance();
  ColorAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  ColorAnimationClip::default_instance_->InitAsDefaultInstance();
  TwoColorAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  TwoColorAnimationClip::default_instance_->InitAsDefaultInstance();
  DrawOrderAnimationKeyFrame::default_instance_->InitAsDefaultInstance();
  DrawOrderAnimationClip::default_instance_->InitAsDefaultInstance();
  AnimationClip::default_instance_->InitAsDefaultInstance();
  Animation::default_instance_->InitAsDefaultInstance();
  BakedMeshData::default_instance_->InitAsDefaultInstance();
  BakedKeyFrame::default_instance_->InitAsDefaultInstance();
  BakedAnimationData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Animation_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Animation_2eproto {
  StaticDescriptorInitializer_Animation_2eproto() {
    protobuf_AddDesc_Animation_2eproto();
  }
} static_descriptor_initializer_Animation_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Curve::kKeyPointsFieldNumber;
#endif  // !_MSC_VER

Curve::Curve()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Curve::InitAsDefaultInstance() {
}

Curve::Curve(const Curve& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Curve::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Curve::~Curve() {
  SharedDtor();
}

void Curve::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Curve::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Curve& Curve::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

Curve* Curve::default_instance_ = NULL;

Curve* Curve::New() const {
  return new Curve;
}

void Curve::Clear() {
  keypoints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Curve::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.Vector4f KeyPoints = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_KeyPoints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_keypoints()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_KeyPoints;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Curve::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.Vector4f KeyPoints = 1;
  for (int i = 0; i < this->keypoints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->keypoints(i), output);
  }
  
}

int Curve::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.Vector4f KeyPoints = 1;
  total_size += 1 * this->keypoints_size();
  for (int i = 0; i < this->keypoints_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keypoints(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Curve::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Curve*>(&from));
}

void Curve::MergeFrom(const Curve& from) {
  GOOGLE_CHECK_NE(&from, this);
  keypoints_.MergeFrom(from.keypoints_);
}

void Curve::CopyFrom(const Curve& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Curve::IsInitialized() const {
  
  for (int i = 0; i < keypoints_size(); i++) {
    if (!this->keypoints(i).IsInitialized()) return false;
  }
  return true;
}

void Curve::Swap(Curve* other) {
  if (other != this) {
    keypoints_.Swap(&other->keypoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Curve::GetTypeName() const {
  return "Serializer.Curve";
}


// ===================================================================

#ifndef _MSC_VER
const int CubicBezier::kP1FieldNumber;
const int CubicBezier::kP2FieldNumber;
#endif  // !_MSC_VER

CubicBezier::CubicBezier()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CubicBezier::InitAsDefaultInstance() {
  p1_ = const_cast< ::Serializer::Vector2f*>(&::Serializer::Vector2f::default_instance());
  p2_ = const_cast< ::Serializer::Vector2f*>(&::Serializer::Vector2f::default_instance());
}

CubicBezier::CubicBezier(const CubicBezier& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CubicBezier::SharedCtor() {
  _cached_size_ = 0;
  p1_ = NULL;
  p2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CubicBezier::~CubicBezier() {
  SharedDtor();
}

void CubicBezier::SharedDtor() {
  if (this != default_instance_) {
    delete p1_;
    delete p2_;
  }
}

void CubicBezier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CubicBezier& CubicBezier::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

CubicBezier* CubicBezier::default_instance_ = NULL;

CubicBezier* CubicBezier::New() const {
  return new CubicBezier;
}

void CubicBezier::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_p1()) {
      if (p1_ != NULL) p1_->::Serializer::Vector2f::Clear();
    }
    if (has_p2()) {
      if (p2_ != NULL) p2_->::Serializer::Vector2f::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CubicBezier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Serializer.Vector2f p1 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_p1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_p2;
        break;
      }
      
      // optional .Serializer.Vector2f p2 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_p2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_p2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CubicBezier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Serializer.Vector2f p1 = 1;
  if (has_p1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->p1(), output);
  }
  
  // optional .Serializer.Vector2f p2 = 2;
  if (has_p2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->p2(), output);
  }
  
}

int CubicBezier::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Serializer.Vector2f p1 = 1;
    if (has_p1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->p1());
    }
    
    // optional .Serializer.Vector2f p2 = 2;
    if (has_p2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->p2());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CubicBezier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CubicBezier*>(&from));
}

void CubicBezier::MergeFrom(const CubicBezier& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_p1()) {
      mutable_p1()->::Serializer::Vector2f::MergeFrom(from.p1());
    }
    if (from.has_p2()) {
      mutable_p2()->::Serializer::Vector2f::MergeFrom(from.p2());
    }
  }
}

void CubicBezier::CopyFrom(const CubicBezier& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CubicBezier::IsInitialized() const {
  
  if (has_p1()) {
    if (!this->p1().IsInitialized()) return false;
  }
  if (has_p2()) {
    if (!this->p2().IsInitialized()) return false;
  }
  return true;
}

void CubicBezier::Swap(CubicBezier* other) {
  if (other != this) {
    std::swap(p1_, other->p1_);
    std::swap(p2_, other->p2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CubicBezier::GetTypeName() const {
  return "Serializer.CubicBezier";
}


// ===================================================================

#ifndef _MSC_VER
const int RotateAnimationKeyFrame::kTimeFieldNumber;
const int RotateAnimationKeyFrame::kInterpolationTypeFieldNumber;
const int RotateAnimationKeyFrame::kExternalArgsFieldNumber;
const int RotateAnimationKeyFrame::kRotationFieldNumber;
#endif  // !_MSC_VER

RotateAnimationKeyFrame::RotateAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RotateAnimationKeyFrame::InitAsDefaultInstance() {
}

RotateAnimationKeyFrame::RotateAnimationKeyFrame(const RotateAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RotateAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  interpolation_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RotateAnimationKeyFrame::~RotateAnimationKeyFrame() {
  SharedDtor();
}

void RotateAnimationKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RotateAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RotateAnimationKeyFrame& RotateAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

RotateAnimationKeyFrame* RotateAnimationKeyFrame::default_instance_ = NULL;

RotateAnimationKeyFrame* RotateAnimationKeyFrame::New() const {
  return new RotateAnimationKeyFrame;
}

void RotateAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    interpolation_type_ = 0;
  }
  external_args_.Clear();
  rotation_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RotateAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interpolation_type;
        break;
      }
      
      // optional int32 interpolation_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interpolation_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interpolation_type_)));
          set_has_interpolation_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        break;
      }
      
      // repeated float external_args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_external_args:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_external_args())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_external_args())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        if (input->ExpectTag(37)) goto parse_rotation;
        break;
      }
      
      // repeated float rotation = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_rotation())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_rotation())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_rotation;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RotateAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // optional int32 interpolation_type = 2;
  if (has_interpolation_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interpolation_type(), output);
  }
  
  // repeated float external_args = 3;
  for (int i = 0; i < this->external_args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->external_args(i), output);
  }
  
  // repeated float rotation = 4;
  for (int i = 0; i < this->rotation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->rotation(i), output);
  }
  
}

int RotateAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
    // optional int32 interpolation_type = 2;
    if (has_interpolation_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interpolation_type());
    }
    
  }
  // repeated float external_args = 3;
  {
    int data_size = 0;
    data_size = 4 * this->external_args_size();
    total_size += 1 * this->external_args_size() + data_size;
  }
  
  // repeated float rotation = 4;
  {
    int data_size = 0;
    data_size = 4 * this->rotation_size();
    total_size += 1 * this->rotation_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RotateAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RotateAnimationKeyFrame*>(&from));
}

void RotateAnimationKeyFrame::MergeFrom(const RotateAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  external_args_.MergeFrom(from.external_args_);
  rotation_.MergeFrom(from.rotation_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_interpolation_type()) {
      set_interpolation_type(from.interpolation_type());
    }
  }
}

void RotateAnimationKeyFrame::CopyFrom(const RotateAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RotateAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void RotateAnimationKeyFrame::Swap(RotateAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(interpolation_type_, other->interpolation_type_);
    external_args_.Swap(&other->external_args_);
    rotation_.Swap(&other->rotation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RotateAnimationKeyFrame::GetTypeName() const {
  return "Serializer.RotateAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int RotateAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

RotateAnimationClip::RotateAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RotateAnimationClip::InitAsDefaultInstance() {
}

RotateAnimationClip::RotateAnimationClip(const RotateAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RotateAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RotateAnimationClip::~RotateAnimationClip() {
  SharedDtor();
}

void RotateAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RotateAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RotateAnimationClip& RotateAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

RotateAnimationClip* RotateAnimationClip::default_instance_ = NULL;

RotateAnimationClip* RotateAnimationClip::New() const {
  return new RotateAnimationClip;
}

void RotateAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RotateAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.RotateAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RotateAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.RotateAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int RotateAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.RotateAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RotateAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RotateAnimationClip*>(&from));
}

void RotateAnimationClip::MergeFrom(const RotateAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void RotateAnimationClip::CopyFrom(const RotateAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RotateAnimationClip::IsInitialized() const {
  
  return true;
}

void RotateAnimationClip::Swap(RotateAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RotateAnimationClip::GetTypeName() const {
  return "Serializer.RotateAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int TranslateAnimationKeyFrame::kTimeFieldNumber;
const int TranslateAnimationKeyFrame::kInterpolationTypeFieldNumber;
const int TranslateAnimationKeyFrame::kExternalArgsFieldNumber;
const int TranslateAnimationKeyFrame::kTranslationFieldNumber;
#endif  // !_MSC_VER

TranslateAnimationKeyFrame::TranslateAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TranslateAnimationKeyFrame::InitAsDefaultInstance() {
}

TranslateAnimationKeyFrame::TranslateAnimationKeyFrame(const TranslateAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TranslateAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  interpolation_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TranslateAnimationKeyFrame::~TranslateAnimationKeyFrame() {
  SharedDtor();
}

void TranslateAnimationKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TranslateAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TranslateAnimationKeyFrame& TranslateAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

TranslateAnimationKeyFrame* TranslateAnimationKeyFrame::default_instance_ = NULL;

TranslateAnimationKeyFrame* TranslateAnimationKeyFrame::New() const {
  return new TranslateAnimationKeyFrame;
}

void TranslateAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    interpolation_type_ = 0;
  }
  external_args_.Clear();
  translation_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TranslateAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interpolation_type;
        break;
      }
      
      // optional int32 interpolation_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interpolation_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interpolation_type_)));
          set_has_interpolation_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        break;
      }
      
      // repeated float external_args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_external_args:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_external_args())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_external_args())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        if (input->ExpectTag(37)) goto parse_translation;
        break;
      }
      
      // repeated float translation = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_translation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_translation())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_translation())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_translation;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TranslateAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // optional int32 interpolation_type = 2;
  if (has_interpolation_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interpolation_type(), output);
  }
  
  // repeated float external_args = 3;
  for (int i = 0; i < this->external_args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->external_args(i), output);
  }
  
  // repeated float translation = 4;
  for (int i = 0; i < this->translation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->translation(i), output);
  }
  
}

int TranslateAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
    // optional int32 interpolation_type = 2;
    if (has_interpolation_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interpolation_type());
    }
    
  }
  // repeated float external_args = 3;
  {
    int data_size = 0;
    data_size = 4 * this->external_args_size();
    total_size += 1 * this->external_args_size() + data_size;
  }
  
  // repeated float translation = 4;
  {
    int data_size = 0;
    data_size = 4 * this->translation_size();
    total_size += 1 * this->translation_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TranslateAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TranslateAnimationKeyFrame*>(&from));
}

void TranslateAnimationKeyFrame::MergeFrom(const TranslateAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  external_args_.MergeFrom(from.external_args_);
  translation_.MergeFrom(from.translation_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_interpolation_type()) {
      set_interpolation_type(from.interpolation_type());
    }
  }
}

void TranslateAnimationKeyFrame::CopyFrom(const TranslateAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranslateAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void TranslateAnimationKeyFrame::Swap(TranslateAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(interpolation_type_, other->interpolation_type_);
    external_args_.Swap(&other->external_args_);
    translation_.Swap(&other->translation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TranslateAnimationKeyFrame::GetTypeName() const {
  return "Serializer.TranslateAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int TranslateAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

TranslateAnimationClip::TranslateAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TranslateAnimationClip::InitAsDefaultInstance() {
}

TranslateAnimationClip::TranslateAnimationClip(const TranslateAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TranslateAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TranslateAnimationClip::~TranslateAnimationClip() {
  SharedDtor();
}

void TranslateAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TranslateAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TranslateAnimationClip& TranslateAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

TranslateAnimationClip* TranslateAnimationClip::default_instance_ = NULL;

TranslateAnimationClip* TranslateAnimationClip::New() const {
  return new TranslateAnimationClip;
}

void TranslateAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TranslateAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.TranslateAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TranslateAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.TranslateAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int TranslateAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.TranslateAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TranslateAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TranslateAnimationClip*>(&from));
}

void TranslateAnimationClip::MergeFrom(const TranslateAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void TranslateAnimationClip::CopyFrom(const TranslateAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranslateAnimationClip::IsInitialized() const {
  
  return true;
}

void TranslateAnimationClip::Swap(TranslateAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TranslateAnimationClip::GetTypeName() const {
  return "Serializer.TranslateAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int ScaleAnimationKeyFrame::kTimeFieldNumber;
const int ScaleAnimationKeyFrame::kInterpolationTypeFieldNumber;
const int ScaleAnimationKeyFrame::kExternalArgsFieldNumber;
const int ScaleAnimationKeyFrame::kScaleFieldNumber;
#endif  // !_MSC_VER

ScaleAnimationKeyFrame::ScaleAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ScaleAnimationKeyFrame::InitAsDefaultInstance() {
}

ScaleAnimationKeyFrame::ScaleAnimationKeyFrame(const ScaleAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ScaleAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  interpolation_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScaleAnimationKeyFrame::~ScaleAnimationKeyFrame() {
  SharedDtor();
}

void ScaleAnimationKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ScaleAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ScaleAnimationKeyFrame& ScaleAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

ScaleAnimationKeyFrame* ScaleAnimationKeyFrame::default_instance_ = NULL;

ScaleAnimationKeyFrame* ScaleAnimationKeyFrame::New() const {
  return new ScaleAnimationKeyFrame;
}

void ScaleAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    interpolation_type_ = 0;
  }
  external_args_.Clear();
  scale_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ScaleAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interpolation_type;
        break;
      }
      
      // optional int32 interpolation_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interpolation_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interpolation_type_)));
          set_has_interpolation_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        break;
      }
      
      // repeated float external_args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_external_args:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_external_args())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_external_args())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        if (input->ExpectTag(37)) goto parse_scale;
        break;
      }
      
      // repeated float scale = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_scale())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_scale())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_scale;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ScaleAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // optional int32 interpolation_type = 2;
  if (has_interpolation_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interpolation_type(), output);
  }
  
  // repeated float external_args = 3;
  for (int i = 0; i < this->external_args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->external_args(i), output);
  }
  
  // repeated float scale = 4;
  for (int i = 0; i < this->scale_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->scale(i), output);
  }
  
}

int ScaleAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
    // optional int32 interpolation_type = 2;
    if (has_interpolation_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interpolation_type());
    }
    
  }
  // repeated float external_args = 3;
  {
    int data_size = 0;
    data_size = 4 * this->external_args_size();
    total_size += 1 * this->external_args_size() + data_size;
  }
  
  // repeated float scale = 4;
  {
    int data_size = 0;
    data_size = 4 * this->scale_size();
    total_size += 1 * this->scale_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScaleAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ScaleAnimationKeyFrame*>(&from));
}

void ScaleAnimationKeyFrame::MergeFrom(const ScaleAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  external_args_.MergeFrom(from.external_args_);
  scale_.MergeFrom(from.scale_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_interpolation_type()) {
      set_interpolation_type(from.interpolation_type());
    }
  }
}

void ScaleAnimationKeyFrame::CopyFrom(const ScaleAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScaleAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void ScaleAnimationKeyFrame::Swap(ScaleAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(interpolation_type_, other->interpolation_type_);
    external_args_.Swap(&other->external_args_);
    scale_.Swap(&other->scale_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ScaleAnimationKeyFrame::GetTypeName() const {
  return "Serializer.ScaleAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int ScaleAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

ScaleAnimationClip::ScaleAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ScaleAnimationClip::InitAsDefaultInstance() {
}

ScaleAnimationClip::ScaleAnimationClip(const ScaleAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ScaleAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScaleAnimationClip::~ScaleAnimationClip() {
  SharedDtor();
}

void ScaleAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ScaleAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ScaleAnimationClip& ScaleAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

ScaleAnimationClip* ScaleAnimationClip::default_instance_ = NULL;

ScaleAnimationClip* ScaleAnimationClip::New() const {
  return new ScaleAnimationClip;
}

void ScaleAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ScaleAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.ScaleAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ScaleAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.ScaleAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int ScaleAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.ScaleAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScaleAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ScaleAnimationClip*>(&from));
}

void ScaleAnimationClip::MergeFrom(const ScaleAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void ScaleAnimationClip::CopyFrom(const ScaleAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScaleAnimationClip::IsInitialized() const {
  
  return true;
}

void ScaleAnimationClip::Swap(ScaleAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ScaleAnimationClip::GetTypeName() const {
  return "Serializer.ScaleAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int ShearAnimationKeyFrame::kTimeFieldNumber;
const int ShearAnimationKeyFrame::kInterpolationTypeFieldNumber;
const int ShearAnimationKeyFrame::kExternalArgsFieldNumber;
const int ShearAnimationKeyFrame::kShearFieldNumber;
#endif  // !_MSC_VER

ShearAnimationKeyFrame::ShearAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShearAnimationKeyFrame::InitAsDefaultInstance() {
}

ShearAnimationKeyFrame::ShearAnimationKeyFrame(const ShearAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShearAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  interpolation_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShearAnimationKeyFrame::~ShearAnimationKeyFrame() {
  SharedDtor();
}

void ShearAnimationKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ShearAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShearAnimationKeyFrame& ShearAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

ShearAnimationKeyFrame* ShearAnimationKeyFrame::default_instance_ = NULL;

ShearAnimationKeyFrame* ShearAnimationKeyFrame::New() const {
  return new ShearAnimationKeyFrame;
}

void ShearAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    interpolation_type_ = 0;
  }
  external_args_.Clear();
  shear_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShearAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interpolation_type;
        break;
      }
      
      // optional int32 interpolation_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interpolation_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interpolation_type_)));
          set_has_interpolation_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        break;
      }
      
      // repeated float external_args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_external_args:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_external_args())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_external_args())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        if (input->ExpectTag(37)) goto parse_shear;
        break;
      }
      
      // repeated float shear = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_shear:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_shear())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_shear())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_shear;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShearAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // optional int32 interpolation_type = 2;
  if (has_interpolation_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interpolation_type(), output);
  }
  
  // repeated float external_args = 3;
  for (int i = 0; i < this->external_args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->external_args(i), output);
  }
  
  // repeated float shear = 4;
  for (int i = 0; i < this->shear_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->shear(i), output);
  }
  
}

int ShearAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
    // optional int32 interpolation_type = 2;
    if (has_interpolation_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interpolation_type());
    }
    
  }
  // repeated float external_args = 3;
  {
    int data_size = 0;
    data_size = 4 * this->external_args_size();
    total_size += 1 * this->external_args_size() + data_size;
  }
  
  // repeated float shear = 4;
  {
    int data_size = 0;
    data_size = 4 * this->shear_size();
    total_size += 1 * this->shear_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShearAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShearAnimationKeyFrame*>(&from));
}

void ShearAnimationKeyFrame::MergeFrom(const ShearAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  external_args_.MergeFrom(from.external_args_);
  shear_.MergeFrom(from.shear_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_interpolation_type()) {
      set_interpolation_type(from.interpolation_type());
    }
  }
}

void ShearAnimationKeyFrame::CopyFrom(const ShearAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShearAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void ShearAnimationKeyFrame::Swap(ShearAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(interpolation_type_, other->interpolation_type_);
    external_args_.Swap(&other->external_args_);
    shear_.Swap(&other->shear_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShearAnimationKeyFrame::GetTypeName() const {
  return "Serializer.ShearAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int ShearAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

ShearAnimationClip::ShearAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShearAnimationClip::InitAsDefaultInstance() {
}

ShearAnimationClip::ShearAnimationClip(const ShearAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShearAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShearAnimationClip::~ShearAnimationClip() {
  SharedDtor();
}

void ShearAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ShearAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShearAnimationClip& ShearAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

ShearAnimationClip* ShearAnimationClip::default_instance_ = NULL;

ShearAnimationClip* ShearAnimationClip::New() const {
  return new ShearAnimationClip;
}

void ShearAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShearAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.ShearAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShearAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.ShearAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int ShearAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.ShearAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShearAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShearAnimationClip*>(&from));
}

void ShearAnimationClip::MergeFrom(const ShearAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void ShearAnimationClip::CopyFrom(const ShearAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShearAnimationClip::IsInitialized() const {
  
  return true;
}

void ShearAnimationClip::Swap(ShearAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShearAnimationClip::GetTypeName() const {
  return "Serializer.ShearAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int SpriteSequenceAnimationKeyFrame::kTimeFieldNumber;
const int SpriteSequenceAnimationKeyFrame::kImageNameFieldNumber;
#endif  // !_MSC_VER

SpriteSequenceAnimationKeyFrame::SpriteSequenceAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SpriteSequenceAnimationKeyFrame::InitAsDefaultInstance() {
}

SpriteSequenceAnimationKeyFrame::SpriteSequenceAnimationKeyFrame(const SpriteSequenceAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SpriteSequenceAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SpriteSequenceAnimationKeyFrame::~SpriteSequenceAnimationKeyFrame() {
  SharedDtor();
}

void SpriteSequenceAnimationKeyFrame::SharedDtor() {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    delete image_name_;
  }
  if (this != default_instance_) {
  }
}

void SpriteSequenceAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SpriteSequenceAnimationKeyFrame& SpriteSequenceAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

SpriteSequenceAnimationKeyFrame* SpriteSequenceAnimationKeyFrame::default_instance_ = NULL;

SpriteSequenceAnimationKeyFrame* SpriteSequenceAnimationKeyFrame::New() const {
  return new SpriteSequenceAnimationKeyFrame;
}

void SpriteSequenceAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_image_name()) {
      if (image_name_ != &::google::protobuf::internal::kEmptyString) {
        image_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SpriteSequenceAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_image_name;
        break;
      }
      
      // optional string image_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SpriteSequenceAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // optional string image_name = 2;
  if (has_image_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->image_name(), output);
  }
  
}

int SpriteSequenceAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
    // optional string image_name = 2;
    if (has_image_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->image_name());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpriteSequenceAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SpriteSequenceAnimationKeyFrame*>(&from));
}

void SpriteSequenceAnimationKeyFrame::MergeFrom(const SpriteSequenceAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_image_name()) {
      set_image_name(from.image_name());
    }
  }
}

void SpriteSequenceAnimationKeyFrame::CopyFrom(const SpriteSequenceAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpriteSequenceAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void SpriteSequenceAnimationKeyFrame::Swap(SpriteSequenceAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(image_name_, other->image_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SpriteSequenceAnimationKeyFrame::GetTypeName() const {
  return "Serializer.SpriteSequenceAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int SpriteSequenceAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

SpriteSequenceAnimationClip::SpriteSequenceAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SpriteSequenceAnimationClip::InitAsDefaultInstance() {
}

SpriteSequenceAnimationClip::SpriteSequenceAnimationClip(const SpriteSequenceAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SpriteSequenceAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SpriteSequenceAnimationClip::~SpriteSequenceAnimationClip() {
  SharedDtor();
}

void SpriteSequenceAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SpriteSequenceAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SpriteSequenceAnimationClip& SpriteSequenceAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

SpriteSequenceAnimationClip* SpriteSequenceAnimationClip::default_instance_ = NULL;

SpriteSequenceAnimationClip* SpriteSequenceAnimationClip::New() const {
  return new SpriteSequenceAnimationClip;
}

void SpriteSequenceAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SpriteSequenceAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.SpriteSequenceAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SpriteSequenceAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.SpriteSequenceAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int SpriteSequenceAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.SpriteSequenceAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpriteSequenceAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SpriteSequenceAnimationClip*>(&from));
}

void SpriteSequenceAnimationClip::MergeFrom(const SpriteSequenceAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void SpriteSequenceAnimationClip::CopyFrom(const SpriteSequenceAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpriteSequenceAnimationClip::IsInitialized() const {
  
  return true;
}

void SpriteSequenceAnimationClip::Swap(SpriteSequenceAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SpriteSequenceAnimationClip::GetTypeName() const {
  return "Serializer.SpriteSequenceAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int ColorAnimationKeyFrame::kTimeFieldNumber;
const int ColorAnimationKeyFrame::kInterpolationTypeFieldNumber;
const int ColorAnimationKeyFrame::kExternalArgsFieldNumber;
const int ColorAnimationKeyFrame::kColorFieldNumber;
#endif  // !_MSC_VER

ColorAnimationKeyFrame::ColorAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ColorAnimationKeyFrame::InitAsDefaultInstance() {
}

ColorAnimationKeyFrame::ColorAnimationKeyFrame(const ColorAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ColorAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  interpolation_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColorAnimationKeyFrame::~ColorAnimationKeyFrame() {
  SharedDtor();
}

void ColorAnimationKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ColorAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ColorAnimationKeyFrame& ColorAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

ColorAnimationKeyFrame* ColorAnimationKeyFrame::default_instance_ = NULL;

ColorAnimationKeyFrame* ColorAnimationKeyFrame::New() const {
  return new ColorAnimationKeyFrame;
}

void ColorAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    interpolation_type_ = 0;
  }
  external_args_.Clear();
  color_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ColorAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interpolation_type;
        break;
      }
      
      // optional int32 interpolation_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interpolation_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interpolation_type_)));
          set_has_interpolation_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        break;
      }
      
      // repeated float external_args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_external_args:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_external_args())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_external_args())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        if (input->ExpectTag(37)) goto parse_color;
        break;
      }
      
      // repeated float color = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_color())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_color())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_color;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColorAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // optional int32 interpolation_type = 2;
  if (has_interpolation_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interpolation_type(), output);
  }
  
  // repeated float external_args = 3;
  for (int i = 0; i < this->external_args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->external_args(i), output);
  }
  
  // repeated float color = 4;
  for (int i = 0; i < this->color_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->color(i), output);
  }
  
}

int ColorAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
    // optional int32 interpolation_type = 2;
    if (has_interpolation_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interpolation_type());
    }
    
  }
  // repeated float external_args = 3;
  {
    int data_size = 0;
    data_size = 4 * this->external_args_size();
    total_size += 1 * this->external_args_size() + data_size;
  }
  
  // repeated float color = 4;
  {
    int data_size = 0;
    data_size = 4 * this->color_size();
    total_size += 1 * this->color_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColorAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ColorAnimationKeyFrame*>(&from));
}

void ColorAnimationKeyFrame::MergeFrom(const ColorAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  external_args_.MergeFrom(from.external_args_);
  color_.MergeFrom(from.color_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_interpolation_type()) {
      set_interpolation_type(from.interpolation_type());
    }
  }
}

void ColorAnimationKeyFrame::CopyFrom(const ColorAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void ColorAnimationKeyFrame::Swap(ColorAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(interpolation_type_, other->interpolation_type_);
    external_args_.Swap(&other->external_args_);
    color_.Swap(&other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ColorAnimationKeyFrame::GetTypeName() const {
  return "Serializer.ColorAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int ColorAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

ColorAnimationClip::ColorAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ColorAnimationClip::InitAsDefaultInstance() {
}

ColorAnimationClip::ColorAnimationClip(const ColorAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ColorAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColorAnimationClip::~ColorAnimationClip() {
  SharedDtor();
}

void ColorAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ColorAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ColorAnimationClip& ColorAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

ColorAnimationClip* ColorAnimationClip::default_instance_ = NULL;

ColorAnimationClip* ColorAnimationClip::New() const {
  return new ColorAnimationClip;
}

void ColorAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ColorAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.ColorAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColorAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.ColorAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int ColorAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.ColorAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColorAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ColorAnimationClip*>(&from));
}

void ColorAnimationClip::MergeFrom(const ColorAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void ColorAnimationClip::CopyFrom(const ColorAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorAnimationClip::IsInitialized() const {
  
  return true;
}

void ColorAnimationClip::Swap(ColorAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ColorAnimationClip::GetTypeName() const {
  return "Serializer.ColorAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int TwoColorAnimationKeyFrame::kTimeFieldNumber;
const int TwoColorAnimationKeyFrame::kInterpolationTypeFieldNumber;
const int TwoColorAnimationKeyFrame::kExternalArgsFieldNumber;
const int TwoColorAnimationKeyFrame::kLightFieldNumber;
const int TwoColorAnimationKeyFrame::kDarkFieldNumber;
#endif  // !_MSC_VER

TwoColorAnimationKeyFrame::TwoColorAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TwoColorAnimationKeyFrame::InitAsDefaultInstance() {
}

TwoColorAnimationKeyFrame::TwoColorAnimationKeyFrame(const TwoColorAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TwoColorAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  interpolation_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TwoColorAnimationKeyFrame::~TwoColorAnimationKeyFrame() {
  SharedDtor();
}

void TwoColorAnimationKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TwoColorAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TwoColorAnimationKeyFrame& TwoColorAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

TwoColorAnimationKeyFrame* TwoColorAnimationKeyFrame::default_instance_ = NULL;

TwoColorAnimationKeyFrame* TwoColorAnimationKeyFrame::New() const {
  return new TwoColorAnimationKeyFrame;
}

void TwoColorAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    interpolation_type_ = 0;
  }
  external_args_.Clear();
  light_.Clear();
  dark_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TwoColorAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interpolation_type;
        break;
      }
      
      // optional int32 interpolation_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interpolation_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interpolation_type_)));
          set_has_interpolation_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        break;
      }
      
      // repeated float external_args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_external_args:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_external_args())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_external_args())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_external_args;
        if (input->ExpectTag(37)) goto parse_light;
        break;
      }
      
      // repeated float light = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_light:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_light())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_light())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_light;
        if (input->ExpectTag(45)) goto parse_dark;
        break;
      }
      
      // repeated float dark = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_dark:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 45, input, this->mutable_dark())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_dark())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_dark;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TwoColorAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // optional int32 interpolation_type = 2;
  if (has_interpolation_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interpolation_type(), output);
  }
  
  // repeated float external_args = 3;
  for (int i = 0; i < this->external_args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->external_args(i), output);
  }
  
  // repeated float light = 4;
  for (int i = 0; i < this->light_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->light(i), output);
  }
  
  // repeated float dark = 5;
  for (int i = 0; i < this->dark_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      5, this->dark(i), output);
  }
  
}

int TwoColorAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
    // optional int32 interpolation_type = 2;
    if (has_interpolation_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interpolation_type());
    }
    
  }
  // repeated float external_args = 3;
  {
    int data_size = 0;
    data_size = 4 * this->external_args_size();
    total_size += 1 * this->external_args_size() + data_size;
  }
  
  // repeated float light = 4;
  {
    int data_size = 0;
    data_size = 4 * this->light_size();
    total_size += 1 * this->light_size() + data_size;
  }
  
  // repeated float dark = 5;
  {
    int data_size = 0;
    data_size = 4 * this->dark_size();
    total_size += 1 * this->dark_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TwoColorAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TwoColorAnimationKeyFrame*>(&from));
}

void TwoColorAnimationKeyFrame::MergeFrom(const TwoColorAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  external_args_.MergeFrom(from.external_args_);
  light_.MergeFrom(from.light_);
  dark_.MergeFrom(from.dark_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_interpolation_type()) {
      set_interpolation_type(from.interpolation_type());
    }
  }
}

void TwoColorAnimationKeyFrame::CopyFrom(const TwoColorAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TwoColorAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void TwoColorAnimationKeyFrame::Swap(TwoColorAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(interpolation_type_, other->interpolation_type_);
    external_args_.Swap(&other->external_args_);
    light_.Swap(&other->light_);
    dark_.Swap(&other->dark_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TwoColorAnimationKeyFrame::GetTypeName() const {
  return "Serializer.TwoColorAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int TwoColorAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

TwoColorAnimationClip::TwoColorAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TwoColorAnimationClip::InitAsDefaultInstance() {
}

TwoColorAnimationClip::TwoColorAnimationClip(const TwoColorAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TwoColorAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TwoColorAnimationClip::~TwoColorAnimationClip() {
  SharedDtor();
}

void TwoColorAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TwoColorAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TwoColorAnimationClip& TwoColorAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

TwoColorAnimationClip* TwoColorAnimationClip::default_instance_ = NULL;

TwoColorAnimationClip* TwoColorAnimationClip::New() const {
  return new TwoColorAnimationClip;
}

void TwoColorAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TwoColorAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.TwoColorAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TwoColorAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.TwoColorAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int TwoColorAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.TwoColorAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TwoColorAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TwoColorAnimationClip*>(&from));
}

void TwoColorAnimationClip::MergeFrom(const TwoColorAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void TwoColorAnimationClip::CopyFrom(const TwoColorAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TwoColorAnimationClip::IsInitialized() const {
  
  return true;
}

void TwoColorAnimationClip::Swap(TwoColorAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TwoColorAnimationClip::GetTypeName() const {
  return "Serializer.TwoColorAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int DrawOrderAnimationKeyFrame::kTimeFieldNumber;
const int DrawOrderAnimationKeyFrame::kDrawOrderFieldNumber;
#endif  // !_MSC_VER

DrawOrderAnimationKeyFrame::DrawOrderAnimationKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DrawOrderAnimationKeyFrame::InitAsDefaultInstance() {
}

DrawOrderAnimationKeyFrame::DrawOrderAnimationKeyFrame(const DrawOrderAnimationKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DrawOrderAnimationKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DrawOrderAnimationKeyFrame::~DrawOrderAnimationKeyFrame() {
  SharedDtor();
}

void DrawOrderAnimationKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DrawOrderAnimationKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DrawOrderAnimationKeyFrame& DrawOrderAnimationKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

DrawOrderAnimationKeyFrame* DrawOrderAnimationKeyFrame::default_instance_ = NULL;

DrawOrderAnimationKeyFrame* DrawOrderAnimationKeyFrame::New() const {
  return new DrawOrderAnimationKeyFrame;
}

void DrawOrderAnimationKeyFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
  }
  draw_order_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DrawOrderAnimationKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_draw_order;
        break;
      }
      
      // repeated string draw_order = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_draw_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_draw_order()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_draw_order;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DrawOrderAnimationKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }
  
  // repeated string draw_order = 2;
  for (int i = 0; i < this->draw_order_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->draw_order(i), output);
  }
  
}

int DrawOrderAnimationKeyFrame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }
    
  }
  // repeated string draw_order = 2;
  total_size += 1 * this->draw_order_size();
  for (int i = 0; i < this->draw_order_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->draw_order(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DrawOrderAnimationKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DrawOrderAnimationKeyFrame*>(&from));
}

void DrawOrderAnimationKeyFrame::MergeFrom(const DrawOrderAnimationKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  draw_order_.MergeFrom(from.draw_order_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void DrawOrderAnimationKeyFrame::CopyFrom(const DrawOrderAnimationKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawOrderAnimationKeyFrame::IsInitialized() const {
  
  return true;
}

void DrawOrderAnimationKeyFrame::Swap(DrawOrderAnimationKeyFrame* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    draw_order_.Swap(&other->draw_order_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DrawOrderAnimationKeyFrame::GetTypeName() const {
  return "Serializer.DrawOrderAnimationKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int DrawOrderAnimationClip::kKeyFramesFieldNumber;
#endif  // !_MSC_VER

DrawOrderAnimationClip::DrawOrderAnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DrawOrderAnimationClip::InitAsDefaultInstance() {
}

DrawOrderAnimationClip::DrawOrderAnimationClip(const DrawOrderAnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DrawOrderAnimationClip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DrawOrderAnimationClip::~DrawOrderAnimationClip() {
  SharedDtor();
}

void DrawOrderAnimationClip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DrawOrderAnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DrawOrderAnimationClip& DrawOrderAnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

DrawOrderAnimationClip* DrawOrderAnimationClip::default_instance_ = NULL;

DrawOrderAnimationClip* DrawOrderAnimationClip::New() const {
  return new DrawOrderAnimationClip;
}

void DrawOrderAnimationClip::Clear() {
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DrawOrderAnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.DrawOrderAnimationKeyFrame key_frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_key_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DrawOrderAnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.DrawOrderAnimationKeyFrame key_frames = 1;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->key_frames(i), output);
  }
  
}

int DrawOrderAnimationClip::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.DrawOrderAnimationKeyFrame key_frames = 1;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DrawOrderAnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DrawOrderAnimationClip*>(&from));
}

void DrawOrderAnimationClip::MergeFrom(const DrawOrderAnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
}

void DrawOrderAnimationClip::CopyFrom(const DrawOrderAnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawOrderAnimationClip::IsInitialized() const {
  
  return true;
}

void DrawOrderAnimationClip::Swap(DrawOrderAnimationClip* other) {
  if (other != this) {
    key_frames_.Swap(&other->key_frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DrawOrderAnimationClip::GetTypeName() const {
  return "Serializer.DrawOrderAnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int AnimationClip::kTypeFieldNumber;
const int AnimationClip::kTargetFieldNumber;
const int AnimationClip::kTargetComponentFieldNumber;
const int AnimationClip::kAnimationClipDataFieldNumber;
#endif  // !_MSC_VER

AnimationClip::AnimationClip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AnimationClip::InitAsDefaultInstance() {
}

AnimationClip::AnimationClip(const AnimationClip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AnimationClip::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_component_ = 0;
  animation_clip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnimationClip::~AnimationClip() {
  SharedDtor();
}

void AnimationClip::SharedDtor() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (animation_clip_data_ != &::google::protobuf::internal::kEmptyString) {
    delete animation_clip_data_;
  }
  if (this != default_instance_) {
  }
}

void AnimationClip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AnimationClip& AnimationClip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

AnimationClip* AnimationClip::default_instance_ = NULL;

AnimationClip* AnimationClip::New() const {
  return new AnimationClip;
}

void AnimationClip::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_target()) {
      if (target_ != &::google::protobuf::internal::kEmptyString) {
        target_->clear();
      }
    }
    target_component_ = 0;
    if (has_animation_clip_data()) {
      if (animation_clip_data_ != &::google::protobuf::internal::kEmptyString) {
        animation_clip_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AnimationClip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_target;
        break;
      }
      
      // optional string target = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_target()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_component;
        break;
      }
      
      // optional int32 target_component = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_component:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_component_)));
          set_has_target_component();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_animation_clip_data;
        break;
      }
      
      // optional bytes animation_clip_data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_animation_clip_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_animation_clip_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AnimationClip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }
  
  // optional string target = 2;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->target(), output);
  }
  
  // optional int32 target_component = 3;
  if (has_target_component()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->target_component(), output);
  }
  
  // optional bytes animation_clip_data = 4;
  if (has_animation_clip_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->animation_clip_data(), output);
  }
  
}

int AnimationClip::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }
    
    // optional string target = 2;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->target());
    }
    
    // optional int32 target_component = 3;
    if (has_target_component()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target_component());
    }
    
    // optional bytes animation_clip_data = 4;
    if (has_animation_clip_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->animation_clip_data());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnimationClip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AnimationClip*>(&from));
}

void AnimationClip::MergeFrom(const AnimationClip& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_target()) {
      set_target(from.target());
    }
    if (from.has_target_component()) {
      set_target_component(from.target_component());
    }
    if (from.has_animation_clip_data()) {
      set_animation_clip_data(from.animation_clip_data());
    }
  }
}

void AnimationClip::CopyFrom(const AnimationClip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnimationClip::IsInitialized() const {
  
  return true;
}

void AnimationClip::Swap(AnimationClip* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(target_, other->target_);
    std::swap(target_component_, other->target_component_);
    std::swap(animation_clip_data_, other->animation_clip_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AnimationClip::GetTypeName() const {
  return "Serializer.AnimationClip";
}


// ===================================================================

#ifndef _MSC_VER
const int Animation::kNameFieldNumber;
const int Animation::kDurationFieldNumber;
const int Animation::kAnimationClipsFieldNumber;
#endif  // !_MSC_VER

Animation::Animation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Animation::InitAsDefaultInstance() {
}

Animation::Animation(const Animation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Animation::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  duration_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Animation::~Animation() {
  SharedDtor();
}

void Animation::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Animation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Animation& Animation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

Animation* Animation::default_instance_ = NULL;

Animation* Animation::New() const {
  return new Animation;
}

void Animation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    duration_ = 0;
  }
  animation_clips_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Animation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_duration;
        break;
      }
      
      // optional float duration = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_animation_clips;
        break;
      }
      
      // repeated .Serializer.AnimationClip animation_clips = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_animation_clips:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_animation_clips()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_animation_clips;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Animation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional float duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->duration(), output);
  }
  
  // repeated .Serializer.AnimationClip animation_clips = 3;
  for (int i = 0; i < this->animation_clips_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->animation_clips(i), output);
  }
  
}

int Animation::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional float duration = 2;
    if (has_duration()) {
      total_size += 1 + 4;
    }
    
  }
  // repeated .Serializer.AnimationClip animation_clips = 3;
  total_size += 1 * this->animation_clips_size();
  for (int i = 0; i < this->animation_clips_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->animation_clips(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Animation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Animation*>(&from));
}

void Animation::MergeFrom(const Animation& from) {
  GOOGLE_CHECK_NE(&from, this);
  animation_clips_.MergeFrom(from.animation_clips_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
  }
}

void Animation::CopyFrom(const Animation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Animation::IsInitialized() const {
  
  return true;
}

void Animation::Swap(Animation* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(duration_, other->duration_);
    animation_clips_.Swap(&other->animation_clips_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Animation::GetTypeName() const {
  return "Serializer.Animation";
}


// ===================================================================

#ifndef _MSC_VER
const int BakedMeshData::kVertexBufferFieldNumber;
const int BakedMeshData::kOffsetMatrixFieldNumber;
#endif  // !_MSC_VER

BakedMeshData::BakedMeshData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BakedMeshData::InitAsDefaultInstance() {
}

BakedMeshData::BakedMeshData(const BakedMeshData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BakedMeshData::SharedCtor() {
  _cached_size_ = 0;
  vertex_buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  offset_matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BakedMeshData::~BakedMeshData() {
  SharedDtor();
}

void BakedMeshData::SharedDtor() {
  if (vertex_buffer_ != &::google::protobuf::internal::kEmptyString) {
    delete vertex_buffer_;
  }
  if (offset_matrix_ != &::google::protobuf::internal::kEmptyString) {
    delete offset_matrix_;
  }
  if (this != default_instance_) {
  }
}

void BakedMeshData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BakedMeshData& BakedMeshData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

BakedMeshData* BakedMeshData::default_instance_ = NULL;

BakedMeshData* BakedMeshData::New() const {
  return new BakedMeshData;
}

void BakedMeshData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_vertex_buffer()) {
      if (vertex_buffer_ != &::google::protobuf::internal::kEmptyString) {
        vertex_buffer_->clear();
      }
    }
    if (has_offset_matrix()) {
      if (offset_matrix_ != &::google::protobuf::internal::kEmptyString) {
        offset_matrix_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BakedMeshData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes vertex_buffer = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vertex_buffer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_offset_matrix;
        break;
      }
      
      // optional bytes offset_matrix = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offset_matrix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_offset_matrix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BakedMeshData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes vertex_buffer = 1;
  if (has_vertex_buffer()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->vertex_buffer(), output);
  }
  
  // optional bytes offset_matrix = 2;
  if (has_offset_matrix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->offset_matrix(), output);
  }
  
}

int BakedMeshData::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes vertex_buffer = 1;
    if (has_vertex_buffer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vertex_buffer());
    }
    
    // optional bytes offset_matrix = 2;
    if (has_offset_matrix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->offset_matrix());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BakedMeshData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BakedMeshData*>(&from));
}

void BakedMeshData::MergeFrom(const BakedMeshData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vertex_buffer()) {
      set_vertex_buffer(from.vertex_buffer());
    }
    if (from.has_offset_matrix()) {
      set_offset_matrix(from.offset_matrix());
    }
  }
}

void BakedMeshData::CopyFrom(const BakedMeshData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BakedMeshData::IsInitialized() const {
  
  return true;
}

void BakedMeshData::Swap(BakedMeshData* other) {
  if (other != this) {
    std::swap(vertex_buffer_, other->vertex_buffer_);
    std::swap(offset_matrix_, other->offset_matrix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BakedMeshData::GetTypeName() const {
  return "Serializer.BakedMeshData";
}


// ===================================================================

#ifndef _MSC_VER
const int BakedKeyFrame::kMeshDatasFieldNumber;
#endif  // !_MSC_VER

BakedKeyFrame::BakedKeyFrame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BakedKeyFrame::InitAsDefaultInstance() {
}

BakedKeyFrame::BakedKeyFrame(const BakedKeyFrame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BakedKeyFrame::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BakedKeyFrame::~BakedKeyFrame() {
  SharedDtor();
}

void BakedKeyFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BakedKeyFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BakedKeyFrame& BakedKeyFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

BakedKeyFrame* BakedKeyFrame::default_instance_ = NULL;

BakedKeyFrame* BakedKeyFrame::New() const {
  return new BakedKeyFrame;
}

void BakedKeyFrame::Clear() {
  mesh_datas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BakedKeyFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Serializer.BakedMeshData mesh_datas = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mesh_datas:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mesh_datas()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_mesh_datas;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BakedKeyFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Serializer.BakedMeshData mesh_datas = 1;
  for (int i = 0; i < this->mesh_datas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mesh_datas(i), output);
  }
  
}

int BakedKeyFrame::ByteSize() const {
  int total_size = 0;
  
  // repeated .Serializer.BakedMeshData mesh_datas = 1;
  total_size += 1 * this->mesh_datas_size();
  for (int i = 0; i < this->mesh_datas_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mesh_datas(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BakedKeyFrame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BakedKeyFrame*>(&from));
}

void BakedKeyFrame::MergeFrom(const BakedKeyFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  mesh_datas_.MergeFrom(from.mesh_datas_);
}

void BakedKeyFrame::CopyFrom(const BakedKeyFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BakedKeyFrame::IsInitialized() const {
  
  return true;
}

void BakedKeyFrame::Swap(BakedKeyFrame* other) {
  if (other != this) {
    mesh_datas_.Swap(&other->mesh_datas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BakedKeyFrame::GetTypeName() const {
  return "Serializer.BakedKeyFrame";
}


// ===================================================================

#ifndef _MSC_VER
const int BakedAnimationData::kNameFieldNumber;
const int BakedAnimationData::kKeyFramesFieldNumber;
const int BakedAnimationData::kFrameRateFieldNumber;
#endif  // !_MSC_VER

BakedAnimationData::BakedAnimationData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BakedAnimationData::InitAsDefaultInstance() {
}

BakedAnimationData::BakedAnimationData(const BakedAnimationData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BakedAnimationData::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  frame_rate_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BakedAnimationData::~BakedAnimationData() {
  SharedDtor();
}

void BakedAnimationData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void BakedAnimationData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BakedAnimationData& BakedAnimationData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Animation_2eproto();  return *default_instance_;
}

BakedAnimationData* BakedAnimationData::default_instance_ = NULL;

BakedAnimationData* BakedAnimationData::New() const {
  return new BakedAnimationData;
}

void BakedAnimationData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    frame_rate_ = 0;
  }
  key_frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BakedAnimationData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key_frames;
        break;
      }
      
      // repeated .Serializer.BakedKeyFrame key_frames = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key_frames;
        if (input->ExpectTag(24)) goto parse_frame_rate;
        break;
      }
      
      // optional int32 frame_rate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frame_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frame_rate_)));
          set_has_frame_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BakedAnimationData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated .Serializer.BakedKeyFrame key_frames = 2;
  for (int i = 0; i < this->key_frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->key_frames(i), output);
  }
  
  // optional int32 frame_rate = 3;
  if (has_frame_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->frame_rate(), output);
  }
  
}

int BakedAnimationData::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional int32 frame_rate = 3;
    if (has_frame_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->frame_rate());
    }
    
  }
  // repeated .Serializer.BakedKeyFrame key_frames = 2;
  total_size += 1 * this->key_frames_size();
  for (int i = 0; i < this->key_frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_frames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BakedAnimationData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BakedAnimationData*>(&from));
}

void BakedAnimationData::MergeFrom(const BakedAnimationData& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_frames_.MergeFrom(from.key_frames_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_frame_rate()) {
      set_frame_rate(from.frame_rate());
    }
  }
}

void BakedAnimationData::CopyFrom(const BakedAnimationData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BakedAnimationData::IsInitialized() const {
  
  return true;
}

void BakedAnimationData::Swap(BakedAnimationData* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    key_frames_.Swap(&other->key_frames_);
    std::swap(frame_rate_, other->frame_rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BakedAnimationData::GetTypeName() const {
  return "Serializer.BakedAnimationData";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)
