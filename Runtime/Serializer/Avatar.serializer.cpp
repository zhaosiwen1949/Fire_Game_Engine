// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Avatar.serializer.h"

#include <algorithm>

#include "once.h"
#include "coded_stream.h"
#include "wire_format_lite_inl.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

void protobuf_ShutdownFile_Avatar_2eproto() {
  delete Bone::default_instance_;
  delete Slot::default_instance_;
  delete RegionAttachment::default_instance_;
  delete Attachment::default_instance_;
  delete SlotAvailableAttachmentsInfo::default_instance_;
  delete Skin::default_instance_;
  delete SpineAvatar::default_instance_;
  delete Avatar3D::default_instance_;
}

void protobuf_AddDesc_Avatar_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Serializer::protobuf_AddDesc_Vector_2eproto();
  ::Serializer::protobuf_AddDesc_Mesh_2eproto();
  ::Serializer::protobuf_AddDesc_GameObject_2eproto();
  ::Serializer::protobuf_AddDesc_Animation_2eproto();
  Bone::default_instance_ = new Bone();
  Slot::default_instance_ = new Slot();
  RegionAttachment::default_instance_ = new RegionAttachment();
  Attachment::default_instance_ = new Attachment();
  SlotAvailableAttachmentsInfo::default_instance_ = new SlotAvailableAttachmentsInfo();
  Skin::default_instance_ = new Skin();
  SpineAvatar::default_instance_ = new SpineAvatar();
  Avatar3D::default_instance_ = new Avatar3D();
  Bone::default_instance_->InitAsDefaultInstance();
  Slot::default_instance_->InitAsDefaultInstance();
  RegionAttachment::default_instance_->InitAsDefaultInstance();
  Attachment::default_instance_->InitAsDefaultInstance();
  SlotAvailableAttachmentsInfo::default_instance_->InitAsDefaultInstance();
  Skin::default_instance_->InitAsDefaultInstance();
  SpineAvatar::default_instance_->InitAsDefaultInstance();
  Avatar3D::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Avatar_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Avatar_2eproto {
  StaticDescriptorInitializer_Avatar_2eproto() {
    protobuf_AddDesc_Avatar_2eproto();
  }
} static_descriptor_initializer_Avatar_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Bone::kNameFieldNumber;
const int Bone::kTranslateFieldNumber;
const int Bone::kRotationFieldNumber;
const int Bone::kScaleFieldNumber;
const int Bone::kShearFieldNumber;
#endif  // !_MSC_VER

Bone::Bone()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Bone::InitAsDefaultInstance() {
}

Bone::Bone(const Bone& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Bone::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Bone::~Bone() {
  SharedDtor();
}

void Bone::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Bone::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Bone& Bone::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

Bone* Bone::default_instance_ = NULL;

Bone* Bone::New() const {
  return new Bone;
}

void Bone::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  translate_.Clear();
  rotation_.Clear();
  scale_.Clear();
  shear_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Bone::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_translate;
        break;
      }
      
      // repeated float translate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_translate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_translate())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_translate())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_translate;
        if (input->ExpectTag(29)) goto parse_rotation;
        break;
      }
      
      // repeated float rotation = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_rotation())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_rotation())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_rotation;
        if (input->ExpectTag(37)) goto parse_scale;
        break;
      }
      
      // repeated float scale = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_scale())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_scale())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_scale;
        if (input->ExpectTag(45)) goto parse_shear;
        break;
      }
      
      // repeated float shear = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_shear:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 45, input, this->mutable_shear())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_shear())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_shear;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Bone::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated float translate = 2;
  for (int i = 0; i < this->translate_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->translate(i), output);
  }
  
  // repeated float rotation = 3;
  for (int i = 0; i < this->rotation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->rotation(i), output);
  }
  
  // repeated float scale = 4;
  for (int i = 0; i < this->scale_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->scale(i), output);
  }
  
  // repeated float shear = 5;
  for (int i = 0; i < this->shear_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      5, this->shear(i), output);
  }
  
}

int Bone::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  // repeated float translate = 2;
  {
    int data_size = 0;
    data_size = 4 * this->translate_size();
    total_size += 1 * this->translate_size() + data_size;
  }
  
  // repeated float rotation = 3;
  {
    int data_size = 0;
    data_size = 4 * this->rotation_size();
    total_size += 1 * this->rotation_size() + data_size;
  }
  
  // repeated float scale = 4;
  {
    int data_size = 0;
    data_size = 4 * this->scale_size();
    total_size += 1 * this->scale_size() + data_size;
  }
  
  // repeated float shear = 5;
  {
    int data_size = 0;
    data_size = 4 * this->shear_size();
    total_size += 1 * this->shear_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Bone::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Bone*>(&from));
}

void Bone::MergeFrom(const Bone& from) {
  GOOGLE_CHECK_NE(&from, this);
  translate_.MergeFrom(from.translate_);
  rotation_.MergeFrom(from.rotation_);
  scale_.MergeFrom(from.scale_);
  shear_.MergeFrom(from.shear_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void Bone::CopyFrom(const Bone& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bone::IsInitialized() const {
  
  return true;
}

void Bone::Swap(Bone* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    translate_.Swap(&other->translate_);
    rotation_.Swap(&other->rotation_);
    scale_.Swap(&other->scale_);
    shear_.Swap(&other->shear_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Bone::GetTypeName() const {
  return "Serializer.Bone";
}


// ===================================================================

#ifndef _MSC_VER
const int Slot::kNameFieldNumber;
const int Slot::kColorFieldNumber;
const int Slot::kDarkFieldNumber;
const int Slot::kAttachmentFieldNumber;
const int Slot::kBlendFuncSrcFieldNumber;
const int Slot::kBlendFuncDstFieldNumber;
#endif  // !_MSC_VER

Slot::Slot()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Slot::InitAsDefaultInstance() {
}

Slot::Slot(const Slot& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Slot::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  attachment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  blend_func_src_ = 0;
  blend_func_dst_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Slot::~Slot() {
  SharedDtor();
}

void Slot::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (attachment_ != &::google::protobuf::internal::kEmptyString) {
    delete attachment_;
  }
  if (this != default_instance_) {
  }
}

void Slot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Slot& Slot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

Slot* Slot::default_instance_ = NULL;

Slot* Slot::New() const {
  return new Slot;
}

void Slot::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_attachment()) {
      if (attachment_ != &::google::protobuf::internal::kEmptyString) {
        attachment_->clear();
      }
    }
    blend_func_src_ = 0;
    blend_func_dst_ = 0;
  }
  color_.Clear();
  dark_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Slot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_color;
        break;
      }
      
      // repeated float color = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_color())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_color())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_color;
        if (input->ExpectTag(29)) goto parse_dark;
        break;
      }
      
      // repeated float dark = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_dark:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_dark())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_dark())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_dark;
        if (input->ExpectTag(34)) goto parse_attachment;
        break;
      }
      
      // optional string attachment = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attachment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_attachment()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_blend_func_src;
        break;
      }
      
      // optional int32 blend_func_src = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blend_func_src:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blend_func_src_)));
          set_has_blend_func_src();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_blend_func_dst;
        break;
      }
      
      // optional int32 blend_func_dst = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blend_func_dst:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blend_func_dst_)));
          set_has_blend_func_dst();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Slot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated float color = 2;
  for (int i = 0; i < this->color_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->color(i), output);
  }
  
  // repeated float dark = 3;
  for (int i = 0; i < this->dark_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->dark(i), output);
  }
  
  // optional string attachment = 4;
  if (has_attachment()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->attachment(), output);
  }
  
  // optional int32 blend_func_src = 5;
  if (has_blend_func_src()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->blend_func_src(), output);
  }
  
  // optional int32 blend_func_dst = 6;
  if (has_blend_func_dst()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->blend_func_dst(), output);
  }
  
}

int Slot::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string attachment = 4;
    if (has_attachment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->attachment());
    }
    
    // optional int32 blend_func_src = 5;
    if (has_blend_func_src()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blend_func_src());
    }
    
    // optional int32 blend_func_dst = 6;
    if (has_blend_func_dst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blend_func_dst());
    }
    
  }
  // repeated float color = 2;
  {
    int data_size = 0;
    data_size = 4 * this->color_size();
    total_size += 1 * this->color_size() + data_size;
  }
  
  // repeated float dark = 3;
  {
    int data_size = 0;
    data_size = 4 * this->dark_size();
    total_size += 1 * this->dark_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Slot::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Slot*>(&from));
}

void Slot::MergeFrom(const Slot& from) {
  GOOGLE_CHECK_NE(&from, this);
  color_.MergeFrom(from.color_);
  dark_.MergeFrom(from.dark_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_attachment()) {
      set_attachment(from.attachment());
    }
    if (from.has_blend_func_src()) {
      set_blend_func_src(from.blend_func_src());
    }
    if (from.has_blend_func_dst()) {
      set_blend_func_dst(from.blend_func_dst());
    }
  }
}

void Slot::CopyFrom(const Slot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Slot::IsInitialized() const {
  
  return true;
}

void Slot::Swap(Slot* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    color_.Swap(&other->color_);
    dark_.Swap(&other->dark_);
    std::swap(attachment_, other->attachment_);
    std::swap(blend_func_src_, other->blend_func_src_);
    std::swap(blend_func_dst_, other->blend_func_dst_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Slot::GetTypeName() const {
  return "Serializer.Slot";
}


// ===================================================================

#ifndef _MSC_VER
const int RegionAttachment::kTranslateFieldNumber;
const int RegionAttachment::kRotationFieldNumber;
const int RegionAttachment::kScaleFieldNumber;
const int RegionAttachment::kSizeFieldNumber;
const int RegionAttachment::kColorFieldNumber;
#endif  // !_MSC_VER

RegionAttachment::RegionAttachment()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegionAttachment::InitAsDefaultInstance() {
}

RegionAttachment::RegionAttachment(const RegionAttachment& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegionAttachment::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegionAttachment::~RegionAttachment() {
  SharedDtor();
}

void RegionAttachment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RegionAttachment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegionAttachment& RegionAttachment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

RegionAttachment* RegionAttachment::default_instance_ = NULL;

RegionAttachment* RegionAttachment::New() const {
  return new RegionAttachment;
}

void RegionAttachment::Clear() {
  translate_.Clear();
  rotation_.Clear();
  scale_.Clear();
  size_.Clear();
  color_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegionAttachment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float translate = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_translate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_translate())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_translate())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(13)) goto parse_translate;
        if (input->ExpectTag(21)) goto parse_rotation;
        break;
      }
      
      // repeated float rotation = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_rotation())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_rotation())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_rotation;
        if (input->ExpectTag(29)) goto parse_scale;
        break;
      }
      
      // repeated float scale = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_scale())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_scale())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_scale;
        if (input->ExpectTag(37)) goto parse_size;
        break;
      }
      
      // repeated float size = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_size())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_size())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_size;
        if (input->ExpectTag(45)) goto parse_color;
        break;
      }
      
      // repeated float color = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 45, input, this->mutable_color())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_color())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_color;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegionAttachment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated float translate = 1;
  for (int i = 0; i < this->translate_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->translate(i), output);
  }
  
  // repeated float rotation = 2;
  for (int i = 0; i < this->rotation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->rotation(i), output);
  }
  
  // repeated float scale = 3;
  for (int i = 0; i < this->scale_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->scale(i), output);
  }
  
  // repeated float size = 4;
  for (int i = 0; i < this->size_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->size(i), output);
  }
  
  // repeated float color = 5;
  for (int i = 0; i < this->color_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      5, this->color(i), output);
  }
  
}

int RegionAttachment::ByteSize() const {
  int total_size = 0;
  
  // repeated float translate = 1;
  {
    int data_size = 0;
    data_size = 4 * this->translate_size();
    total_size += 1 * this->translate_size() + data_size;
  }
  
  // repeated float rotation = 2;
  {
    int data_size = 0;
    data_size = 4 * this->rotation_size();
    total_size += 1 * this->rotation_size() + data_size;
  }
  
  // repeated float scale = 3;
  {
    int data_size = 0;
    data_size = 4 * this->scale_size();
    total_size += 1 * this->scale_size() + data_size;
  }
  
  // repeated float size = 4;
  {
    int data_size = 0;
    data_size = 4 * this->size_size();
    total_size += 1 * this->size_size() + data_size;
  }
  
  // repeated float color = 5;
  {
    int data_size = 0;
    data_size = 4 * this->color_size();
    total_size += 1 * this->color_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegionAttachment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegionAttachment*>(&from));
}

void RegionAttachment::MergeFrom(const RegionAttachment& from) {
  GOOGLE_CHECK_NE(&from, this);
  translate_.MergeFrom(from.translate_);
  rotation_.MergeFrom(from.rotation_);
  scale_.MergeFrom(from.scale_);
  size_.MergeFrom(from.size_);
  color_.MergeFrom(from.color_);
}

void RegionAttachment::CopyFrom(const RegionAttachment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionAttachment::IsInitialized() const {
  
  return true;
}

void RegionAttachment::Swap(RegionAttachment* other) {
  if (other != this) {
    translate_.Swap(&other->translate_);
    rotation_.Swap(&other->rotation_);
    scale_.Swap(&other->scale_);
    size_.Swap(&other->size_);
    color_.Swap(&other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegionAttachment::GetTypeName() const {
  return "Serializer.RegionAttachment";
}


// ===================================================================

#ifndef _MSC_VER
const int Attachment::kTypeFieldNumber;
const int Attachment::kNameFieldNumber;
const int Attachment::kDataFieldNumber;
#endif  // !_MSC_VER

Attachment::Attachment()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Attachment::InitAsDefaultInstance() {
}

Attachment::Attachment(const Attachment& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Attachment::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attachment::~Attachment() {
  SharedDtor();
}

void Attachment::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void Attachment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Attachment& Attachment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

Attachment* Attachment::default_instance_ = NULL;

Attachment* Attachment::New() const {
  return new Attachment;
}

void Attachment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Attachment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }
      
      // optional bytes data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Attachment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }
  
  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // optional bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->data(), output);
  }
  
}

int Attachment::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }
    
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attachment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Attachment*>(&from));
}

void Attachment::MergeFrom(const Attachment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
}

void Attachment::CopyFrom(const Attachment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attachment::IsInitialized() const {
  
  return true;
}

void Attachment::Swap(Attachment* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(name_, other->name_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Attachment::GetTypeName() const {
  return "Serializer.Attachment";
}


// ===================================================================

#ifndef _MSC_VER
const int SlotAvailableAttachmentsInfo::kNameFieldNumber;
const int SlotAvailableAttachmentsInfo::kAvailableAttachmentsFieldNumber;
#endif  // !_MSC_VER

SlotAvailableAttachmentsInfo::SlotAvailableAttachmentsInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlotAvailableAttachmentsInfo::InitAsDefaultInstance() {
}

SlotAvailableAttachmentsInfo::SlotAvailableAttachmentsInfo(const SlotAvailableAttachmentsInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlotAvailableAttachmentsInfo::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlotAvailableAttachmentsInfo::~SlotAvailableAttachmentsInfo() {
  SharedDtor();
}

void SlotAvailableAttachmentsInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void SlotAvailableAttachmentsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlotAvailableAttachmentsInfo& SlotAvailableAttachmentsInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

SlotAvailableAttachmentsInfo* SlotAvailableAttachmentsInfo::default_instance_ = NULL;

SlotAvailableAttachmentsInfo* SlotAvailableAttachmentsInfo::New() const {
  return new SlotAvailableAttachmentsInfo;
}

void SlotAvailableAttachmentsInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  available_attachments_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlotAvailableAttachmentsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_available_attachments;
        break;
      }
      
      // repeated .Serializer.Attachment available_attachments = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_available_attachments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_available_attachments()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_available_attachments;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlotAvailableAttachmentsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated .Serializer.Attachment available_attachments = 2;
  for (int i = 0; i < this->available_attachments_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->available_attachments(i), output);
  }
  
}

int SlotAvailableAttachmentsInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  // repeated .Serializer.Attachment available_attachments = 2;
  total_size += 1 * this->available_attachments_size();
  for (int i = 0; i < this->available_attachments_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->available_attachments(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlotAvailableAttachmentsInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlotAvailableAttachmentsInfo*>(&from));
}

void SlotAvailableAttachmentsInfo::MergeFrom(const SlotAvailableAttachmentsInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  available_attachments_.MergeFrom(from.available_attachments_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void SlotAvailableAttachmentsInfo::CopyFrom(const SlotAvailableAttachmentsInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlotAvailableAttachmentsInfo::IsInitialized() const {
  
  return true;
}

void SlotAvailableAttachmentsInfo::Swap(SlotAvailableAttachmentsInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    available_attachments_.Swap(&other->available_attachments_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlotAvailableAttachmentsInfo::GetTypeName() const {
  return "Serializer.SlotAvailableAttachmentsInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int Skin::kNameFieldNumber;
const int Skin::kSlotAvailableAttachmentsInfoFieldNumber;
#endif  // !_MSC_VER

Skin::Skin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Skin::InitAsDefaultInstance() {
}

Skin::Skin(const Skin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Skin::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Skin::~Skin() {
  SharedDtor();
}

void Skin::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Skin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Skin& Skin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

Skin* Skin::default_instance_ = NULL;

Skin* Skin::New() const {
  return new Skin;
}

void Skin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  slot_available_attachments_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Skin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slot_available_attachments_info;
        break;
      }
      
      // repeated .Serializer.SlotAvailableAttachmentsInfo slot_available_attachments_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slot_available_attachments_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_slot_available_attachments_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slot_available_attachments_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Skin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated .Serializer.SlotAvailableAttachmentsInfo slot_available_attachments_info = 2;
  for (int i = 0; i < this->slot_available_attachments_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->slot_available_attachments_info(i), output);
  }
  
}

int Skin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  // repeated .Serializer.SlotAvailableAttachmentsInfo slot_available_attachments_info = 2;
  total_size += 1 * this->slot_available_attachments_info_size();
  for (int i = 0; i < this->slot_available_attachments_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->slot_available_attachments_info(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Skin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Skin*>(&from));
}

void Skin::MergeFrom(const Skin& from) {
  GOOGLE_CHECK_NE(&from, this);
  slot_available_attachments_info_.MergeFrom(from.slot_available_attachments_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void Skin::CopyFrom(const Skin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Skin::IsInitialized() const {
  
  return true;
}

void Skin::Swap(Skin* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    slot_available_attachments_info_.Swap(&other->slot_available_attachments_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Skin::GetTypeName() const {
  return "Serializer.Skin";
}


// ===================================================================

#ifndef _MSC_VER
const int SpineAvatar::kNameFieldNumber;
const int SpineAvatar::kSetupPoseFieldNumber;
const int SpineAvatar::kBonesFieldNumber;
const int SpineAvatar::kSlotsFieldNumber;
const int SpineAvatar::kSkinsFieldNumber;
const int SpineAvatar::kAnimationsFieldNumber;
#endif  // !_MSC_VER

SpineAvatar::SpineAvatar()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SpineAvatar::InitAsDefaultInstance() {
  setup_pose_ = const_cast< ::Serializer::GameObject*>(&::Serializer::GameObject::default_instance());
}

SpineAvatar::SpineAvatar(const SpineAvatar& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SpineAvatar::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  setup_pose_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SpineAvatar::~SpineAvatar() {
  SharedDtor();
}

void SpineAvatar::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete setup_pose_;
  }
}

void SpineAvatar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SpineAvatar& SpineAvatar::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

SpineAvatar* SpineAvatar::default_instance_ = NULL;

SpineAvatar* SpineAvatar::New() const {
  return new SpineAvatar;
}

void SpineAvatar::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_setup_pose()) {
      if (setup_pose_ != NULL) setup_pose_->::Serializer::GameObject::Clear();
    }
  }
  bones_.Clear();
  slots_.Clear();
  skins_.Clear();
  animations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SpineAvatar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_setup_pose;
        break;
      }
      
      // optional .Serializer.GameObject setup_pose = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_setup_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_setup_pose()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bones;
        break;
      }
      
      // repeated .Serializer.Bone bones = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bones:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bones()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bones;
        if (input->ExpectTag(34)) goto parse_slots;
        break;
      }
      
      // repeated .Serializer.Slot slots = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slots:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_slots()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_slots;
        if (input->ExpectTag(42)) goto parse_skins;
        break;
      }
      
      // repeated .Serializer.Skin skins = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_skins:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_skins()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_skins;
        if (input->ExpectTag(50)) goto parse_animations;
        break;
      }
      
      // repeated .Serializer.Animation animations = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_animations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_animations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_animations;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SpineAvatar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional .Serializer.GameObject setup_pose = 2;
  if (has_setup_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->setup_pose(), output);
  }
  
  // repeated .Serializer.Bone bones = 3;
  for (int i = 0; i < this->bones_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->bones(i), output);
  }
  
  // repeated .Serializer.Slot slots = 4;
  for (int i = 0; i < this->slots_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->slots(i), output);
  }
  
  // repeated .Serializer.Skin skins = 5;
  for (int i = 0; i < this->skins_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->skins(i), output);
  }
  
  // repeated .Serializer.Animation animations = 6;
  for (int i = 0; i < this->animations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->animations(i), output);
  }
  
}

int SpineAvatar::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional .Serializer.GameObject setup_pose = 2;
    if (has_setup_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->setup_pose());
    }
    
  }
  // repeated .Serializer.Bone bones = 3;
  total_size += 1 * this->bones_size();
  for (int i = 0; i < this->bones_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bones(i));
  }
  
  // repeated .Serializer.Slot slots = 4;
  total_size += 1 * this->slots_size();
  for (int i = 0; i < this->slots_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->slots(i));
  }
  
  // repeated .Serializer.Skin skins = 5;
  total_size += 1 * this->skins_size();
  for (int i = 0; i < this->skins_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->skins(i));
  }
  
  // repeated .Serializer.Animation animations = 6;
  total_size += 1 * this->animations_size();
  for (int i = 0; i < this->animations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->animations(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpineAvatar::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SpineAvatar*>(&from));
}

void SpineAvatar::MergeFrom(const SpineAvatar& from) {
  GOOGLE_CHECK_NE(&from, this);
  bones_.MergeFrom(from.bones_);
  slots_.MergeFrom(from.slots_);
  skins_.MergeFrom(from.skins_);
  animations_.MergeFrom(from.animations_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_setup_pose()) {
      mutable_setup_pose()->::Serializer::GameObject::MergeFrom(from.setup_pose());
    }
  }
}

void SpineAvatar::CopyFrom(const SpineAvatar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpineAvatar::IsInitialized() const {
  
  if (has_setup_pose()) {
    if (!this->setup_pose().IsInitialized()) return false;
  }
  return true;
}

void SpineAvatar::Swap(SpineAvatar* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(setup_pose_, other->setup_pose_);
    bones_.Swap(&other->bones_);
    slots_.Swap(&other->slots_);
    skins_.Swap(&other->skins_);
    animations_.Swap(&other->animations_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SpineAvatar::GetTypeName() const {
  return "Serializer.SpineAvatar";
}


// ===================================================================

#ifndef _MSC_VER
const int Avatar3D::kNameFieldNumber;
const int Avatar3D::kTPoseFieldNumber;
const int Avatar3D::kTPoseInvertMatrixFieldNumber;
#endif  // !_MSC_VER

Avatar3D::Avatar3D()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Avatar3D::InitAsDefaultInstance() {
}

Avatar3D::Avatar3D(const Avatar3D& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Avatar3D::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Avatar3D::~Avatar3D() {
  SharedDtor();
}

void Avatar3D::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Avatar3D::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Avatar3D& Avatar3D::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Avatar_2eproto();  return *default_instance_;
}

Avatar3D* Avatar3D::default_instance_ = NULL;

Avatar3D* Avatar3D::New() const {
  return new Avatar3D;
}

void Avatar3D::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  t_pose_.Clear();
  t_pose_invert_matrix_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Avatar3D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_t_pose;
        break;
      }
      
      // repeated .Serializer.Mesh t_pose = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_t_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_t_pose()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_t_pose;
        if (input->ExpectTag(26)) goto parse_t_pose_invert_matrix;
        break;
      }
      
      // repeated .Serializer.Matrix4fB t_pose_invert_matrix = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_t_pose_invert_matrix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_t_pose_invert_matrix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_t_pose_invert_matrix;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Avatar3D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated .Serializer.Mesh t_pose = 2;
  for (int i = 0; i < this->t_pose_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->t_pose(i), output);
  }
  
  // repeated .Serializer.Matrix4fB t_pose_invert_matrix = 3;
  for (int i = 0; i < this->t_pose_invert_matrix_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->t_pose_invert_matrix(i), output);
  }
  
}

int Avatar3D::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  // repeated .Serializer.Mesh t_pose = 2;
  total_size += 1 * this->t_pose_size();
  for (int i = 0; i < this->t_pose_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->t_pose(i));
  }
  
  // repeated .Serializer.Matrix4fB t_pose_invert_matrix = 3;
  total_size += 1 * this->t_pose_invert_matrix_size();
  for (int i = 0; i < this->t_pose_invert_matrix_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->t_pose_invert_matrix(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Avatar3D::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Avatar3D*>(&from));
}

void Avatar3D::MergeFrom(const Avatar3D& from) {
  GOOGLE_CHECK_NE(&from, this);
  t_pose_.MergeFrom(from.t_pose_);
  t_pose_invert_matrix_.MergeFrom(from.t_pose_invert_matrix_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void Avatar3D::CopyFrom(const Avatar3D& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Avatar3D::IsInitialized() const {
  
  return true;
}

void Avatar3D::Swap(Avatar3D* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    t_pose_.Swap(&other->t_pose_);
    t_pose_invert_matrix_.Swap(&other->t_pose_invert_matrix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Avatar3D::GetTypeName() const {
  return "Serializer.Avatar3D";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)
