// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Animation.proto

#ifndef PROTOBUF_Animation_2eproto__INCLUDED
#define PROTOBUF_Animation_2eproto__INCLUDED

#include <string>

#include "common.h"

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "generated_message_util.h"
#include "repeated_field.h"
#include "extension_set.h"
#include "Vector.serializer.h"
#include "Color.serializer.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Animation_2eproto();
void protobuf_AssignDesc_Animation_2eproto();
void protobuf_ShutdownFile_Animation_2eproto();

class Curve;
class CubicBezier;
class RotateAnimationKeyFrame;
class RotateAnimationClip;
class TranslateAnimationKeyFrame;
class TranslateAnimationClip;
class ScaleAnimationKeyFrame;
class ScaleAnimationClip;
class ShearAnimationKeyFrame;
class ShearAnimationClip;
class SpriteSequenceAnimationKeyFrame;
class SpriteSequenceAnimationClip;
class ColorAnimationKeyFrame;
class ColorAnimationClip;
class TwoColorAnimationKeyFrame;
class TwoColorAnimationClip;
class DrawOrderAnimationKeyFrame;
class DrawOrderAnimationClip;
class AnimationClip;
class Animation;
class BakedMeshData;
class BakedKeyFrame;
class BakedAnimationData;

// ===================================================================

class Curve : public ::google::protobuf::MessageLite {
 public:
  Curve();
  virtual ~Curve();
  
  Curve(const Curve& from);
  
  inline Curve& operator=(const Curve& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Curve& default_instance();
  
  void Swap(Curve* other);
  
  // implements Message ----------------------------------------------
  
  Curve* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Curve& from);
  void MergeFrom(const Curve& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.Vector4f KeyPoints = 1;
  inline int keypoints_size() const;
  inline void clear_keypoints();
  static const int kKeyPointsFieldNumber = 1;
  inline const ::Serializer::Vector4f& keypoints(int index) const;
  inline ::Serializer::Vector4f* mutable_keypoints(int index);
  inline ::Serializer::Vector4f* add_keypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Vector4f >&
      keypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Vector4f >*
      mutable_keypoints();
  
  // @@protoc_insertion_point(class_scope:Serializer.Curve)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::Vector4f > keypoints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static Curve* default_instance_;
};
// -------------------------------------------------------------------

class CubicBezier : public ::google::protobuf::MessageLite {
 public:
  CubicBezier();
  virtual ~CubicBezier();
  
  CubicBezier(const CubicBezier& from);
  
  inline CubicBezier& operator=(const CubicBezier& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CubicBezier& default_instance();
  
  void Swap(CubicBezier* other);
  
  // implements Message ----------------------------------------------
  
  CubicBezier* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CubicBezier& from);
  void MergeFrom(const CubicBezier& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Serializer.Vector2f p1 = 1;
  inline bool has_p1() const;
  inline void clear_p1();
  static const int kP1FieldNumber = 1;
  inline const ::Serializer::Vector2f& p1() const;
  inline ::Serializer::Vector2f* mutable_p1();
  inline ::Serializer::Vector2f* release_p1();
  
  // optional .Serializer.Vector2f p2 = 2;
  inline bool has_p2() const;
  inline void clear_p2();
  static const int kP2FieldNumber = 2;
  inline const ::Serializer::Vector2f& p2() const;
  inline ::Serializer::Vector2f* mutable_p2();
  inline ::Serializer::Vector2f* release_p2();
  
  // @@protoc_insertion_point(class_scope:Serializer.CubicBezier)
 private:
  inline void set_has_p1();
  inline void clear_has_p1();
  inline void set_has_p2();
  inline void clear_has_p2();
  
  ::Serializer::Vector2f* p1_;
  ::Serializer::Vector2f* p2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static CubicBezier* default_instance_;
};
// -------------------------------------------------------------------

class RotateAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  RotateAnimationKeyFrame();
  virtual ~RotateAnimationKeyFrame();
  
  RotateAnimationKeyFrame(const RotateAnimationKeyFrame& from);
  
  inline RotateAnimationKeyFrame& operator=(const RotateAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RotateAnimationKeyFrame& default_instance();
  
  void Swap(RotateAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  RotateAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RotateAnimationKeyFrame& from);
  void MergeFrom(const RotateAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // optional int32 interpolation_type = 2;
  inline bool has_interpolation_type() const;
  inline void clear_interpolation_type();
  static const int kInterpolationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 interpolation_type() const;
  inline void set_interpolation_type(::google::protobuf::int32 value);
  
  // repeated float external_args = 3;
  inline int external_args_size() const;
  inline void clear_external_args();
  static const int kExternalArgsFieldNumber = 3;
  inline float external_args(int index) const;
  inline void set_external_args(int index, float value);
  inline void add_external_args(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      external_args() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_external_args();
  
  // repeated float rotation = 4;
  inline int rotation_size() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 4;
  inline float rotation(int index) const;
  inline void set_rotation(int index, float value);
  inline void add_rotation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_rotation();
  
  // @@protoc_insertion_point(class_scope:Serializer.RotateAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_interpolation_type();
  inline void clear_has_interpolation_type();
  
  float time_;
  ::google::protobuf::int32 interpolation_type_;
  ::google::protobuf::RepeatedField< float > external_args_;
  ::google::protobuf::RepeatedField< float > rotation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static RotateAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class RotateAnimationClip : public ::google::protobuf::MessageLite {
 public:
  RotateAnimationClip();
  virtual ~RotateAnimationClip();
  
  RotateAnimationClip(const RotateAnimationClip& from);
  
  inline RotateAnimationClip& operator=(const RotateAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RotateAnimationClip& default_instance();
  
  void Swap(RotateAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  RotateAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RotateAnimationClip& from);
  void MergeFrom(const RotateAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.RotateAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::RotateAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::RotateAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::RotateAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::RotateAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::RotateAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.RotateAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::RotateAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static RotateAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class TranslateAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  TranslateAnimationKeyFrame();
  virtual ~TranslateAnimationKeyFrame();
  
  TranslateAnimationKeyFrame(const TranslateAnimationKeyFrame& from);
  
  inline TranslateAnimationKeyFrame& operator=(const TranslateAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TranslateAnimationKeyFrame& default_instance();
  
  void Swap(TranslateAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  TranslateAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranslateAnimationKeyFrame& from);
  void MergeFrom(const TranslateAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // optional int32 interpolation_type = 2;
  inline bool has_interpolation_type() const;
  inline void clear_interpolation_type();
  static const int kInterpolationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 interpolation_type() const;
  inline void set_interpolation_type(::google::protobuf::int32 value);
  
  // repeated float external_args = 3;
  inline int external_args_size() const;
  inline void clear_external_args();
  static const int kExternalArgsFieldNumber = 3;
  inline float external_args(int index) const;
  inline void set_external_args(int index, float value);
  inline void add_external_args(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      external_args() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_external_args();
  
  // repeated float translation = 4;
  inline int translation_size() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 4;
  inline float translation(int index) const;
  inline void set_translation(int index, float value);
  inline void add_translation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      translation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_translation();
  
  // @@protoc_insertion_point(class_scope:Serializer.TranslateAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_interpolation_type();
  inline void clear_has_interpolation_type();
  
  float time_;
  ::google::protobuf::int32 interpolation_type_;
  ::google::protobuf::RepeatedField< float > external_args_;
  ::google::protobuf::RepeatedField< float > translation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static TranslateAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class TranslateAnimationClip : public ::google::protobuf::MessageLite {
 public:
  TranslateAnimationClip();
  virtual ~TranslateAnimationClip();
  
  TranslateAnimationClip(const TranslateAnimationClip& from);
  
  inline TranslateAnimationClip& operator=(const TranslateAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TranslateAnimationClip& default_instance();
  
  void Swap(TranslateAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  TranslateAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranslateAnimationClip& from);
  void MergeFrom(const TranslateAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.TranslateAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::TranslateAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::TranslateAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::TranslateAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::TranslateAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::TranslateAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.TranslateAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::TranslateAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static TranslateAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class ScaleAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  ScaleAnimationKeyFrame();
  virtual ~ScaleAnimationKeyFrame();
  
  ScaleAnimationKeyFrame(const ScaleAnimationKeyFrame& from);
  
  inline ScaleAnimationKeyFrame& operator=(const ScaleAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ScaleAnimationKeyFrame& default_instance();
  
  void Swap(ScaleAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  ScaleAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ScaleAnimationKeyFrame& from);
  void MergeFrom(const ScaleAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // optional int32 interpolation_type = 2;
  inline bool has_interpolation_type() const;
  inline void clear_interpolation_type();
  static const int kInterpolationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 interpolation_type() const;
  inline void set_interpolation_type(::google::protobuf::int32 value);
  
  // repeated float external_args = 3;
  inline int external_args_size() const;
  inline void clear_external_args();
  static const int kExternalArgsFieldNumber = 3;
  inline float external_args(int index) const;
  inline void set_external_args(int index, float value);
  inline void add_external_args(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      external_args() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_external_args();
  
  // repeated float scale = 4;
  inline int scale_size() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  inline float scale(int index) const;
  inline void set_scale(int index, float value);
  inline void add_scale(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      scale() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_scale();
  
  // @@protoc_insertion_point(class_scope:Serializer.ScaleAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_interpolation_type();
  inline void clear_has_interpolation_type();
  
  float time_;
  ::google::protobuf::int32 interpolation_type_;
  ::google::protobuf::RepeatedField< float > external_args_;
  ::google::protobuf::RepeatedField< float > scale_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static ScaleAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class ScaleAnimationClip : public ::google::protobuf::MessageLite {
 public:
  ScaleAnimationClip();
  virtual ~ScaleAnimationClip();
  
  ScaleAnimationClip(const ScaleAnimationClip& from);
  
  inline ScaleAnimationClip& operator=(const ScaleAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ScaleAnimationClip& default_instance();
  
  void Swap(ScaleAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  ScaleAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ScaleAnimationClip& from);
  void MergeFrom(const ScaleAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.ScaleAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::ScaleAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::ScaleAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::ScaleAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::ScaleAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::ScaleAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.ScaleAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::ScaleAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static ScaleAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class ShearAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  ShearAnimationKeyFrame();
  virtual ~ShearAnimationKeyFrame();
  
  ShearAnimationKeyFrame(const ShearAnimationKeyFrame& from);
  
  inline ShearAnimationKeyFrame& operator=(const ShearAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ShearAnimationKeyFrame& default_instance();
  
  void Swap(ShearAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  ShearAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShearAnimationKeyFrame& from);
  void MergeFrom(const ShearAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // optional int32 interpolation_type = 2;
  inline bool has_interpolation_type() const;
  inline void clear_interpolation_type();
  static const int kInterpolationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 interpolation_type() const;
  inline void set_interpolation_type(::google::protobuf::int32 value);
  
  // repeated float external_args = 3;
  inline int external_args_size() const;
  inline void clear_external_args();
  static const int kExternalArgsFieldNumber = 3;
  inline float external_args(int index) const;
  inline void set_external_args(int index, float value);
  inline void add_external_args(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      external_args() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_external_args();
  
  // repeated float shear = 4;
  inline int shear_size() const;
  inline void clear_shear();
  static const int kShearFieldNumber = 4;
  inline float shear(int index) const;
  inline void set_shear(int index, float value);
  inline void add_shear(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      shear() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_shear();
  
  // @@protoc_insertion_point(class_scope:Serializer.ShearAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_interpolation_type();
  inline void clear_has_interpolation_type();
  
  float time_;
  ::google::protobuf::int32 interpolation_type_;
  ::google::protobuf::RepeatedField< float > external_args_;
  ::google::protobuf::RepeatedField< float > shear_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static ShearAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class ShearAnimationClip : public ::google::protobuf::MessageLite {
 public:
  ShearAnimationClip();
  virtual ~ShearAnimationClip();
  
  ShearAnimationClip(const ShearAnimationClip& from);
  
  inline ShearAnimationClip& operator=(const ShearAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ShearAnimationClip& default_instance();
  
  void Swap(ShearAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  ShearAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShearAnimationClip& from);
  void MergeFrom(const ShearAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.ShearAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::ShearAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::ShearAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::ShearAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::ShearAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::ShearAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.ShearAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::ShearAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static ShearAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class SpriteSequenceAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  SpriteSequenceAnimationKeyFrame();
  virtual ~SpriteSequenceAnimationKeyFrame();
  
  SpriteSequenceAnimationKeyFrame(const SpriteSequenceAnimationKeyFrame& from);
  
  inline SpriteSequenceAnimationKeyFrame& operator=(const SpriteSequenceAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SpriteSequenceAnimationKeyFrame& default_instance();
  
  void Swap(SpriteSequenceAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  SpriteSequenceAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpriteSequenceAnimationKeyFrame& from);
  void MergeFrom(const SpriteSequenceAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // optional string image_name = 2;
  inline bool has_image_name() const;
  inline void clear_image_name();
  static const int kImageNameFieldNumber = 2;
  inline const ::std::string& image_name() const;
  inline void set_image_name(const ::std::string& value);
  inline void set_image_name(const char* value);
  inline void set_image_name(const char* value, size_t size);
  inline ::std::string* mutable_image_name();
  inline ::std::string* release_image_name();
  
  // @@protoc_insertion_point(class_scope:Serializer.SpriteSequenceAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_image_name();
  inline void clear_has_image_name();
  
  ::std::string* image_name_;
  float time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static SpriteSequenceAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class SpriteSequenceAnimationClip : public ::google::protobuf::MessageLite {
 public:
  SpriteSequenceAnimationClip();
  virtual ~SpriteSequenceAnimationClip();
  
  SpriteSequenceAnimationClip(const SpriteSequenceAnimationClip& from);
  
  inline SpriteSequenceAnimationClip& operator=(const SpriteSequenceAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SpriteSequenceAnimationClip& default_instance();
  
  void Swap(SpriteSequenceAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  SpriteSequenceAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpriteSequenceAnimationClip& from);
  void MergeFrom(const SpriteSequenceAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.SpriteSequenceAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::SpriteSequenceAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::SpriteSequenceAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::SpriteSequenceAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::SpriteSequenceAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::SpriteSequenceAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.SpriteSequenceAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::SpriteSequenceAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static SpriteSequenceAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class ColorAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  ColorAnimationKeyFrame();
  virtual ~ColorAnimationKeyFrame();
  
  ColorAnimationKeyFrame(const ColorAnimationKeyFrame& from);
  
  inline ColorAnimationKeyFrame& operator=(const ColorAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ColorAnimationKeyFrame& default_instance();
  
  void Swap(ColorAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  ColorAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ColorAnimationKeyFrame& from);
  void MergeFrom(const ColorAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // optional int32 interpolation_type = 2;
  inline bool has_interpolation_type() const;
  inline void clear_interpolation_type();
  static const int kInterpolationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 interpolation_type() const;
  inline void set_interpolation_type(::google::protobuf::int32 value);
  
  // repeated float external_args = 3;
  inline int external_args_size() const;
  inline void clear_external_args();
  static const int kExternalArgsFieldNumber = 3;
  inline float external_args(int index) const;
  inline void set_external_args(int index, float value);
  inline void add_external_args(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      external_args() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_external_args();
  
  // repeated float color = 4;
  inline int color_size() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline float color(int index) const;
  inline void set_color(int index, float value);
  inline void add_color(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      color() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_color();
  
  // @@protoc_insertion_point(class_scope:Serializer.ColorAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_interpolation_type();
  inline void clear_has_interpolation_type();
  
  float time_;
  ::google::protobuf::int32 interpolation_type_;
  ::google::protobuf::RepeatedField< float > external_args_;
  ::google::protobuf::RepeatedField< float > color_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static ColorAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class ColorAnimationClip : public ::google::protobuf::MessageLite {
 public:
  ColorAnimationClip();
  virtual ~ColorAnimationClip();
  
  ColorAnimationClip(const ColorAnimationClip& from);
  
  inline ColorAnimationClip& operator=(const ColorAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ColorAnimationClip& default_instance();
  
  void Swap(ColorAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  ColorAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ColorAnimationClip& from);
  void MergeFrom(const ColorAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.ColorAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::ColorAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::ColorAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::ColorAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::ColorAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::ColorAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.ColorAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::ColorAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static ColorAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class TwoColorAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  TwoColorAnimationKeyFrame();
  virtual ~TwoColorAnimationKeyFrame();
  
  TwoColorAnimationKeyFrame(const TwoColorAnimationKeyFrame& from);
  
  inline TwoColorAnimationKeyFrame& operator=(const TwoColorAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TwoColorAnimationKeyFrame& default_instance();
  
  void Swap(TwoColorAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  TwoColorAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TwoColorAnimationKeyFrame& from);
  void MergeFrom(const TwoColorAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // optional int32 interpolation_type = 2;
  inline bool has_interpolation_type() const;
  inline void clear_interpolation_type();
  static const int kInterpolationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 interpolation_type() const;
  inline void set_interpolation_type(::google::protobuf::int32 value);
  
  // repeated float external_args = 3;
  inline int external_args_size() const;
  inline void clear_external_args();
  static const int kExternalArgsFieldNumber = 3;
  inline float external_args(int index) const;
  inline void set_external_args(int index, float value);
  inline void add_external_args(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      external_args() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_external_args();
  
  // repeated float light = 4;
  inline int light_size() const;
  inline void clear_light();
  static const int kLightFieldNumber = 4;
  inline float light(int index) const;
  inline void set_light(int index, float value);
  inline void add_light(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      light() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_light();
  
  // repeated float dark = 5;
  inline int dark_size() const;
  inline void clear_dark();
  static const int kDarkFieldNumber = 5;
  inline float dark(int index) const;
  inline void set_dark(int index, float value);
  inline void add_dark(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      dark() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_dark();
  
  // @@protoc_insertion_point(class_scope:Serializer.TwoColorAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_interpolation_type();
  inline void clear_has_interpolation_type();
  
  float time_;
  ::google::protobuf::int32 interpolation_type_;
  ::google::protobuf::RepeatedField< float > external_args_;
  ::google::protobuf::RepeatedField< float > light_;
  ::google::protobuf::RepeatedField< float > dark_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static TwoColorAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class TwoColorAnimationClip : public ::google::protobuf::MessageLite {
 public:
  TwoColorAnimationClip();
  virtual ~TwoColorAnimationClip();
  
  TwoColorAnimationClip(const TwoColorAnimationClip& from);
  
  inline TwoColorAnimationClip& operator=(const TwoColorAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TwoColorAnimationClip& default_instance();
  
  void Swap(TwoColorAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  TwoColorAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TwoColorAnimationClip& from);
  void MergeFrom(const TwoColorAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.TwoColorAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::TwoColorAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::TwoColorAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::TwoColorAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::TwoColorAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::TwoColorAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.TwoColorAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::TwoColorAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static TwoColorAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class DrawOrderAnimationKeyFrame : public ::google::protobuf::MessageLite {
 public:
  DrawOrderAnimationKeyFrame();
  virtual ~DrawOrderAnimationKeyFrame();
  
  DrawOrderAnimationKeyFrame(const DrawOrderAnimationKeyFrame& from);
  
  inline DrawOrderAnimationKeyFrame& operator=(const DrawOrderAnimationKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DrawOrderAnimationKeyFrame& default_instance();
  
  void Swap(DrawOrderAnimationKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  DrawOrderAnimationKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DrawOrderAnimationKeyFrame& from);
  void MergeFrom(const DrawOrderAnimationKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);
  
  // repeated string draw_order = 2;
  inline int draw_order_size() const;
  inline void clear_draw_order();
  static const int kDrawOrderFieldNumber = 2;
  inline const ::std::string& draw_order(int index) const;
  inline ::std::string* mutable_draw_order(int index);
  inline void set_draw_order(int index, const ::std::string& value);
  inline void set_draw_order(int index, const char* value);
  inline void set_draw_order(int index, const char* value, size_t size);
  inline ::std::string* add_draw_order();
  inline void add_draw_order(const ::std::string& value);
  inline void add_draw_order(const char* value);
  inline void add_draw_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& draw_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_draw_order();
  
  // @@protoc_insertion_point(class_scope:Serializer.DrawOrderAnimationKeyFrame)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::RepeatedPtrField< ::std::string> draw_order_;
  float time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static DrawOrderAnimationKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class DrawOrderAnimationClip : public ::google::protobuf::MessageLite {
 public:
  DrawOrderAnimationClip();
  virtual ~DrawOrderAnimationClip();
  
  DrawOrderAnimationClip(const DrawOrderAnimationClip& from);
  
  inline DrawOrderAnimationClip& operator=(const DrawOrderAnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DrawOrderAnimationClip& default_instance();
  
  void Swap(DrawOrderAnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  DrawOrderAnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DrawOrderAnimationClip& from);
  void MergeFrom(const DrawOrderAnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.DrawOrderAnimationKeyFrame key_frames = 1;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 1;
  inline const ::Serializer::DrawOrderAnimationKeyFrame& key_frames(int index) const;
  inline ::Serializer::DrawOrderAnimationKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::DrawOrderAnimationKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::DrawOrderAnimationKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::DrawOrderAnimationKeyFrame >*
      mutable_key_frames();
  
  // @@protoc_insertion_point(class_scope:Serializer.DrawOrderAnimationClip)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::DrawOrderAnimationKeyFrame > key_frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static DrawOrderAnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class AnimationClip : public ::google::protobuf::MessageLite {
 public:
  AnimationClip();
  virtual ~AnimationClip();
  
  AnimationClip(const AnimationClip& from);
  
  inline AnimationClip& operator=(const AnimationClip& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AnimationClip& default_instance();
  
  void Swap(AnimationClip* other);
  
  // implements Message ----------------------------------------------
  
  AnimationClip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnimationClip& from);
  void MergeFrom(const AnimationClip& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  
  // optional int32 target_component = 3;
  inline bool has_target_component() const;
  inline void clear_target_component();
  static const int kTargetComponentFieldNumber = 3;
  inline ::google::protobuf::int32 target_component() const;
  inline void set_target_component(::google::protobuf::int32 value);
  
  // optional bytes animation_clip_data = 4;
  inline bool has_animation_clip_data() const;
  inline void clear_animation_clip_data();
  static const int kAnimationClipDataFieldNumber = 4;
  inline const ::std::string& animation_clip_data() const;
  inline void set_animation_clip_data(const ::std::string& value);
  inline void set_animation_clip_data(const char* value);
  inline void set_animation_clip_data(const void* value, size_t size);
  inline ::std::string* mutable_animation_clip_data();
  inline ::std::string* release_animation_clip_data();
  
  // @@protoc_insertion_point(class_scope:Serializer.AnimationClip)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_target_component();
  inline void clear_has_target_component();
  inline void set_has_animation_clip_data();
  inline void clear_has_animation_clip_data();
  
  ::std::string* target_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 target_component_;
  ::std::string* animation_clip_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static AnimationClip* default_instance_;
};
// -------------------------------------------------------------------

class Animation : public ::google::protobuf::MessageLite {
 public:
  Animation();
  virtual ~Animation();
  
  Animation(const Animation& from);
  
  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Animation& default_instance();
  
  void Swap(Animation* other);
  
  // implements Message ----------------------------------------------
  
  Animation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Animation& from);
  void MergeFrom(const Animation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional float duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline float duration() const;
  inline void set_duration(float value);
  
  // repeated .Serializer.AnimationClip animation_clips = 3;
  inline int animation_clips_size() const;
  inline void clear_animation_clips();
  static const int kAnimationClipsFieldNumber = 3;
  inline const ::Serializer::AnimationClip& animation_clips(int index) const;
  inline ::Serializer::AnimationClip* mutable_animation_clips(int index);
  inline ::Serializer::AnimationClip* add_animation_clips();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::AnimationClip >&
      animation_clips() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::AnimationClip >*
      mutable_animation_clips();
  
  // @@protoc_insertion_point(class_scope:Serializer.Animation)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::AnimationClip > animation_clips_;
  float duration_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static Animation* default_instance_;
};
// -------------------------------------------------------------------

class BakedMeshData : public ::google::protobuf::MessageLite {
 public:
  BakedMeshData();
  virtual ~BakedMeshData();
  
  BakedMeshData(const BakedMeshData& from);
  
  inline BakedMeshData& operator=(const BakedMeshData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BakedMeshData& default_instance();
  
  void Swap(BakedMeshData* other);
  
  // implements Message ----------------------------------------------
  
  BakedMeshData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BakedMeshData& from);
  void MergeFrom(const BakedMeshData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes vertex_buffer = 1;
  inline bool has_vertex_buffer() const;
  inline void clear_vertex_buffer();
  static const int kVertexBufferFieldNumber = 1;
  inline const ::std::string& vertex_buffer() const;
  inline void set_vertex_buffer(const ::std::string& value);
  inline void set_vertex_buffer(const char* value);
  inline void set_vertex_buffer(const void* value, size_t size);
  inline ::std::string* mutable_vertex_buffer();
  inline ::std::string* release_vertex_buffer();
  
  // optional bytes offset_matrix = 2;
  inline bool has_offset_matrix() const;
  inline void clear_offset_matrix();
  static const int kOffsetMatrixFieldNumber = 2;
  inline const ::std::string& offset_matrix() const;
  inline void set_offset_matrix(const ::std::string& value);
  inline void set_offset_matrix(const char* value);
  inline void set_offset_matrix(const void* value, size_t size);
  inline ::std::string* mutable_offset_matrix();
  inline ::std::string* release_offset_matrix();
  
  // @@protoc_insertion_point(class_scope:Serializer.BakedMeshData)
 private:
  inline void set_has_vertex_buffer();
  inline void clear_has_vertex_buffer();
  inline void set_has_offset_matrix();
  inline void clear_has_offset_matrix();
  
  ::std::string* vertex_buffer_;
  ::std::string* offset_matrix_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static BakedMeshData* default_instance_;
};
// -------------------------------------------------------------------

class BakedKeyFrame : public ::google::protobuf::MessageLite {
 public:
  BakedKeyFrame();
  virtual ~BakedKeyFrame();
  
  BakedKeyFrame(const BakedKeyFrame& from);
  
  inline BakedKeyFrame& operator=(const BakedKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BakedKeyFrame& default_instance();
  
  void Swap(BakedKeyFrame* other);
  
  // implements Message ----------------------------------------------
  
  BakedKeyFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BakedKeyFrame& from);
  void MergeFrom(const BakedKeyFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Serializer.BakedMeshData mesh_datas = 1;
  inline int mesh_datas_size() const;
  inline void clear_mesh_datas();
  static const int kMeshDatasFieldNumber = 1;
  inline const ::Serializer::BakedMeshData& mesh_datas(int index) const;
  inline ::Serializer::BakedMeshData* mutable_mesh_datas(int index);
  inline ::Serializer::BakedMeshData* add_mesh_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::BakedMeshData >&
      mesh_datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::BakedMeshData >*
      mutable_mesh_datas();
  
  // @@protoc_insertion_point(class_scope:Serializer.BakedKeyFrame)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Serializer::BakedMeshData > mesh_datas_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static BakedKeyFrame* default_instance_;
};
// -------------------------------------------------------------------

class BakedAnimationData : public ::google::protobuf::MessageLite {
 public:
  BakedAnimationData();
  virtual ~BakedAnimationData();
  
  BakedAnimationData(const BakedAnimationData& from);
  
  inline BakedAnimationData& operator=(const BakedAnimationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BakedAnimationData& default_instance();
  
  void Swap(BakedAnimationData* other);
  
  // implements Message ----------------------------------------------
  
  BakedAnimationData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BakedAnimationData& from);
  void MergeFrom(const BakedAnimationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .Serializer.BakedKeyFrame key_frames = 2;
  inline int key_frames_size() const;
  inline void clear_key_frames();
  static const int kKeyFramesFieldNumber = 2;
  inline const ::Serializer::BakedKeyFrame& key_frames(int index) const;
  inline ::Serializer::BakedKeyFrame* mutable_key_frames(int index);
  inline ::Serializer::BakedKeyFrame* add_key_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::BakedKeyFrame >&
      key_frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::BakedKeyFrame >*
      mutable_key_frames();
  
  // optional int32 frame_rate = 3;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 3;
  inline ::google::protobuf::int32 frame_rate() const;
  inline void set_frame_rate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Serializer.BakedAnimationData)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::BakedKeyFrame > key_frames_;
  ::google::protobuf::int32 frame_rate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Animation_2eproto();
  friend void protobuf_AssignDesc_Animation_2eproto();
  friend void protobuf_ShutdownFile_Animation_2eproto();
  
  void InitAsDefaultInstance();
  static BakedAnimationData* default_instance_;
};
// ===================================================================


// ===================================================================

// Curve

// repeated .Serializer.Vector4f KeyPoints = 1;
inline int Curve::keypoints_size() const {
  return keypoints_.size();
}
inline void Curve::clear_keypoints() {
  keypoints_.Clear();
}
inline const ::Serializer::Vector4f& Curve::keypoints(int index) const {
  return keypoints_.Get(index);
}
inline ::Serializer::Vector4f* Curve::mutable_keypoints(int index) {
  return keypoints_.Mutable(index);
}
inline ::Serializer::Vector4f* Curve::add_keypoints() {
  return keypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Vector4f >&
Curve::keypoints() const {
  return keypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Vector4f >*
Curve::mutable_keypoints() {
  return &keypoints_;
}

// -------------------------------------------------------------------

// CubicBezier

// optional .Serializer.Vector2f p1 = 1;
inline bool CubicBezier::has_p1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CubicBezier::set_has_p1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CubicBezier::clear_has_p1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CubicBezier::clear_p1() {
  if (p1_ != NULL) p1_->::Serializer::Vector2f::Clear();
  clear_has_p1();
}
inline const ::Serializer::Vector2f& CubicBezier::p1() const {
  return p1_ != NULL ? *p1_ : *default_instance_->p1_;
}
inline ::Serializer::Vector2f* CubicBezier::mutable_p1() {
  set_has_p1();
  if (p1_ == NULL) p1_ = new ::Serializer::Vector2f;
  return p1_;
}
inline ::Serializer::Vector2f* CubicBezier::release_p1() {
  clear_has_p1();
  ::Serializer::Vector2f* temp = p1_;
  p1_ = NULL;
  return temp;
}

// optional .Serializer.Vector2f p2 = 2;
inline bool CubicBezier::has_p2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CubicBezier::set_has_p2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CubicBezier::clear_has_p2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CubicBezier::clear_p2() {
  if (p2_ != NULL) p2_->::Serializer::Vector2f::Clear();
  clear_has_p2();
}
inline const ::Serializer::Vector2f& CubicBezier::p2() const {
  return p2_ != NULL ? *p2_ : *default_instance_->p2_;
}
inline ::Serializer::Vector2f* CubicBezier::mutable_p2() {
  set_has_p2();
  if (p2_ == NULL) p2_ = new ::Serializer::Vector2f;
  return p2_;
}
inline ::Serializer::Vector2f* CubicBezier::release_p2() {
  clear_has_p2();
  ::Serializer::Vector2f* temp = p2_;
  p2_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RotateAnimationKeyFrame

// optional float time = 1;
inline bool RotateAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotateAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotateAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotateAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float RotateAnimationKeyFrame::time() const {
  return time_;
}
inline void RotateAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional int32 interpolation_type = 2;
inline bool RotateAnimationKeyFrame::has_interpolation_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotateAnimationKeyFrame::set_has_interpolation_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotateAnimationKeyFrame::clear_has_interpolation_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotateAnimationKeyFrame::clear_interpolation_type() {
  interpolation_type_ = 0;
  clear_has_interpolation_type();
}
inline ::google::protobuf::int32 RotateAnimationKeyFrame::interpolation_type() const {
  return interpolation_type_;
}
inline void RotateAnimationKeyFrame::set_interpolation_type(::google::protobuf::int32 value) {
  set_has_interpolation_type();
  interpolation_type_ = value;
}

// repeated float external_args = 3;
inline int RotateAnimationKeyFrame::external_args_size() const {
  return external_args_.size();
}
inline void RotateAnimationKeyFrame::clear_external_args() {
  external_args_.Clear();
}
inline float RotateAnimationKeyFrame::external_args(int index) const {
  return external_args_.Get(index);
}
inline void RotateAnimationKeyFrame::set_external_args(int index, float value) {
  external_args_.Set(index, value);
}
inline void RotateAnimationKeyFrame::add_external_args(float value) {
  external_args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RotateAnimationKeyFrame::external_args() const {
  return external_args_;
}
inline ::google::protobuf::RepeatedField< float >*
RotateAnimationKeyFrame::mutable_external_args() {
  return &external_args_;
}

// repeated float rotation = 4;
inline int RotateAnimationKeyFrame::rotation_size() const {
  return rotation_.size();
}
inline void RotateAnimationKeyFrame::clear_rotation() {
  rotation_.Clear();
}
inline float RotateAnimationKeyFrame::rotation(int index) const {
  return rotation_.Get(index);
}
inline void RotateAnimationKeyFrame::set_rotation(int index, float value) {
  rotation_.Set(index, value);
}
inline void RotateAnimationKeyFrame::add_rotation(float value) {
  rotation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RotateAnimationKeyFrame::rotation() const {
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
RotateAnimationKeyFrame::mutable_rotation() {
  return &rotation_;
}

// -------------------------------------------------------------------

// RotateAnimationClip

// repeated .Serializer.RotateAnimationKeyFrame key_frames = 1;
inline int RotateAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void RotateAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::RotateAnimationKeyFrame& RotateAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::RotateAnimationKeyFrame* RotateAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::RotateAnimationKeyFrame* RotateAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::RotateAnimationKeyFrame >&
RotateAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::RotateAnimationKeyFrame >*
RotateAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// TranslateAnimationKeyFrame

// optional float time = 1;
inline bool TranslateAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranslateAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranslateAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranslateAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float TranslateAnimationKeyFrame::time() const {
  return time_;
}
inline void TranslateAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional int32 interpolation_type = 2;
inline bool TranslateAnimationKeyFrame::has_interpolation_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranslateAnimationKeyFrame::set_has_interpolation_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranslateAnimationKeyFrame::clear_has_interpolation_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranslateAnimationKeyFrame::clear_interpolation_type() {
  interpolation_type_ = 0;
  clear_has_interpolation_type();
}
inline ::google::protobuf::int32 TranslateAnimationKeyFrame::interpolation_type() const {
  return interpolation_type_;
}
inline void TranslateAnimationKeyFrame::set_interpolation_type(::google::protobuf::int32 value) {
  set_has_interpolation_type();
  interpolation_type_ = value;
}

// repeated float external_args = 3;
inline int TranslateAnimationKeyFrame::external_args_size() const {
  return external_args_.size();
}
inline void TranslateAnimationKeyFrame::clear_external_args() {
  external_args_.Clear();
}
inline float TranslateAnimationKeyFrame::external_args(int index) const {
  return external_args_.Get(index);
}
inline void TranslateAnimationKeyFrame::set_external_args(int index, float value) {
  external_args_.Set(index, value);
}
inline void TranslateAnimationKeyFrame::add_external_args(float value) {
  external_args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TranslateAnimationKeyFrame::external_args() const {
  return external_args_;
}
inline ::google::protobuf::RepeatedField< float >*
TranslateAnimationKeyFrame::mutable_external_args() {
  return &external_args_;
}

// repeated float translation = 4;
inline int TranslateAnimationKeyFrame::translation_size() const {
  return translation_.size();
}
inline void TranslateAnimationKeyFrame::clear_translation() {
  translation_.Clear();
}
inline float TranslateAnimationKeyFrame::translation(int index) const {
  return translation_.Get(index);
}
inline void TranslateAnimationKeyFrame::set_translation(int index, float value) {
  translation_.Set(index, value);
}
inline void TranslateAnimationKeyFrame::add_translation(float value) {
  translation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TranslateAnimationKeyFrame::translation() const {
  return translation_;
}
inline ::google::protobuf::RepeatedField< float >*
TranslateAnimationKeyFrame::mutable_translation() {
  return &translation_;
}

// -------------------------------------------------------------------

// TranslateAnimationClip

// repeated .Serializer.TranslateAnimationKeyFrame key_frames = 1;
inline int TranslateAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void TranslateAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::TranslateAnimationKeyFrame& TranslateAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::TranslateAnimationKeyFrame* TranslateAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::TranslateAnimationKeyFrame* TranslateAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::TranslateAnimationKeyFrame >&
TranslateAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::TranslateAnimationKeyFrame >*
TranslateAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// ScaleAnimationKeyFrame

// optional float time = 1;
inline bool ScaleAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScaleAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScaleAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScaleAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float ScaleAnimationKeyFrame::time() const {
  return time_;
}
inline void ScaleAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional int32 interpolation_type = 2;
inline bool ScaleAnimationKeyFrame::has_interpolation_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScaleAnimationKeyFrame::set_has_interpolation_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScaleAnimationKeyFrame::clear_has_interpolation_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScaleAnimationKeyFrame::clear_interpolation_type() {
  interpolation_type_ = 0;
  clear_has_interpolation_type();
}
inline ::google::protobuf::int32 ScaleAnimationKeyFrame::interpolation_type() const {
  return interpolation_type_;
}
inline void ScaleAnimationKeyFrame::set_interpolation_type(::google::protobuf::int32 value) {
  set_has_interpolation_type();
  interpolation_type_ = value;
}

// repeated float external_args = 3;
inline int ScaleAnimationKeyFrame::external_args_size() const {
  return external_args_.size();
}
inline void ScaleAnimationKeyFrame::clear_external_args() {
  external_args_.Clear();
}
inline float ScaleAnimationKeyFrame::external_args(int index) const {
  return external_args_.Get(index);
}
inline void ScaleAnimationKeyFrame::set_external_args(int index, float value) {
  external_args_.Set(index, value);
}
inline void ScaleAnimationKeyFrame::add_external_args(float value) {
  external_args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ScaleAnimationKeyFrame::external_args() const {
  return external_args_;
}
inline ::google::protobuf::RepeatedField< float >*
ScaleAnimationKeyFrame::mutable_external_args() {
  return &external_args_;
}

// repeated float scale = 4;
inline int ScaleAnimationKeyFrame::scale_size() const {
  return scale_.size();
}
inline void ScaleAnimationKeyFrame::clear_scale() {
  scale_.Clear();
}
inline float ScaleAnimationKeyFrame::scale(int index) const {
  return scale_.Get(index);
}
inline void ScaleAnimationKeyFrame::set_scale(int index, float value) {
  scale_.Set(index, value);
}
inline void ScaleAnimationKeyFrame::add_scale(float value) {
  scale_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ScaleAnimationKeyFrame::scale() const {
  return scale_;
}
inline ::google::protobuf::RepeatedField< float >*
ScaleAnimationKeyFrame::mutable_scale() {
  return &scale_;
}

// -------------------------------------------------------------------

// ScaleAnimationClip

// repeated .Serializer.ScaleAnimationKeyFrame key_frames = 1;
inline int ScaleAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void ScaleAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::ScaleAnimationKeyFrame& ScaleAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::ScaleAnimationKeyFrame* ScaleAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::ScaleAnimationKeyFrame* ScaleAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::ScaleAnimationKeyFrame >&
ScaleAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::ScaleAnimationKeyFrame >*
ScaleAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// ShearAnimationKeyFrame

// optional float time = 1;
inline bool ShearAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShearAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShearAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShearAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float ShearAnimationKeyFrame::time() const {
  return time_;
}
inline void ShearAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional int32 interpolation_type = 2;
inline bool ShearAnimationKeyFrame::has_interpolation_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShearAnimationKeyFrame::set_has_interpolation_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShearAnimationKeyFrame::clear_has_interpolation_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShearAnimationKeyFrame::clear_interpolation_type() {
  interpolation_type_ = 0;
  clear_has_interpolation_type();
}
inline ::google::protobuf::int32 ShearAnimationKeyFrame::interpolation_type() const {
  return interpolation_type_;
}
inline void ShearAnimationKeyFrame::set_interpolation_type(::google::protobuf::int32 value) {
  set_has_interpolation_type();
  interpolation_type_ = value;
}

// repeated float external_args = 3;
inline int ShearAnimationKeyFrame::external_args_size() const {
  return external_args_.size();
}
inline void ShearAnimationKeyFrame::clear_external_args() {
  external_args_.Clear();
}
inline float ShearAnimationKeyFrame::external_args(int index) const {
  return external_args_.Get(index);
}
inline void ShearAnimationKeyFrame::set_external_args(int index, float value) {
  external_args_.Set(index, value);
}
inline void ShearAnimationKeyFrame::add_external_args(float value) {
  external_args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ShearAnimationKeyFrame::external_args() const {
  return external_args_;
}
inline ::google::protobuf::RepeatedField< float >*
ShearAnimationKeyFrame::mutable_external_args() {
  return &external_args_;
}

// repeated float shear = 4;
inline int ShearAnimationKeyFrame::shear_size() const {
  return shear_.size();
}
inline void ShearAnimationKeyFrame::clear_shear() {
  shear_.Clear();
}
inline float ShearAnimationKeyFrame::shear(int index) const {
  return shear_.Get(index);
}
inline void ShearAnimationKeyFrame::set_shear(int index, float value) {
  shear_.Set(index, value);
}
inline void ShearAnimationKeyFrame::add_shear(float value) {
  shear_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ShearAnimationKeyFrame::shear() const {
  return shear_;
}
inline ::google::protobuf::RepeatedField< float >*
ShearAnimationKeyFrame::mutable_shear() {
  return &shear_;
}

// -------------------------------------------------------------------

// ShearAnimationClip

// repeated .Serializer.ShearAnimationKeyFrame key_frames = 1;
inline int ShearAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void ShearAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::ShearAnimationKeyFrame& ShearAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::ShearAnimationKeyFrame* ShearAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::ShearAnimationKeyFrame* ShearAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::ShearAnimationKeyFrame >&
ShearAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::ShearAnimationKeyFrame >*
ShearAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// SpriteSequenceAnimationKeyFrame

// optional float time = 1;
inline bool SpriteSequenceAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpriteSequenceAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpriteSequenceAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpriteSequenceAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float SpriteSequenceAnimationKeyFrame::time() const {
  return time_;
}
inline void SpriteSequenceAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional string image_name = 2;
inline bool SpriteSequenceAnimationKeyFrame::has_image_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpriteSequenceAnimationKeyFrame::set_has_image_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpriteSequenceAnimationKeyFrame::clear_has_image_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpriteSequenceAnimationKeyFrame::clear_image_name() {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    image_name_->clear();
  }
  clear_has_image_name();
}
inline const ::std::string& SpriteSequenceAnimationKeyFrame::image_name() const {
  return *image_name_;
}
inline void SpriteSequenceAnimationKeyFrame::set_image_name(const ::std::string& value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void SpriteSequenceAnimationKeyFrame::set_image_name(const char* value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void SpriteSequenceAnimationKeyFrame::set_image_name(const char* value, size_t size) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpriteSequenceAnimationKeyFrame::mutable_image_name() {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  return image_name_;
}
inline ::std::string* SpriteSequenceAnimationKeyFrame::release_image_name() {
  clear_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_name_;
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SpriteSequenceAnimationClip

// repeated .Serializer.SpriteSequenceAnimationKeyFrame key_frames = 1;
inline int SpriteSequenceAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void SpriteSequenceAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::SpriteSequenceAnimationKeyFrame& SpriteSequenceAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::SpriteSequenceAnimationKeyFrame* SpriteSequenceAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::SpriteSequenceAnimationKeyFrame* SpriteSequenceAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::SpriteSequenceAnimationKeyFrame >&
SpriteSequenceAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::SpriteSequenceAnimationKeyFrame >*
SpriteSequenceAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// ColorAnimationKeyFrame

// optional float time = 1;
inline bool ColorAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColorAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColorAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColorAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float ColorAnimationKeyFrame::time() const {
  return time_;
}
inline void ColorAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional int32 interpolation_type = 2;
inline bool ColorAnimationKeyFrame::has_interpolation_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColorAnimationKeyFrame::set_has_interpolation_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColorAnimationKeyFrame::clear_has_interpolation_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColorAnimationKeyFrame::clear_interpolation_type() {
  interpolation_type_ = 0;
  clear_has_interpolation_type();
}
inline ::google::protobuf::int32 ColorAnimationKeyFrame::interpolation_type() const {
  return interpolation_type_;
}
inline void ColorAnimationKeyFrame::set_interpolation_type(::google::protobuf::int32 value) {
  set_has_interpolation_type();
  interpolation_type_ = value;
}

// repeated float external_args = 3;
inline int ColorAnimationKeyFrame::external_args_size() const {
  return external_args_.size();
}
inline void ColorAnimationKeyFrame::clear_external_args() {
  external_args_.Clear();
}
inline float ColorAnimationKeyFrame::external_args(int index) const {
  return external_args_.Get(index);
}
inline void ColorAnimationKeyFrame::set_external_args(int index, float value) {
  external_args_.Set(index, value);
}
inline void ColorAnimationKeyFrame::add_external_args(float value) {
  external_args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ColorAnimationKeyFrame::external_args() const {
  return external_args_;
}
inline ::google::protobuf::RepeatedField< float >*
ColorAnimationKeyFrame::mutable_external_args() {
  return &external_args_;
}

// repeated float color = 4;
inline int ColorAnimationKeyFrame::color_size() const {
  return color_.size();
}
inline void ColorAnimationKeyFrame::clear_color() {
  color_.Clear();
}
inline float ColorAnimationKeyFrame::color(int index) const {
  return color_.Get(index);
}
inline void ColorAnimationKeyFrame::set_color(int index, float value) {
  color_.Set(index, value);
}
inline void ColorAnimationKeyFrame::add_color(float value) {
  color_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ColorAnimationKeyFrame::color() const {
  return color_;
}
inline ::google::protobuf::RepeatedField< float >*
ColorAnimationKeyFrame::mutable_color() {
  return &color_;
}

// -------------------------------------------------------------------

// ColorAnimationClip

// repeated .Serializer.ColorAnimationKeyFrame key_frames = 1;
inline int ColorAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void ColorAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::ColorAnimationKeyFrame& ColorAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::ColorAnimationKeyFrame* ColorAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::ColorAnimationKeyFrame* ColorAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::ColorAnimationKeyFrame >&
ColorAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::ColorAnimationKeyFrame >*
ColorAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// TwoColorAnimationKeyFrame

// optional float time = 1;
inline bool TwoColorAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TwoColorAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TwoColorAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TwoColorAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float TwoColorAnimationKeyFrame::time() const {
  return time_;
}
inline void TwoColorAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional int32 interpolation_type = 2;
inline bool TwoColorAnimationKeyFrame::has_interpolation_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TwoColorAnimationKeyFrame::set_has_interpolation_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TwoColorAnimationKeyFrame::clear_has_interpolation_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TwoColorAnimationKeyFrame::clear_interpolation_type() {
  interpolation_type_ = 0;
  clear_has_interpolation_type();
}
inline ::google::protobuf::int32 TwoColorAnimationKeyFrame::interpolation_type() const {
  return interpolation_type_;
}
inline void TwoColorAnimationKeyFrame::set_interpolation_type(::google::protobuf::int32 value) {
  set_has_interpolation_type();
  interpolation_type_ = value;
}

// repeated float external_args = 3;
inline int TwoColorAnimationKeyFrame::external_args_size() const {
  return external_args_.size();
}
inline void TwoColorAnimationKeyFrame::clear_external_args() {
  external_args_.Clear();
}
inline float TwoColorAnimationKeyFrame::external_args(int index) const {
  return external_args_.Get(index);
}
inline void TwoColorAnimationKeyFrame::set_external_args(int index, float value) {
  external_args_.Set(index, value);
}
inline void TwoColorAnimationKeyFrame::add_external_args(float value) {
  external_args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TwoColorAnimationKeyFrame::external_args() const {
  return external_args_;
}
inline ::google::protobuf::RepeatedField< float >*
TwoColorAnimationKeyFrame::mutable_external_args() {
  return &external_args_;
}

// repeated float light = 4;
inline int TwoColorAnimationKeyFrame::light_size() const {
  return light_.size();
}
inline void TwoColorAnimationKeyFrame::clear_light() {
  light_.Clear();
}
inline float TwoColorAnimationKeyFrame::light(int index) const {
  return light_.Get(index);
}
inline void TwoColorAnimationKeyFrame::set_light(int index, float value) {
  light_.Set(index, value);
}
inline void TwoColorAnimationKeyFrame::add_light(float value) {
  light_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TwoColorAnimationKeyFrame::light() const {
  return light_;
}
inline ::google::protobuf::RepeatedField< float >*
TwoColorAnimationKeyFrame::mutable_light() {
  return &light_;
}

// repeated float dark = 5;
inline int TwoColorAnimationKeyFrame::dark_size() const {
  return dark_.size();
}
inline void TwoColorAnimationKeyFrame::clear_dark() {
  dark_.Clear();
}
inline float TwoColorAnimationKeyFrame::dark(int index) const {
  return dark_.Get(index);
}
inline void TwoColorAnimationKeyFrame::set_dark(int index, float value) {
  dark_.Set(index, value);
}
inline void TwoColorAnimationKeyFrame::add_dark(float value) {
  dark_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TwoColorAnimationKeyFrame::dark() const {
  return dark_;
}
inline ::google::protobuf::RepeatedField< float >*
TwoColorAnimationKeyFrame::mutable_dark() {
  return &dark_;
}

// -------------------------------------------------------------------

// TwoColorAnimationClip

// repeated .Serializer.TwoColorAnimationKeyFrame key_frames = 1;
inline int TwoColorAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void TwoColorAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::TwoColorAnimationKeyFrame& TwoColorAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::TwoColorAnimationKeyFrame* TwoColorAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::TwoColorAnimationKeyFrame* TwoColorAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::TwoColorAnimationKeyFrame >&
TwoColorAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::TwoColorAnimationKeyFrame >*
TwoColorAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// DrawOrderAnimationKeyFrame

// optional float time = 1;
inline bool DrawOrderAnimationKeyFrame::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawOrderAnimationKeyFrame::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawOrderAnimationKeyFrame::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawOrderAnimationKeyFrame::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float DrawOrderAnimationKeyFrame::time() const {
  return time_;
}
inline void DrawOrderAnimationKeyFrame::set_time(float value) {
  set_has_time();
  time_ = value;
}

// repeated string draw_order = 2;
inline int DrawOrderAnimationKeyFrame::draw_order_size() const {
  return draw_order_.size();
}
inline void DrawOrderAnimationKeyFrame::clear_draw_order() {
  draw_order_.Clear();
}
inline const ::std::string& DrawOrderAnimationKeyFrame::draw_order(int index) const {
  return draw_order_.Get(index);
}
inline ::std::string* DrawOrderAnimationKeyFrame::mutable_draw_order(int index) {
  return draw_order_.Mutable(index);
}
inline void DrawOrderAnimationKeyFrame::set_draw_order(int index, const ::std::string& value) {
  draw_order_.Mutable(index)->assign(value);
}
inline void DrawOrderAnimationKeyFrame::set_draw_order(int index, const char* value) {
  draw_order_.Mutable(index)->assign(value);
}
inline void DrawOrderAnimationKeyFrame::set_draw_order(int index, const char* value, size_t size) {
  draw_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrawOrderAnimationKeyFrame::add_draw_order() {
  return draw_order_.Add();
}
inline void DrawOrderAnimationKeyFrame::add_draw_order(const ::std::string& value) {
  draw_order_.Add()->assign(value);
}
inline void DrawOrderAnimationKeyFrame::add_draw_order(const char* value) {
  draw_order_.Add()->assign(value);
}
inline void DrawOrderAnimationKeyFrame::add_draw_order(const char* value, size_t size) {
  draw_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DrawOrderAnimationKeyFrame::draw_order() const {
  return draw_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DrawOrderAnimationKeyFrame::mutable_draw_order() {
  return &draw_order_;
}

// -------------------------------------------------------------------

// DrawOrderAnimationClip

// repeated .Serializer.DrawOrderAnimationKeyFrame key_frames = 1;
inline int DrawOrderAnimationClip::key_frames_size() const {
  return key_frames_.size();
}
inline void DrawOrderAnimationClip::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::DrawOrderAnimationKeyFrame& DrawOrderAnimationClip::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::DrawOrderAnimationKeyFrame* DrawOrderAnimationClip::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::DrawOrderAnimationKeyFrame* DrawOrderAnimationClip::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::DrawOrderAnimationKeyFrame >&
DrawOrderAnimationClip::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::DrawOrderAnimationKeyFrame >*
DrawOrderAnimationClip::mutable_key_frames() {
  return &key_frames_;
}

// -------------------------------------------------------------------

// AnimationClip

// optional int32 type = 1;
inline bool AnimationClip::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimationClip::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimationClip::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimationClip::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AnimationClip::type() const {
  return type_;
}
inline void AnimationClip::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string target = 2;
inline bool AnimationClip::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnimationClip::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnimationClip::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnimationClip::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& AnimationClip::target() const {
  return *target_;
}
inline void AnimationClip::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void AnimationClip::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void AnimationClip::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimationClip::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* AnimationClip::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 target_component = 3;
inline bool AnimationClip::has_target_component() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnimationClip::set_has_target_component() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnimationClip::clear_has_target_component() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnimationClip::clear_target_component() {
  target_component_ = 0;
  clear_has_target_component();
}
inline ::google::protobuf::int32 AnimationClip::target_component() const {
  return target_component_;
}
inline void AnimationClip::set_target_component(::google::protobuf::int32 value) {
  set_has_target_component();
  target_component_ = value;
}

// optional bytes animation_clip_data = 4;
inline bool AnimationClip::has_animation_clip_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnimationClip::set_has_animation_clip_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnimationClip::clear_has_animation_clip_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnimationClip::clear_animation_clip_data() {
  if (animation_clip_data_ != &::google::protobuf::internal::kEmptyString) {
    animation_clip_data_->clear();
  }
  clear_has_animation_clip_data();
}
inline const ::std::string& AnimationClip::animation_clip_data() const {
  return *animation_clip_data_;
}
inline void AnimationClip::set_animation_clip_data(const ::std::string& value) {
  set_has_animation_clip_data();
  if (animation_clip_data_ == &::google::protobuf::internal::kEmptyString) {
    animation_clip_data_ = new ::std::string;
  }
  animation_clip_data_->assign(value);
}
inline void AnimationClip::set_animation_clip_data(const char* value) {
  set_has_animation_clip_data();
  if (animation_clip_data_ == &::google::protobuf::internal::kEmptyString) {
    animation_clip_data_ = new ::std::string;
  }
  animation_clip_data_->assign(value);
}
inline void AnimationClip::set_animation_clip_data(const void* value, size_t size) {
  set_has_animation_clip_data();
  if (animation_clip_data_ == &::google::protobuf::internal::kEmptyString) {
    animation_clip_data_ = new ::std::string;
  }
  animation_clip_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimationClip::mutable_animation_clip_data() {
  set_has_animation_clip_data();
  if (animation_clip_data_ == &::google::protobuf::internal::kEmptyString) {
    animation_clip_data_ = new ::std::string;
  }
  return animation_clip_data_;
}
inline ::std::string* AnimationClip::release_animation_clip_data() {
  clear_has_animation_clip_data();
  if (animation_clip_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = animation_clip_data_;
    animation_clip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Animation

// optional string name = 1;
inline bool Animation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Animation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Animation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Animation::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Animation::name() const {
  return *name_;
}
inline void Animation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Animation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Animation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Animation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Animation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float duration = 2;
inline bool Animation::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Animation::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Animation::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Animation::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float Animation::duration() const {
  return duration_;
}
inline void Animation::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// repeated .Serializer.AnimationClip animation_clips = 3;
inline int Animation::animation_clips_size() const {
  return animation_clips_.size();
}
inline void Animation::clear_animation_clips() {
  animation_clips_.Clear();
}
inline const ::Serializer::AnimationClip& Animation::animation_clips(int index) const {
  return animation_clips_.Get(index);
}
inline ::Serializer::AnimationClip* Animation::mutable_animation_clips(int index) {
  return animation_clips_.Mutable(index);
}
inline ::Serializer::AnimationClip* Animation::add_animation_clips() {
  return animation_clips_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::AnimationClip >&
Animation::animation_clips() const {
  return animation_clips_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::AnimationClip >*
Animation::mutable_animation_clips() {
  return &animation_clips_;
}

// -------------------------------------------------------------------

// BakedMeshData

// optional bytes vertex_buffer = 1;
inline bool BakedMeshData::has_vertex_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BakedMeshData::set_has_vertex_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BakedMeshData::clear_has_vertex_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BakedMeshData::clear_vertex_buffer() {
  if (vertex_buffer_ != &::google::protobuf::internal::kEmptyString) {
    vertex_buffer_->clear();
  }
  clear_has_vertex_buffer();
}
inline const ::std::string& BakedMeshData::vertex_buffer() const {
  return *vertex_buffer_;
}
inline void BakedMeshData::set_vertex_buffer(const ::std::string& value) {
  set_has_vertex_buffer();
  if (vertex_buffer_ == &::google::protobuf::internal::kEmptyString) {
    vertex_buffer_ = new ::std::string;
  }
  vertex_buffer_->assign(value);
}
inline void BakedMeshData::set_vertex_buffer(const char* value) {
  set_has_vertex_buffer();
  if (vertex_buffer_ == &::google::protobuf::internal::kEmptyString) {
    vertex_buffer_ = new ::std::string;
  }
  vertex_buffer_->assign(value);
}
inline void BakedMeshData::set_vertex_buffer(const void* value, size_t size) {
  set_has_vertex_buffer();
  if (vertex_buffer_ == &::google::protobuf::internal::kEmptyString) {
    vertex_buffer_ = new ::std::string;
  }
  vertex_buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BakedMeshData::mutable_vertex_buffer() {
  set_has_vertex_buffer();
  if (vertex_buffer_ == &::google::protobuf::internal::kEmptyString) {
    vertex_buffer_ = new ::std::string;
  }
  return vertex_buffer_;
}
inline ::std::string* BakedMeshData::release_vertex_buffer() {
  clear_has_vertex_buffer();
  if (vertex_buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vertex_buffer_;
    vertex_buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes offset_matrix = 2;
inline bool BakedMeshData::has_offset_matrix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BakedMeshData::set_has_offset_matrix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BakedMeshData::clear_has_offset_matrix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BakedMeshData::clear_offset_matrix() {
  if (offset_matrix_ != &::google::protobuf::internal::kEmptyString) {
    offset_matrix_->clear();
  }
  clear_has_offset_matrix();
}
inline const ::std::string& BakedMeshData::offset_matrix() const {
  return *offset_matrix_;
}
inline void BakedMeshData::set_offset_matrix(const ::std::string& value) {
  set_has_offset_matrix();
  if (offset_matrix_ == &::google::protobuf::internal::kEmptyString) {
    offset_matrix_ = new ::std::string;
  }
  offset_matrix_->assign(value);
}
inline void BakedMeshData::set_offset_matrix(const char* value) {
  set_has_offset_matrix();
  if (offset_matrix_ == &::google::protobuf::internal::kEmptyString) {
    offset_matrix_ = new ::std::string;
  }
  offset_matrix_->assign(value);
}
inline void BakedMeshData::set_offset_matrix(const void* value, size_t size) {
  set_has_offset_matrix();
  if (offset_matrix_ == &::google::protobuf::internal::kEmptyString) {
    offset_matrix_ = new ::std::string;
  }
  offset_matrix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BakedMeshData::mutable_offset_matrix() {
  set_has_offset_matrix();
  if (offset_matrix_ == &::google::protobuf::internal::kEmptyString) {
    offset_matrix_ = new ::std::string;
  }
  return offset_matrix_;
}
inline ::std::string* BakedMeshData::release_offset_matrix() {
  clear_has_offset_matrix();
  if (offset_matrix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = offset_matrix_;
    offset_matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BakedKeyFrame

// repeated .Serializer.BakedMeshData mesh_datas = 1;
inline int BakedKeyFrame::mesh_datas_size() const {
  return mesh_datas_.size();
}
inline void BakedKeyFrame::clear_mesh_datas() {
  mesh_datas_.Clear();
}
inline const ::Serializer::BakedMeshData& BakedKeyFrame::mesh_datas(int index) const {
  return mesh_datas_.Get(index);
}
inline ::Serializer::BakedMeshData* BakedKeyFrame::mutable_mesh_datas(int index) {
  return mesh_datas_.Mutable(index);
}
inline ::Serializer::BakedMeshData* BakedKeyFrame::add_mesh_datas() {
  return mesh_datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::BakedMeshData >&
BakedKeyFrame::mesh_datas() const {
  return mesh_datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::BakedMeshData >*
BakedKeyFrame::mutable_mesh_datas() {
  return &mesh_datas_;
}

// -------------------------------------------------------------------

// BakedAnimationData

// optional string name = 1;
inline bool BakedAnimationData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BakedAnimationData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BakedAnimationData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BakedAnimationData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BakedAnimationData::name() const {
  return *name_;
}
inline void BakedAnimationData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BakedAnimationData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BakedAnimationData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BakedAnimationData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BakedAnimationData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Serializer.BakedKeyFrame key_frames = 2;
inline int BakedAnimationData::key_frames_size() const {
  return key_frames_.size();
}
inline void BakedAnimationData::clear_key_frames() {
  key_frames_.Clear();
}
inline const ::Serializer::BakedKeyFrame& BakedAnimationData::key_frames(int index) const {
  return key_frames_.Get(index);
}
inline ::Serializer::BakedKeyFrame* BakedAnimationData::mutable_key_frames(int index) {
  return key_frames_.Mutable(index);
}
inline ::Serializer::BakedKeyFrame* BakedAnimationData::add_key_frames() {
  return key_frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::BakedKeyFrame >&
BakedAnimationData::key_frames() const {
  return key_frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::BakedKeyFrame >*
BakedAnimationData::mutable_key_frames() {
  return &key_frames_;
}

// optional int32 frame_rate = 3;
inline bool BakedAnimationData::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BakedAnimationData::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BakedAnimationData::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BakedAnimationData::clear_frame_rate() {
  frame_rate_ = 0;
  clear_has_frame_rate();
}
inline ::google::protobuf::int32 BakedAnimationData::frame_rate() const {
  return frame_rate_;
}
inline void BakedAnimationData::set_frame_rate(::google::protobuf::int32 value) {
  set_has_frame_rate();
  frame_rate_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Animation_2eproto__INCLUDED
