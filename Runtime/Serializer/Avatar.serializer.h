// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Avatar.proto

#ifndef PROTOBUF_Avatar_2eproto__INCLUDED
#define PROTOBUF_Avatar_2eproto__INCLUDED

#include <string>

#include "common.h"

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "generated_message_util.h"
#include "repeated_field.h"
#include "extension_set.h"
#include "Vector.serializer.h"
#include "Mesh.serializer.h"
#include "GameObject.serializer.h"
#include "Animation.serializer.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Avatar_2eproto();
void protobuf_AssignDesc_Avatar_2eproto();
void protobuf_ShutdownFile_Avatar_2eproto();

class Bone;
class Slot;
class RegionAttachment;
class Attachment;
class SlotAvailableAttachmentsInfo;
class Skin;
class SpineAvatar;
class Avatar3D;

// ===================================================================

class Bone : public ::google::protobuf::MessageLite {
 public:
  Bone();
  virtual ~Bone();
  
  Bone(const Bone& from);
  
  inline Bone& operator=(const Bone& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Bone& default_instance();
  
  void Swap(Bone* other);
  
  // implements Message ----------------------------------------------
  
  Bone* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Bone& from);
  void MergeFrom(const Bone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated float translate = 2;
  inline int translate_size() const;
  inline void clear_translate();
  static const int kTranslateFieldNumber = 2;
  inline float translate(int index) const;
  inline void set_translate(int index, float value);
  inline void add_translate(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      translate() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_translate();
  
  // repeated float rotation = 3;
  inline int rotation_size() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 3;
  inline float rotation(int index) const;
  inline void set_rotation(int index, float value);
  inline void add_rotation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_rotation();
  
  // repeated float scale = 4;
  inline int scale_size() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  inline float scale(int index) const;
  inline void set_scale(int index, float value);
  inline void add_scale(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      scale() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_scale();
  
  // repeated float shear = 5;
  inline int shear_size() const;
  inline void clear_shear();
  static const int kShearFieldNumber = 5;
  inline float shear(int index) const;
  inline void set_shear(int index, float value);
  inline void add_shear(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      shear() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_shear();
  
  // @@protoc_insertion_point(class_scope:Serializer.Bone)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedField< float > translate_;
  ::google::protobuf::RepeatedField< float > rotation_;
  ::google::protobuf::RepeatedField< float > scale_;
  ::google::protobuf::RepeatedField< float > shear_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static Bone* default_instance_;
};
// -------------------------------------------------------------------

class Slot : public ::google::protobuf::MessageLite {
 public:
  Slot();
  virtual ~Slot();
  
  Slot(const Slot& from);
  
  inline Slot& operator=(const Slot& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Slot& default_instance();
  
  void Swap(Slot* other);
  
  // implements Message ----------------------------------------------
  
  Slot* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Slot& from);
  void MergeFrom(const Slot& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated float color = 2;
  inline int color_size() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline float color(int index) const;
  inline void set_color(int index, float value);
  inline void add_color(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      color() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_color();
  
  // repeated float dark = 3;
  inline int dark_size() const;
  inline void clear_dark();
  static const int kDarkFieldNumber = 3;
  inline float dark(int index) const;
  inline void set_dark(int index, float value);
  inline void add_dark(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      dark() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_dark();
  
  // optional string attachment = 4;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 4;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const char* value, size_t size);
  inline ::std::string* mutable_attachment();
  inline ::std::string* release_attachment();
  
  // optional int32 blend_func_src = 5;
  inline bool has_blend_func_src() const;
  inline void clear_blend_func_src();
  static const int kBlendFuncSrcFieldNumber = 5;
  inline ::google::protobuf::int32 blend_func_src() const;
  inline void set_blend_func_src(::google::protobuf::int32 value);
  
  // optional int32 blend_func_dst = 6;
  inline bool has_blend_func_dst() const;
  inline void clear_blend_func_dst();
  static const int kBlendFuncDstFieldNumber = 6;
  inline ::google::protobuf::int32 blend_func_dst() const;
  inline void set_blend_func_dst(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Serializer.Slot)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_blend_func_src();
  inline void clear_has_blend_func_src();
  inline void set_has_blend_func_dst();
  inline void clear_has_blend_func_dst();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedField< float > color_;
  ::google::protobuf::RepeatedField< float > dark_;
  ::std::string* attachment_;
  ::google::protobuf::int32 blend_func_src_;
  ::google::protobuf::int32 blend_func_dst_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static Slot* default_instance_;
};
// -------------------------------------------------------------------

class RegionAttachment : public ::google::protobuf::MessageLite {
 public:
  RegionAttachment();
  virtual ~RegionAttachment();
  
  RegionAttachment(const RegionAttachment& from);
  
  inline RegionAttachment& operator=(const RegionAttachment& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RegionAttachment& default_instance();
  
  void Swap(RegionAttachment* other);
  
  // implements Message ----------------------------------------------
  
  RegionAttachment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegionAttachment& from);
  void MergeFrom(const RegionAttachment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float translate = 1;
  inline int translate_size() const;
  inline void clear_translate();
  static const int kTranslateFieldNumber = 1;
  inline float translate(int index) const;
  inline void set_translate(int index, float value);
  inline void add_translate(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      translate() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_translate();
  
  // repeated float rotation = 2;
  inline int rotation_size() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 2;
  inline float rotation(int index) const;
  inline void set_rotation(int index, float value);
  inline void add_rotation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_rotation();
  
  // repeated float scale = 3;
  inline int scale_size() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 3;
  inline float scale(int index) const;
  inline void set_scale(int index, float value);
  inline void add_scale(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      scale() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_scale();
  
  // repeated float size = 4;
  inline int size_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline float size(int index) const;
  inline void set_size(int index, float value);
  inline void add_size(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      size() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_size();
  
  // repeated float color = 5;
  inline int color_size() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline float color(int index) const;
  inline void set_color(int index, float value);
  inline void add_color(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      color() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_color();
  
  // @@protoc_insertion_point(class_scope:Serializer.RegionAttachment)
 private:
  
  ::google::protobuf::RepeatedField< float > translate_;
  ::google::protobuf::RepeatedField< float > rotation_;
  ::google::protobuf::RepeatedField< float > scale_;
  ::google::protobuf::RepeatedField< float > size_;
  ::google::protobuf::RepeatedField< float > color_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static RegionAttachment* default_instance_;
};
// -------------------------------------------------------------------

class Attachment : public ::google::protobuf::MessageLite {
 public:
  Attachment();
  virtual ~Attachment();
  
  Attachment(const Attachment& from);
  
  inline Attachment& operator=(const Attachment& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Attachment& default_instance();
  
  void Swap(Attachment* other);
  
  // implements Message ----------------------------------------------
  
  Attachment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Attachment& from);
  void MergeFrom(const Attachment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:Serializer.Attachment)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::std::string* name_;
  ::std::string* data_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static Attachment* default_instance_;
};
// -------------------------------------------------------------------

class SlotAvailableAttachmentsInfo : public ::google::protobuf::MessageLite {
 public:
  SlotAvailableAttachmentsInfo();
  virtual ~SlotAvailableAttachmentsInfo();
  
  SlotAvailableAttachmentsInfo(const SlotAvailableAttachmentsInfo& from);
  
  inline SlotAvailableAttachmentsInfo& operator=(const SlotAvailableAttachmentsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SlotAvailableAttachmentsInfo& default_instance();
  
  void Swap(SlotAvailableAttachmentsInfo* other);
  
  // implements Message ----------------------------------------------
  
  SlotAvailableAttachmentsInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SlotAvailableAttachmentsInfo& from);
  void MergeFrom(const SlotAvailableAttachmentsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .Serializer.Attachment available_attachments = 2;
  inline int available_attachments_size() const;
  inline void clear_available_attachments();
  static const int kAvailableAttachmentsFieldNumber = 2;
  inline const ::Serializer::Attachment& available_attachments(int index) const;
  inline ::Serializer::Attachment* mutable_available_attachments(int index);
  inline ::Serializer::Attachment* add_available_attachments();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Attachment >&
      available_attachments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Attachment >*
      mutable_available_attachments();
  
  // @@protoc_insertion_point(class_scope:Serializer.SlotAvailableAttachmentsInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Attachment > available_attachments_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static SlotAvailableAttachmentsInfo* default_instance_;
};
// -------------------------------------------------------------------

class Skin : public ::google::protobuf::MessageLite {
 public:
  Skin();
  virtual ~Skin();
  
  Skin(const Skin& from);
  
  inline Skin& operator=(const Skin& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Skin& default_instance();
  
  void Swap(Skin* other);
  
  // implements Message ----------------------------------------------
  
  Skin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Skin& from);
  void MergeFrom(const Skin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .Serializer.SlotAvailableAttachmentsInfo slot_available_attachments_info = 2;
  inline int slot_available_attachments_info_size() const;
  inline void clear_slot_available_attachments_info();
  static const int kSlotAvailableAttachmentsInfoFieldNumber = 2;
  inline const ::Serializer::SlotAvailableAttachmentsInfo& slot_available_attachments_info(int index) const;
  inline ::Serializer::SlotAvailableAttachmentsInfo* mutable_slot_available_attachments_info(int index);
  inline ::Serializer::SlotAvailableAttachmentsInfo* add_slot_available_attachments_info();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::SlotAvailableAttachmentsInfo >&
      slot_available_attachments_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::SlotAvailableAttachmentsInfo >*
      mutable_slot_available_attachments_info();
  
  // @@protoc_insertion_point(class_scope:Serializer.Skin)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::SlotAvailableAttachmentsInfo > slot_available_attachments_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static Skin* default_instance_;
};
// -------------------------------------------------------------------

class SpineAvatar : public ::google::protobuf::MessageLite {
 public:
  SpineAvatar();
  virtual ~SpineAvatar();
  
  SpineAvatar(const SpineAvatar& from);
  
  inline SpineAvatar& operator=(const SpineAvatar& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SpineAvatar& default_instance();
  
  void Swap(SpineAvatar* other);
  
  // implements Message ----------------------------------------------
  
  SpineAvatar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpineAvatar& from);
  void MergeFrom(const SpineAvatar& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .Serializer.GameObject setup_pose = 2;
  inline bool has_setup_pose() const;
  inline void clear_setup_pose();
  static const int kSetupPoseFieldNumber = 2;
  inline const ::Serializer::GameObject& setup_pose() const;
  inline ::Serializer::GameObject* mutable_setup_pose();
  inline ::Serializer::GameObject* release_setup_pose();
  
  // repeated .Serializer.Bone bones = 3;
  inline int bones_size() const;
  inline void clear_bones();
  static const int kBonesFieldNumber = 3;
  inline const ::Serializer::Bone& bones(int index) const;
  inline ::Serializer::Bone* mutable_bones(int index);
  inline ::Serializer::Bone* add_bones();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Bone >&
      bones() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Bone >*
      mutable_bones();
  
  // repeated .Serializer.Slot slots = 4;
  inline int slots_size() const;
  inline void clear_slots();
  static const int kSlotsFieldNumber = 4;
  inline const ::Serializer::Slot& slots(int index) const;
  inline ::Serializer::Slot* mutable_slots(int index);
  inline ::Serializer::Slot* add_slots();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Slot >&
      slots() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Slot >*
      mutable_slots();
  
  // repeated .Serializer.Skin skins = 5;
  inline int skins_size() const;
  inline void clear_skins();
  static const int kSkinsFieldNumber = 5;
  inline const ::Serializer::Skin& skins(int index) const;
  inline ::Serializer::Skin* mutable_skins(int index);
  inline ::Serializer::Skin* add_skins();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Skin >&
      skins() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Skin >*
      mutable_skins();
  
  // repeated .Serializer.Animation animations = 6;
  inline int animations_size() const;
  inline void clear_animations();
  static const int kAnimationsFieldNumber = 6;
  inline const ::Serializer::Animation& animations(int index) const;
  inline ::Serializer::Animation* mutable_animations(int index);
  inline ::Serializer::Animation* add_animations();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Animation >&
      animations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Animation >*
      mutable_animations();
  
  // @@protoc_insertion_point(class_scope:Serializer.SpineAvatar)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_setup_pose();
  inline void clear_has_setup_pose();
  
  ::std::string* name_;
  ::Serializer::GameObject* setup_pose_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Bone > bones_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Slot > slots_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Skin > skins_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Animation > animations_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static SpineAvatar* default_instance_;
};
// -------------------------------------------------------------------

class Avatar3D : public ::google::protobuf::MessageLite {
 public:
  Avatar3D();
  virtual ~Avatar3D();
  
  Avatar3D(const Avatar3D& from);
  
  inline Avatar3D& operator=(const Avatar3D& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Avatar3D& default_instance();
  
  void Swap(Avatar3D* other);
  
  // implements Message ----------------------------------------------
  
  Avatar3D* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Avatar3D& from);
  void MergeFrom(const Avatar3D& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .Serializer.Mesh t_pose = 2;
  inline int t_pose_size() const;
  inline void clear_t_pose();
  static const int kTPoseFieldNumber = 2;
  inline const ::Serializer::Mesh& t_pose(int index) const;
  inline ::Serializer::Mesh* mutable_t_pose(int index);
  inline ::Serializer::Mesh* add_t_pose();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Mesh >&
      t_pose() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Mesh >*
      mutable_t_pose();
  
  // repeated .Serializer.Matrix4fB t_pose_invert_matrix = 3;
  inline int t_pose_invert_matrix_size() const;
  inline void clear_t_pose_invert_matrix();
  static const int kTPoseInvertMatrixFieldNumber = 3;
  inline const ::Serializer::Matrix4fB& t_pose_invert_matrix(int index) const;
  inline ::Serializer::Matrix4fB* mutable_t_pose_invert_matrix(int index);
  inline ::Serializer::Matrix4fB* add_t_pose_invert_matrix();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Matrix4fB >&
      t_pose_invert_matrix() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Matrix4fB >*
      mutable_t_pose_invert_matrix();
  
  // @@protoc_insertion_point(class_scope:Serializer.Avatar3D)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Mesh > t_pose_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Matrix4fB > t_pose_invert_matrix_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Avatar_2eproto();
  friend void protobuf_AssignDesc_Avatar_2eproto();
  friend void protobuf_ShutdownFile_Avatar_2eproto();
  
  void InitAsDefaultInstance();
  static Avatar3D* default_instance_;
};
// ===================================================================


// ===================================================================

// Bone

// optional string name = 1;
inline bool Bone::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bone::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bone::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bone::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Bone::name() const {
  return *name_;
}
inline void Bone::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Bone::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Bone::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bone::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Bone::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated float translate = 2;
inline int Bone::translate_size() const {
  return translate_.size();
}
inline void Bone::clear_translate() {
  translate_.Clear();
}
inline float Bone::translate(int index) const {
  return translate_.Get(index);
}
inline void Bone::set_translate(int index, float value) {
  translate_.Set(index, value);
}
inline void Bone::add_translate(float value) {
  translate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Bone::translate() const {
  return translate_;
}
inline ::google::protobuf::RepeatedField< float >*
Bone::mutable_translate() {
  return &translate_;
}

// repeated float rotation = 3;
inline int Bone::rotation_size() const {
  return rotation_.size();
}
inline void Bone::clear_rotation() {
  rotation_.Clear();
}
inline float Bone::rotation(int index) const {
  return rotation_.Get(index);
}
inline void Bone::set_rotation(int index, float value) {
  rotation_.Set(index, value);
}
inline void Bone::add_rotation(float value) {
  rotation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Bone::rotation() const {
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
Bone::mutable_rotation() {
  return &rotation_;
}

// repeated float scale = 4;
inline int Bone::scale_size() const {
  return scale_.size();
}
inline void Bone::clear_scale() {
  scale_.Clear();
}
inline float Bone::scale(int index) const {
  return scale_.Get(index);
}
inline void Bone::set_scale(int index, float value) {
  scale_.Set(index, value);
}
inline void Bone::add_scale(float value) {
  scale_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Bone::scale() const {
  return scale_;
}
inline ::google::protobuf::RepeatedField< float >*
Bone::mutable_scale() {
  return &scale_;
}

// repeated float shear = 5;
inline int Bone::shear_size() const {
  return shear_.size();
}
inline void Bone::clear_shear() {
  shear_.Clear();
}
inline float Bone::shear(int index) const {
  return shear_.Get(index);
}
inline void Bone::set_shear(int index, float value) {
  shear_.Set(index, value);
}
inline void Bone::add_shear(float value) {
  shear_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Bone::shear() const {
  return shear_;
}
inline ::google::protobuf::RepeatedField< float >*
Bone::mutable_shear() {
  return &shear_;
}

// -------------------------------------------------------------------

// Slot

// optional string name = 1;
inline bool Slot::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Slot::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Slot::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Slot::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Slot::name() const {
  return *name_;
}
inline void Slot::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Slot::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Slot::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Slot::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Slot::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated float color = 2;
inline int Slot::color_size() const {
  return color_.size();
}
inline void Slot::clear_color() {
  color_.Clear();
}
inline float Slot::color(int index) const {
  return color_.Get(index);
}
inline void Slot::set_color(int index, float value) {
  color_.Set(index, value);
}
inline void Slot::add_color(float value) {
  color_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Slot::color() const {
  return color_;
}
inline ::google::protobuf::RepeatedField< float >*
Slot::mutable_color() {
  return &color_;
}

// repeated float dark = 3;
inline int Slot::dark_size() const {
  return dark_.size();
}
inline void Slot::clear_dark() {
  dark_.Clear();
}
inline float Slot::dark(int index) const {
  return dark_.Get(index);
}
inline void Slot::set_dark(int index, float value) {
  dark_.Set(index, value);
}
inline void Slot::add_dark(float value) {
  dark_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Slot::dark() const {
  return dark_;
}
inline ::google::protobuf::RepeatedField< float >*
Slot::mutable_dark() {
  return &dark_;
}

// optional string attachment = 4;
inline bool Slot::has_attachment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Slot::set_has_attachment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Slot::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Slot::clear_attachment() {
  if (attachment_ != &::google::protobuf::internal::kEmptyString) {
    attachment_->clear();
  }
  clear_has_attachment();
}
inline const ::std::string& Slot::attachment() const {
  return *attachment_;
}
inline void Slot::set_attachment(const ::std::string& value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Slot::set_attachment(const char* value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Slot::set_attachment(const char* value, size_t size) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Slot::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  return attachment_;
}
inline ::std::string* Slot::release_attachment() {
  clear_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attachment_;
    attachment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 blend_func_src = 5;
inline bool Slot::has_blend_func_src() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Slot::set_has_blend_func_src() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Slot::clear_has_blend_func_src() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Slot::clear_blend_func_src() {
  blend_func_src_ = 0;
  clear_has_blend_func_src();
}
inline ::google::protobuf::int32 Slot::blend_func_src() const {
  return blend_func_src_;
}
inline void Slot::set_blend_func_src(::google::protobuf::int32 value) {
  set_has_blend_func_src();
  blend_func_src_ = value;
}

// optional int32 blend_func_dst = 6;
inline bool Slot::has_blend_func_dst() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Slot::set_has_blend_func_dst() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Slot::clear_has_blend_func_dst() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Slot::clear_blend_func_dst() {
  blend_func_dst_ = 0;
  clear_has_blend_func_dst();
}
inline ::google::protobuf::int32 Slot::blend_func_dst() const {
  return blend_func_dst_;
}
inline void Slot::set_blend_func_dst(::google::protobuf::int32 value) {
  set_has_blend_func_dst();
  blend_func_dst_ = value;
}

// -------------------------------------------------------------------

// RegionAttachment

// repeated float translate = 1;
inline int RegionAttachment::translate_size() const {
  return translate_.size();
}
inline void RegionAttachment::clear_translate() {
  translate_.Clear();
}
inline float RegionAttachment::translate(int index) const {
  return translate_.Get(index);
}
inline void RegionAttachment::set_translate(int index, float value) {
  translate_.Set(index, value);
}
inline void RegionAttachment::add_translate(float value) {
  translate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RegionAttachment::translate() const {
  return translate_;
}
inline ::google::protobuf::RepeatedField< float >*
RegionAttachment::mutable_translate() {
  return &translate_;
}

// repeated float rotation = 2;
inline int RegionAttachment::rotation_size() const {
  return rotation_.size();
}
inline void RegionAttachment::clear_rotation() {
  rotation_.Clear();
}
inline float RegionAttachment::rotation(int index) const {
  return rotation_.Get(index);
}
inline void RegionAttachment::set_rotation(int index, float value) {
  rotation_.Set(index, value);
}
inline void RegionAttachment::add_rotation(float value) {
  rotation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RegionAttachment::rotation() const {
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
RegionAttachment::mutable_rotation() {
  return &rotation_;
}

// repeated float scale = 3;
inline int RegionAttachment::scale_size() const {
  return scale_.size();
}
inline void RegionAttachment::clear_scale() {
  scale_.Clear();
}
inline float RegionAttachment::scale(int index) const {
  return scale_.Get(index);
}
inline void RegionAttachment::set_scale(int index, float value) {
  scale_.Set(index, value);
}
inline void RegionAttachment::add_scale(float value) {
  scale_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RegionAttachment::scale() const {
  return scale_;
}
inline ::google::protobuf::RepeatedField< float >*
RegionAttachment::mutable_scale() {
  return &scale_;
}

// repeated float size = 4;
inline int RegionAttachment::size_size() const {
  return size_.size();
}
inline void RegionAttachment::clear_size() {
  size_.Clear();
}
inline float RegionAttachment::size(int index) const {
  return size_.Get(index);
}
inline void RegionAttachment::set_size(int index, float value) {
  size_.Set(index, value);
}
inline void RegionAttachment::add_size(float value) {
  size_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RegionAttachment::size() const {
  return size_;
}
inline ::google::protobuf::RepeatedField< float >*
RegionAttachment::mutable_size() {
  return &size_;
}

// repeated float color = 5;
inline int RegionAttachment::color_size() const {
  return color_.size();
}
inline void RegionAttachment::clear_color() {
  color_.Clear();
}
inline float RegionAttachment::color(int index) const {
  return color_.Get(index);
}
inline void RegionAttachment::set_color(int index, float value) {
  color_.Set(index, value);
}
inline void RegionAttachment::add_color(float value) {
  color_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RegionAttachment::color() const {
  return color_;
}
inline ::google::protobuf::RepeatedField< float >*
RegionAttachment::mutable_color() {
  return &color_;
}

// -------------------------------------------------------------------

// Attachment

// optional int32 type = 1;
inline bool Attachment::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attachment::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attachment::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attachment::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Attachment::type() const {
  return type_;
}
inline void Attachment::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string name = 2;
inline bool Attachment::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attachment::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attachment::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attachment::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Attachment::name() const {
  return *name_;
}
inline void Attachment::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attachment::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attachment::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attachment::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Attachment::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes data = 3;
inline bool Attachment::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attachment::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attachment::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attachment::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Attachment::data() const {
  return *data_;
}
inline void Attachment::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Attachment::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Attachment::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attachment::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Attachment::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SlotAvailableAttachmentsInfo

// optional string name = 1;
inline bool SlotAvailableAttachmentsInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlotAvailableAttachmentsInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlotAvailableAttachmentsInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlotAvailableAttachmentsInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SlotAvailableAttachmentsInfo::name() const {
  return *name_;
}
inline void SlotAvailableAttachmentsInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SlotAvailableAttachmentsInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SlotAvailableAttachmentsInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlotAvailableAttachmentsInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SlotAvailableAttachmentsInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Serializer.Attachment available_attachments = 2;
inline int SlotAvailableAttachmentsInfo::available_attachments_size() const {
  return available_attachments_.size();
}
inline void SlotAvailableAttachmentsInfo::clear_available_attachments() {
  available_attachments_.Clear();
}
inline const ::Serializer::Attachment& SlotAvailableAttachmentsInfo::available_attachments(int index) const {
  return available_attachments_.Get(index);
}
inline ::Serializer::Attachment* SlotAvailableAttachmentsInfo::mutable_available_attachments(int index) {
  return available_attachments_.Mutable(index);
}
inline ::Serializer::Attachment* SlotAvailableAttachmentsInfo::add_available_attachments() {
  return available_attachments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Attachment >&
SlotAvailableAttachmentsInfo::available_attachments() const {
  return available_attachments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Attachment >*
SlotAvailableAttachmentsInfo::mutable_available_attachments() {
  return &available_attachments_;
}

// -------------------------------------------------------------------

// Skin

// optional string name = 1;
inline bool Skin::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Skin::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Skin::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Skin::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Skin::name() const {
  return *name_;
}
inline void Skin::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Skin::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Skin::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skin::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Skin::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Serializer.SlotAvailableAttachmentsInfo slot_available_attachments_info = 2;
inline int Skin::slot_available_attachments_info_size() const {
  return slot_available_attachments_info_.size();
}
inline void Skin::clear_slot_available_attachments_info() {
  slot_available_attachments_info_.Clear();
}
inline const ::Serializer::SlotAvailableAttachmentsInfo& Skin::slot_available_attachments_info(int index) const {
  return slot_available_attachments_info_.Get(index);
}
inline ::Serializer::SlotAvailableAttachmentsInfo* Skin::mutable_slot_available_attachments_info(int index) {
  return slot_available_attachments_info_.Mutable(index);
}
inline ::Serializer::SlotAvailableAttachmentsInfo* Skin::add_slot_available_attachments_info() {
  return slot_available_attachments_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::SlotAvailableAttachmentsInfo >&
Skin::slot_available_attachments_info() const {
  return slot_available_attachments_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::SlotAvailableAttachmentsInfo >*
Skin::mutable_slot_available_attachments_info() {
  return &slot_available_attachments_info_;
}

// -------------------------------------------------------------------

// SpineAvatar

// optional string name = 1;
inline bool SpineAvatar::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpineAvatar::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpineAvatar::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpineAvatar::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SpineAvatar::name() const {
  return *name_;
}
inline void SpineAvatar::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SpineAvatar::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SpineAvatar::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpineAvatar::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SpineAvatar::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Serializer.GameObject setup_pose = 2;
inline bool SpineAvatar::has_setup_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpineAvatar::set_has_setup_pose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpineAvatar::clear_has_setup_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpineAvatar::clear_setup_pose() {
  if (setup_pose_ != NULL) setup_pose_->::Serializer::GameObject::Clear();
  clear_has_setup_pose();
}
inline const ::Serializer::GameObject& SpineAvatar::setup_pose() const {
  return setup_pose_ != NULL ? *setup_pose_ : *default_instance_->setup_pose_;
}
inline ::Serializer::GameObject* SpineAvatar::mutable_setup_pose() {
  set_has_setup_pose();
  if (setup_pose_ == NULL) setup_pose_ = new ::Serializer::GameObject;
  return setup_pose_;
}
inline ::Serializer::GameObject* SpineAvatar::release_setup_pose() {
  clear_has_setup_pose();
  ::Serializer::GameObject* temp = setup_pose_;
  setup_pose_ = NULL;
  return temp;
}

// repeated .Serializer.Bone bones = 3;
inline int SpineAvatar::bones_size() const {
  return bones_.size();
}
inline void SpineAvatar::clear_bones() {
  bones_.Clear();
}
inline const ::Serializer::Bone& SpineAvatar::bones(int index) const {
  return bones_.Get(index);
}
inline ::Serializer::Bone* SpineAvatar::mutable_bones(int index) {
  return bones_.Mutable(index);
}
inline ::Serializer::Bone* SpineAvatar::add_bones() {
  return bones_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Bone >&
SpineAvatar::bones() const {
  return bones_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Bone >*
SpineAvatar::mutable_bones() {
  return &bones_;
}

// repeated .Serializer.Slot slots = 4;
inline int SpineAvatar::slots_size() const {
  return slots_.size();
}
inline void SpineAvatar::clear_slots() {
  slots_.Clear();
}
inline const ::Serializer::Slot& SpineAvatar::slots(int index) const {
  return slots_.Get(index);
}
inline ::Serializer::Slot* SpineAvatar::mutable_slots(int index) {
  return slots_.Mutable(index);
}
inline ::Serializer::Slot* SpineAvatar::add_slots() {
  return slots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Slot >&
SpineAvatar::slots() const {
  return slots_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Slot >*
SpineAvatar::mutable_slots() {
  return &slots_;
}

// repeated .Serializer.Skin skins = 5;
inline int SpineAvatar::skins_size() const {
  return skins_.size();
}
inline void SpineAvatar::clear_skins() {
  skins_.Clear();
}
inline const ::Serializer::Skin& SpineAvatar::skins(int index) const {
  return skins_.Get(index);
}
inline ::Serializer::Skin* SpineAvatar::mutable_skins(int index) {
  return skins_.Mutable(index);
}
inline ::Serializer::Skin* SpineAvatar::add_skins() {
  return skins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Skin >&
SpineAvatar::skins() const {
  return skins_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Skin >*
SpineAvatar::mutable_skins() {
  return &skins_;
}

// repeated .Serializer.Animation animations = 6;
inline int SpineAvatar::animations_size() const {
  return animations_.size();
}
inline void SpineAvatar::clear_animations() {
  animations_.Clear();
}
inline const ::Serializer::Animation& SpineAvatar::animations(int index) const {
  return animations_.Get(index);
}
inline ::Serializer::Animation* SpineAvatar::mutable_animations(int index) {
  return animations_.Mutable(index);
}
inline ::Serializer::Animation* SpineAvatar::add_animations() {
  return animations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Animation >&
SpineAvatar::animations() const {
  return animations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Animation >*
SpineAvatar::mutable_animations() {
  return &animations_;
}

// -------------------------------------------------------------------

// Avatar3D

// optional string name = 1;
inline bool Avatar3D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Avatar3D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Avatar3D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Avatar3D::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Avatar3D::name() const {
  return *name_;
}
inline void Avatar3D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Avatar3D::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Avatar3D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Avatar3D::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Avatar3D::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Serializer.Mesh t_pose = 2;
inline int Avatar3D::t_pose_size() const {
  return t_pose_.size();
}
inline void Avatar3D::clear_t_pose() {
  t_pose_.Clear();
}
inline const ::Serializer::Mesh& Avatar3D::t_pose(int index) const {
  return t_pose_.Get(index);
}
inline ::Serializer::Mesh* Avatar3D::mutable_t_pose(int index) {
  return t_pose_.Mutable(index);
}
inline ::Serializer::Mesh* Avatar3D::add_t_pose() {
  return t_pose_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Mesh >&
Avatar3D::t_pose() const {
  return t_pose_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Mesh >*
Avatar3D::mutable_t_pose() {
  return &t_pose_;
}

// repeated .Serializer.Matrix4fB t_pose_invert_matrix = 3;
inline int Avatar3D::t_pose_invert_matrix_size() const {
  return t_pose_invert_matrix_.size();
}
inline void Avatar3D::clear_t_pose_invert_matrix() {
  t_pose_invert_matrix_.Clear();
}
inline const ::Serializer::Matrix4fB& Avatar3D::t_pose_invert_matrix(int index) const {
  return t_pose_invert_matrix_.Get(index);
}
inline ::Serializer::Matrix4fB* Avatar3D::mutable_t_pose_invert_matrix(int index) {
  return t_pose_invert_matrix_.Mutable(index);
}
inline ::Serializer::Matrix4fB* Avatar3D::add_t_pose_invert_matrix() {
  return t_pose_invert_matrix_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Matrix4fB >&
Avatar3D::t_pose_invert_matrix() const {
  return t_pose_invert_matrix_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Matrix4fB >*
Avatar3D::mutable_t_pose_invert_matrix() {
  return &t_pose_invert_matrix_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Avatar_2eproto__INCLUDED
