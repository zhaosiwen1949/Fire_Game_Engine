// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Label.proto

#ifndef PROTOBUF_Label_2eproto__INCLUDED
#define PROTOBUF_Label_2eproto__INCLUDED

#include <string>

#include "common.h"

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "generated_message_util.h"
#include "repeated_field.h"
#include "extension_set.h"
#include "Color.serializer.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Label_2eproto();
void protobuf_AssignDesc_Label_2eproto();
void protobuf_ShutdownFile_Label_2eproto();

class Label;

// ===================================================================

class Label : public ::google::protobuf::MessageLite {
 public:
  Label();
  virtual ~Label();
  
  Label(const Label& from);
  
  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Label& default_instance();
  
  void Swap(Label* other);
  
  // implements Message ----------------------------------------------
  
  Label* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 text = 1;
  inline int text_size() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline ::google::protobuf::int32 text(int index) const;
  inline void set_text(int index, ::google::protobuf::int32 value);
  inline void add_text(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      text() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_text();
  
  // optional string font = 2;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 2;
  inline const ::std::string& font() const;
  inline void set_font(const ::std::string& value);
  inline void set_font(const char* value);
  inline void set_font(const char* value, size_t size);
  inline ::std::string* mutable_font();
  inline ::std::string* release_font();
  
  // optional int32 charsize = 3;
  inline bool has_charsize() const;
  inline void clear_charsize();
  static const int kCharsizeFieldNumber = 3;
  inline ::google::protobuf::int32 charsize() const;
  inline void set_charsize(::google::protobuf::int32 value);
  
  // optional int32 style = 4;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 4;
  inline ::google::protobuf::int32 style() const;
  inline void set_style(::google::protobuf::int32 value);
  
  // optional int32 outlineSize = 5;
  inline bool has_outlinesize() const;
  inline void clear_outlinesize();
  static const int kOutlineSizeFieldNumber = 5;
  inline ::google::protobuf::int32 outlinesize() const;
  inline void set_outlinesize(::google::protobuf::int32 value);
  
  // optional .Serializer.Color4B outlinecolor = 6;
  inline bool has_outlinecolor() const;
  inline void clear_outlinecolor();
  static const int kOutlinecolorFieldNumber = 6;
  inline const ::Serializer::Color4B& outlinecolor() const;
  inline ::Serializer::Color4B* mutable_outlinecolor();
  inline ::Serializer::Color4B* release_outlinecolor();
  
  // optional int32 shadowx = 7;
  inline bool has_shadowx() const;
  inline void clear_shadowx();
  static const int kShadowxFieldNumber = 7;
  inline ::google::protobuf::int32 shadowx() const;
  inline void set_shadowx(::google::protobuf::int32 value);
  
  // optional int32 shadowy = 8;
  inline bool has_shadowy() const;
  inline void clear_shadowy();
  static const int kShadowyFieldNumber = 8;
  inline ::google::protobuf::int32 shadowy() const;
  inline void set_shadowy(::google::protobuf::int32 value);
  
  // optional int32 aligning = 9;
  inline bool has_aligning() const;
  inline void clear_aligning();
  static const int kAligningFieldNumber = 9;
  inline ::google::protobuf::int32 aligning() const;
  inline void set_aligning(::google::protobuf::int32 value);
  
  // optional .Serializer.Color4B textColor = 10;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 10;
  inline const ::Serializer::Color4B& textcolor() const;
  inline ::Serializer::Color4B* mutable_textcolor();
  inline ::Serializer::Color4B* release_textcolor();
  
  // optional .Serializer.Color4B shadowColor = 11;
  inline bool has_shadowcolor() const;
  inline void clear_shadowcolor();
  static const int kShadowColorFieldNumber = 11;
  inline const ::Serializer::Color4B& shadowcolor() const;
  inline ::Serializer::Color4B* mutable_shadowcolor();
  inline ::Serializer::Color4B* release_shadowcolor();
  
  // @@protoc_insertion_point(class_scope:Serializer.Label)
 private:
  inline void set_has_font();
  inline void clear_has_font();
  inline void set_has_charsize();
  inline void clear_has_charsize();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_outlinesize();
  inline void clear_has_outlinesize();
  inline void set_has_outlinecolor();
  inline void clear_has_outlinecolor();
  inline void set_has_shadowx();
  inline void clear_has_shadowx();
  inline void set_has_shadowy();
  inline void clear_has_shadowy();
  inline void set_has_aligning();
  inline void clear_has_aligning();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_shadowcolor();
  inline void clear_has_shadowcolor();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > text_;
  ::std::string* font_;
  ::google::protobuf::int32 charsize_;
  ::google::protobuf::int32 style_;
  ::Serializer::Color4B* outlinecolor_;
  ::google::protobuf::int32 outlinesize_;
  ::google::protobuf::int32 shadowx_;
  ::google::protobuf::int32 shadowy_;
  ::google::protobuf::int32 aligning_;
  ::Serializer::Color4B* textcolor_;
  ::Serializer::Color4B* shadowcolor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Label_2eproto();
  friend void protobuf_AssignDesc_Label_2eproto();
  friend void protobuf_ShutdownFile_Label_2eproto();
  
  void InitAsDefaultInstance();
  static Label* default_instance_;
};
// ===================================================================


// ===================================================================

// Label

// repeated int32 text = 1;
inline int Label::text_size() const {
  return text_.size();
}
inline void Label::clear_text() {
  text_.Clear();
}
inline ::google::protobuf::int32 Label::text(int index) const {
  return text_.Get(index);
}
inline void Label::set_text(int index, ::google::protobuf::int32 value) {
  text_.Set(index, value);
}
inline void Label::add_text(::google::protobuf::int32 value) {
  text_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Label::text() const {
  return text_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Label::mutable_text() {
  return &text_;
}

// optional string font = 2;
inline bool Label::has_font() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_font() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_font() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_font() {
  if (font_ != &::google::protobuf::internal::kEmptyString) {
    font_->clear();
  }
  clear_has_font();
}
inline const ::std::string& Label::font() const {
  return *font_;
}
inline void Label::set_font(const ::std::string& value) {
  set_has_font();
  if (font_ == &::google::protobuf::internal::kEmptyString) {
    font_ = new ::std::string;
  }
  font_->assign(value);
}
inline void Label::set_font(const char* value) {
  set_has_font();
  if (font_ == &::google::protobuf::internal::kEmptyString) {
    font_ = new ::std::string;
  }
  font_->assign(value);
}
inline void Label::set_font(const char* value, size_t size) {
  set_has_font();
  if (font_ == &::google::protobuf::internal::kEmptyString) {
    font_ = new ::std::string;
  }
  font_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_font() {
  set_has_font();
  if (font_ == &::google::protobuf::internal::kEmptyString) {
    font_ = new ::std::string;
  }
  return font_;
}
inline ::std::string* Label::release_font() {
  clear_has_font();
  if (font_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = font_;
    font_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 charsize = 3;
inline bool Label::has_charsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Label::set_has_charsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Label::clear_has_charsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Label::clear_charsize() {
  charsize_ = 0;
  clear_has_charsize();
}
inline ::google::protobuf::int32 Label::charsize() const {
  return charsize_;
}
inline void Label::set_charsize(::google::protobuf::int32 value) {
  set_has_charsize();
  charsize_ = value;
}

// optional int32 style = 4;
inline bool Label::has_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Label::set_has_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Label::clear_has_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Label::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Label::style() const {
  return style_;
}
inline void Label::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional int32 outlineSize = 5;
inline bool Label::has_outlinesize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Label::set_has_outlinesize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Label::clear_has_outlinesize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Label::clear_outlinesize() {
  outlinesize_ = 0;
  clear_has_outlinesize();
}
inline ::google::protobuf::int32 Label::outlinesize() const {
  return outlinesize_;
}
inline void Label::set_outlinesize(::google::protobuf::int32 value) {
  set_has_outlinesize();
  outlinesize_ = value;
}

// optional .Serializer.Color4B outlinecolor = 6;
inline bool Label::has_outlinecolor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Label::set_has_outlinecolor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Label::clear_has_outlinecolor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Label::clear_outlinecolor() {
  if (outlinecolor_ != NULL) outlinecolor_->::Serializer::Color4B::Clear();
  clear_has_outlinecolor();
}
inline const ::Serializer::Color4B& Label::outlinecolor() const {
  return outlinecolor_ != NULL ? *outlinecolor_ : *default_instance_->outlinecolor_;
}
inline ::Serializer::Color4B* Label::mutable_outlinecolor() {
  set_has_outlinecolor();
  if (outlinecolor_ == NULL) outlinecolor_ = new ::Serializer::Color4B;
  return outlinecolor_;
}
inline ::Serializer::Color4B* Label::release_outlinecolor() {
  clear_has_outlinecolor();
  ::Serializer::Color4B* temp = outlinecolor_;
  outlinecolor_ = NULL;
  return temp;
}

// optional int32 shadowx = 7;
inline bool Label::has_shadowx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Label::set_has_shadowx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Label::clear_has_shadowx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Label::clear_shadowx() {
  shadowx_ = 0;
  clear_has_shadowx();
}
inline ::google::protobuf::int32 Label::shadowx() const {
  return shadowx_;
}
inline void Label::set_shadowx(::google::protobuf::int32 value) {
  set_has_shadowx();
  shadowx_ = value;
}

// optional int32 shadowy = 8;
inline bool Label::has_shadowy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Label::set_has_shadowy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Label::clear_has_shadowy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Label::clear_shadowy() {
  shadowy_ = 0;
  clear_has_shadowy();
}
inline ::google::protobuf::int32 Label::shadowy() const {
  return shadowy_;
}
inline void Label::set_shadowy(::google::protobuf::int32 value) {
  set_has_shadowy();
  shadowy_ = value;
}

// optional int32 aligning = 9;
inline bool Label::has_aligning() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Label::set_has_aligning() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Label::clear_has_aligning() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Label::clear_aligning() {
  aligning_ = 0;
  clear_has_aligning();
}
inline ::google::protobuf::int32 Label::aligning() const {
  return aligning_;
}
inline void Label::set_aligning(::google::protobuf::int32 value) {
  set_has_aligning();
  aligning_ = value;
}

// optional .Serializer.Color4B textColor = 10;
inline bool Label::has_textcolor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Label::set_has_textcolor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Label::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Label::clear_textcolor() {
  if (textcolor_ != NULL) textcolor_->::Serializer::Color4B::Clear();
  clear_has_textcolor();
}
inline const ::Serializer::Color4B& Label::textcolor() const {
  return textcolor_ != NULL ? *textcolor_ : *default_instance_->textcolor_;
}
inline ::Serializer::Color4B* Label::mutable_textcolor() {
  set_has_textcolor();
  if (textcolor_ == NULL) textcolor_ = new ::Serializer::Color4B;
  return textcolor_;
}
inline ::Serializer::Color4B* Label::release_textcolor() {
  clear_has_textcolor();
  ::Serializer::Color4B* temp = textcolor_;
  textcolor_ = NULL;
  return temp;
}

// optional .Serializer.Color4B shadowColor = 11;
inline bool Label::has_shadowcolor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Label::set_has_shadowcolor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Label::clear_has_shadowcolor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Label::clear_shadowcolor() {
  if (shadowcolor_ != NULL) shadowcolor_->::Serializer::Color4B::Clear();
  clear_has_shadowcolor();
}
inline const ::Serializer::Color4B& Label::shadowcolor() const {
  return shadowcolor_ != NULL ? *shadowcolor_ : *default_instance_->shadowcolor_;
}
inline ::Serializer::Color4B* Label::mutable_shadowcolor() {
  set_has_shadowcolor();
  if (shadowcolor_ == NULL) shadowcolor_ = new ::Serializer::Color4B;
  return shadowcolor_;
}
inline ::Serializer::Color4B* Label::release_shadowcolor() {
  clear_has_shadowcolor();
  ::Serializer::Color4B* temp = shadowcolor_;
  shadowcolor_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Label_2eproto__INCLUDED
