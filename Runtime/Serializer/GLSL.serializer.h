// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GLSL.proto

#ifndef PROTOBUF_GLSL_2eproto__INCLUDED
#define PROTOBUF_GLSL_2eproto__INCLUDED

#include <string>

#include "common.h"

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "generated_message_util.h"
#include "repeated_field.h"
#include "extension_set.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GLSL_2eproto();
void protobuf_AssignDesc_GLSL_2eproto();
void protobuf_ShutdownFile_GLSL_2eproto();

class UniformDefine;
class AttributeDefine;
class GLSL;

// ===================================================================

class UniformDefine : public ::google::protobuf::MessageLite {
 public:
  UniformDefine();
  virtual ~UniformDefine();
  
  UniformDefine(const UniformDefine& from);
  
  inline UniformDefine& operator=(const UniformDefine& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UniformDefine& default_instance();
  
  void Swap(UniformDefine* other);
  
  // implements Message ----------------------------------------------
  
  UniformDefine* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UniformDefine& from);
  void MergeFrom(const UniformDefine& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Serializer.UniformDefine)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::std::string* name_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_GLSL_2eproto();
  friend void protobuf_AssignDesc_GLSL_2eproto();
  friend void protobuf_ShutdownFile_GLSL_2eproto();
  
  void InitAsDefaultInstance();
  static UniformDefine* default_instance_;
};
// -------------------------------------------------------------------

class AttributeDefine : public ::google::protobuf::MessageLite {
 public:
  AttributeDefine();
  virtual ~AttributeDefine();
  
  AttributeDefine(const AttributeDefine& from);
  
  inline AttributeDefine& operator=(const AttributeDefine& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AttributeDefine& default_instance();
  
  void Swap(AttributeDefine* other);
  
  // implements Message ----------------------------------------------
  
  AttributeDefine* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttributeDefine& from);
  void MergeFrom(const AttributeDefine& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 stride = 2;
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 2;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);
  
  // optional int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // optional int32 data_type = 4;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 4;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
  // optional int32 normalized = 5;
  inline bool has_normalized() const;
  inline void clear_normalized();
  static const int kNormalizedFieldNumber = 5;
  inline ::google::protobuf::int32 normalized() const;
  inline void set_normalized(::google::protobuf::int32 value);
  
  // optional int32 component_count = 6;
  inline bool has_component_count() const;
  inline void clear_component_count();
  static const int kComponentCountFieldNumber = 6;
  inline ::google::protobuf::int32 component_count() const;
  inline void set_component_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Serializer.AttributeDefine)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_normalized();
  inline void clear_has_normalized();
  inline void set_has_component_count();
  inline void clear_has_component_count();
  
  ::std::string* name_;
  ::google::protobuf::int32 stride_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 data_type_;
  ::google::protobuf::int32 normalized_;
  ::google::protobuf::int32 component_count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_GLSL_2eproto();
  friend void protobuf_AssignDesc_GLSL_2eproto();
  friend void protobuf_ShutdownFile_GLSL_2eproto();
  
  void InitAsDefaultInstance();
  static AttributeDefine* default_instance_;
};
// -------------------------------------------------------------------

class GLSL : public ::google::protobuf::MessageLite {
 public:
  GLSL();
  virtual ~GLSL();
  
  GLSL(const GLSL& from);
  
  inline GLSL& operator=(const GLSL& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLSL& default_instance();
  
  void Swap(GLSL* other);
  
  // implements Message ----------------------------------------------
  
  GLSL* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLSL& from);
  void MergeFrom(const GLSL& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string guid = 2;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 2;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  
  // optional bytes vert_code = 3;
  inline bool has_vert_code() const;
  inline void clear_vert_code();
  static const int kVertCodeFieldNumber = 3;
  inline const ::std::string& vert_code() const;
  inline void set_vert_code(const ::std::string& value);
  inline void set_vert_code(const char* value);
  inline void set_vert_code(const void* value, size_t size);
  inline ::std::string* mutable_vert_code();
  inline ::std::string* release_vert_code();
  
  // optional bytes frag_code = 4;
  inline bool has_frag_code() const;
  inline void clear_frag_code();
  static const int kFragCodeFieldNumber = 4;
  inline const ::std::string& frag_code() const;
  inline void set_frag_code(const ::std::string& value);
  inline void set_frag_code(const char* value);
  inline void set_frag_code(const void* value, size_t size);
  inline ::std::string* mutable_frag_code();
  inline ::std::string* release_frag_code();
  
  // repeated .Serializer.AttributeDefine attributes = 5;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::Serializer::AttributeDefine& attributes(int index) const;
  inline ::Serializer::AttributeDefine* mutable_attributes(int index);
  inline ::Serializer::AttributeDefine* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::AttributeDefine >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::AttributeDefine >*
      mutable_attributes();
  
  // repeated .Serializer.UniformDefine uniforms = 6;
  inline int uniforms_size() const;
  inline void clear_uniforms();
  static const int kUniformsFieldNumber = 6;
  inline const ::Serializer::UniformDefine& uniforms(int index) const;
  inline ::Serializer::UniformDefine* mutable_uniforms(int index);
  inline ::Serializer::UniformDefine* add_uniforms();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::UniformDefine >&
      uniforms() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::UniformDefine >*
      mutable_uniforms();
  
  // optional fixed64 lwtVS = 7;
  inline bool has_lwtvs() const;
  inline void clear_lwtvs();
  static const int kLwtVSFieldNumber = 7;
  inline ::google::protobuf::uint64 lwtvs() const;
  inline void set_lwtvs(::google::protobuf::uint64 value);
  
  // optional fixed64 lwtFS = 8;
  inline bool has_lwtfs() const;
  inline void clear_lwtfs();
  static const int kLwtFSFieldNumber = 8;
  inline ::google::protobuf::uint64 lwtfs() const;
  inline void set_lwtfs(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:Serializer.GLSL)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_vert_code();
  inline void clear_has_vert_code();
  inline void set_has_frag_code();
  inline void clear_has_frag_code();
  inline void set_has_lwtvs();
  inline void clear_has_lwtvs();
  inline void set_has_lwtfs();
  inline void clear_has_lwtfs();
  
  ::std::string* name_;
  ::std::string* guid_;
  ::std::string* vert_code_;
  ::std::string* frag_code_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::AttributeDefine > attributes_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::UniformDefine > uniforms_;
  ::google::protobuf::uint64 lwtvs_;
  ::google::protobuf::uint64 lwtfs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_GLSL_2eproto();
  friend void protobuf_AssignDesc_GLSL_2eproto();
  friend void protobuf_ShutdownFile_GLSL_2eproto();
  
  void InitAsDefaultInstance();
  static GLSL* default_instance_;
};
// ===================================================================


// ===================================================================

// UniformDefine

// optional string name = 1;
inline bool UniformDefine::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniformDefine::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniformDefine::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniformDefine::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UniformDefine::name() const {
  return *name_;
}
inline void UniformDefine::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UniformDefine::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UniformDefine::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniformDefine::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UniformDefine::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 type = 2;
inline bool UniformDefine::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniformDefine::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniformDefine::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniformDefine::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UniformDefine::type() const {
  return type_;
}
inline void UniformDefine::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AttributeDefine

// optional string name = 1;
inline bool AttributeDefine::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttributeDefine::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttributeDefine::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttributeDefine::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AttributeDefine::name() const {
  return *name_;
}
inline void AttributeDefine::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AttributeDefine::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AttributeDefine::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AttributeDefine::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AttributeDefine::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 stride = 2;
inline bool AttributeDefine::has_stride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttributeDefine::set_has_stride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttributeDefine::clear_has_stride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttributeDefine::clear_stride() {
  stride_ = 0;
  clear_has_stride();
}
inline ::google::protobuf::int32 AttributeDefine::stride() const {
  return stride_;
}
inline void AttributeDefine::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// optional int32 offset = 3;
inline bool AttributeDefine::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AttributeDefine::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AttributeDefine::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AttributeDefine::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AttributeDefine::offset() const {
  return offset_;
}
inline void AttributeDefine::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional int32 data_type = 4;
inline bool AttributeDefine::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AttributeDefine::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AttributeDefine::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AttributeDefine::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::google::protobuf::int32 AttributeDefine::data_type() const {
  return data_type_;
}
inline void AttributeDefine::set_data_type(::google::protobuf::int32 value) {
  set_has_data_type();
  data_type_ = value;
}

// optional int32 normalized = 5;
inline bool AttributeDefine::has_normalized() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AttributeDefine::set_has_normalized() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AttributeDefine::clear_has_normalized() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AttributeDefine::clear_normalized() {
  normalized_ = 0;
  clear_has_normalized();
}
inline ::google::protobuf::int32 AttributeDefine::normalized() const {
  return normalized_;
}
inline void AttributeDefine::set_normalized(::google::protobuf::int32 value) {
  set_has_normalized();
  normalized_ = value;
}

// optional int32 component_count = 6;
inline bool AttributeDefine::has_component_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AttributeDefine::set_has_component_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AttributeDefine::clear_has_component_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AttributeDefine::clear_component_count() {
  component_count_ = 0;
  clear_has_component_count();
}
inline ::google::protobuf::int32 AttributeDefine::component_count() const {
  return component_count_;
}
inline void AttributeDefine::set_component_count(::google::protobuf::int32 value) {
  set_has_component_count();
  component_count_ = value;
}

// -------------------------------------------------------------------

// GLSL

// optional string name = 1;
inline bool GLSL::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLSL::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLSL::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLSL::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GLSL::name() const {
  return *name_;
}
inline void GLSL::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GLSL::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GLSL::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLSL::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GLSL::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string guid = 2;
inline bool GLSL::has_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLSL::set_has_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLSL::clear_has_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLSL::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& GLSL::guid() const {
  return *guid_;
}
inline void GLSL::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void GLSL::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void GLSL::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLSL::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* GLSL::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vert_code = 3;
inline bool GLSL::has_vert_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLSL::set_has_vert_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLSL::clear_has_vert_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLSL::clear_vert_code() {
  if (vert_code_ != &::google::protobuf::internal::kEmptyString) {
    vert_code_->clear();
  }
  clear_has_vert_code();
}
inline const ::std::string& GLSL::vert_code() const {
  return *vert_code_;
}
inline void GLSL::set_vert_code(const ::std::string& value) {
  set_has_vert_code();
  if (vert_code_ == &::google::protobuf::internal::kEmptyString) {
    vert_code_ = new ::std::string;
  }
  vert_code_->assign(value);
}
inline void GLSL::set_vert_code(const char* value) {
  set_has_vert_code();
  if (vert_code_ == &::google::protobuf::internal::kEmptyString) {
    vert_code_ = new ::std::string;
  }
  vert_code_->assign(value);
}
inline void GLSL::set_vert_code(const void* value, size_t size) {
  set_has_vert_code();
  if (vert_code_ == &::google::protobuf::internal::kEmptyString) {
    vert_code_ = new ::std::string;
  }
  vert_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLSL::mutable_vert_code() {
  set_has_vert_code();
  if (vert_code_ == &::google::protobuf::internal::kEmptyString) {
    vert_code_ = new ::std::string;
  }
  return vert_code_;
}
inline ::std::string* GLSL::release_vert_code() {
  clear_has_vert_code();
  if (vert_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vert_code_;
    vert_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes frag_code = 4;
inline bool GLSL::has_frag_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLSL::set_has_frag_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLSL::clear_has_frag_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLSL::clear_frag_code() {
  if (frag_code_ != &::google::protobuf::internal::kEmptyString) {
    frag_code_->clear();
  }
  clear_has_frag_code();
}
inline const ::std::string& GLSL::frag_code() const {
  return *frag_code_;
}
inline void GLSL::set_frag_code(const ::std::string& value) {
  set_has_frag_code();
  if (frag_code_ == &::google::protobuf::internal::kEmptyString) {
    frag_code_ = new ::std::string;
  }
  frag_code_->assign(value);
}
inline void GLSL::set_frag_code(const char* value) {
  set_has_frag_code();
  if (frag_code_ == &::google::protobuf::internal::kEmptyString) {
    frag_code_ = new ::std::string;
  }
  frag_code_->assign(value);
}
inline void GLSL::set_frag_code(const void* value, size_t size) {
  set_has_frag_code();
  if (frag_code_ == &::google::protobuf::internal::kEmptyString) {
    frag_code_ = new ::std::string;
  }
  frag_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLSL::mutable_frag_code() {
  set_has_frag_code();
  if (frag_code_ == &::google::protobuf::internal::kEmptyString) {
    frag_code_ = new ::std::string;
  }
  return frag_code_;
}
inline ::std::string* GLSL::release_frag_code() {
  clear_has_frag_code();
  if (frag_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frag_code_;
    frag_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Serializer.AttributeDefine attributes = 5;
inline int GLSL::attributes_size() const {
  return attributes_.size();
}
inline void GLSL::clear_attributes() {
  attributes_.Clear();
}
inline const ::Serializer::AttributeDefine& GLSL::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::Serializer::AttributeDefine* GLSL::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::Serializer::AttributeDefine* GLSL::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::AttributeDefine >&
GLSL::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::AttributeDefine >*
GLSL::mutable_attributes() {
  return &attributes_;
}

// repeated .Serializer.UniformDefine uniforms = 6;
inline int GLSL::uniforms_size() const {
  return uniforms_.size();
}
inline void GLSL::clear_uniforms() {
  uniforms_.Clear();
}
inline const ::Serializer::UniformDefine& GLSL::uniforms(int index) const {
  return uniforms_.Get(index);
}
inline ::Serializer::UniformDefine* GLSL::mutable_uniforms(int index) {
  return uniforms_.Mutable(index);
}
inline ::Serializer::UniformDefine* GLSL::add_uniforms() {
  return uniforms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::UniformDefine >&
GLSL::uniforms() const {
  return uniforms_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::UniformDefine >*
GLSL::mutable_uniforms() {
  return &uniforms_;
}

// optional fixed64 lwtVS = 7;
inline bool GLSL::has_lwtvs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLSL::set_has_lwtvs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLSL::clear_has_lwtvs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLSL::clear_lwtvs() {
  lwtvs_ = GOOGLE_ULONGLONG(0);
  clear_has_lwtvs();
}
inline ::google::protobuf::uint64 GLSL::lwtvs() const {
  return lwtvs_;
}
inline void GLSL::set_lwtvs(::google::protobuf::uint64 value) {
  set_has_lwtvs();
  lwtvs_ = value;
}

// optional fixed64 lwtFS = 8;
inline bool GLSL::has_lwtfs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLSL::set_has_lwtfs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLSL::clear_has_lwtfs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLSL::clear_lwtfs() {
  lwtfs_ = GOOGLE_ULONGLONG(0);
  clear_has_lwtfs();
}
inline ::google::protobuf::uint64 GLSL::lwtfs() const {
  return lwtfs_;
}
inline void GLSL::set_lwtfs(::google::protobuf::uint64 value) {
  set_has_lwtfs();
  lwtfs_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GLSL_2eproto__INCLUDED
