// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TextureInfo.proto

#ifndef PROTOBUF_TextureInfo_2eproto__INCLUDED
#define PROTOBUF_TextureInfo_2eproto__INCLUDED

#include <string>

#include "common.h"

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "generated_message_util.h"
#include "repeated_field.h"
#include "extension_set.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TextureInfo_2eproto();
void protobuf_AssignDesc_TextureInfo_2eproto();
void protobuf_ShutdownFile_TextureInfo_2eproto();

class ETC1Data;
class ImageCompressInfo;
class Sprite;
class Texture;
class TextureInfo;

// ===================================================================

class ETC1Data : public ::google::protobuf::MessageLite {
 public:
  ETC1Data();
  virtual ~ETC1Data();
  
  ETC1Data(const ETC1Data& from);
  
  inline ETC1Data& operator=(const ETC1Data& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ETC1Data& default_instance();
  
  void Swap(ETC1Data* other);
  
  // implements Message ----------------------------------------------
  
  ETC1Data* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ETC1Data& from);
  void MergeFrom(const ETC1Data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes RGB = 1;
  inline bool has_rgb() const;
  inline void clear_rgb();
  static const int kRGBFieldNumber = 1;
  inline const ::std::string& rgb() const;
  inline void set_rgb(const ::std::string& value);
  inline void set_rgb(const char* value);
  inline void set_rgb(const void* value, size_t size);
  inline ::std::string* mutable_rgb();
  inline ::std::string* release_rgb();
  
  // optional bytes Alpha = 2;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 2;
  inline const ::std::string& alpha() const;
  inline void set_alpha(const ::std::string& value);
  inline void set_alpha(const char* value);
  inline void set_alpha(const void* value, size_t size);
  inline ::std::string* mutable_alpha();
  inline ::std::string* release_alpha();
  
  // @@protoc_insertion_point(class_scope:Serializer.ETC1Data)
 private:
  inline void set_has_rgb();
  inline void clear_has_rgb();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  
  ::std::string* rgb_;
  ::std::string* alpha_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_TextureInfo_2eproto();
  friend void protobuf_AssignDesc_TextureInfo_2eproto();
  friend void protobuf_ShutdownFile_TextureInfo_2eproto();
  
  void InitAsDefaultInstance();
  static ETC1Data* default_instance_;
};
// -------------------------------------------------------------------

class ImageCompressInfo : public ::google::protobuf::MessageLite {
 public:
  ImageCompressInfo();
  virtual ~ImageCompressInfo();
  
  ImageCompressInfo(const ImageCompressInfo& from);
  
  inline ImageCompressInfo& operator=(const ImageCompressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ImageCompressInfo& default_instance();
  
  void Swap(ImageCompressInfo* other);
  
  // implements Message ----------------------------------------------
  
  ImageCompressInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageCompressInfo& from);
  void MergeFrom(const ImageCompressInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 max_size = 1;
  inline bool has_max_size() const;
  inline void clear_max_size();
  static const int kMaxSizeFieldNumber = 1;
  inline ::google::protobuf::int32 max_size() const;
  inline void set_max_size(::google::protobuf::int32 value);
  
  // optional int32 format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline ::google::protobuf::int32 format() const;
  inline void set_format(::google::protobuf::int32 value);
  
  // optional int32 quality = 3;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 3;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Serializer.ImageCompressInfo)
 private:
  inline void set_has_max_size();
  inline void clear_has_max_size();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_quality();
  inline void clear_has_quality();
  
  ::google::protobuf::int32 max_size_;
  ::google::protobuf::int32 format_;
  ::google::protobuf::int32 quality_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_TextureInfo_2eproto();
  friend void protobuf_AssignDesc_TextureInfo_2eproto();
  friend void protobuf_ShutdownFile_TextureInfo_2eproto();
  
  void InitAsDefaultInstance();
  static ImageCompressInfo* default_instance_;
};
// -------------------------------------------------------------------

class Sprite : public ::google::protobuf::MessageLite {
 public:
  Sprite();
  virtual ~Sprite();
  
  Sprite(const Sprite& from);
  
  inline Sprite& operator=(const Sprite& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Sprite& default_instance();
  
  void Swap(Sprite* other);
  
  // implements Message ----------------------------------------------
  
  Sprite* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Sprite& from);
  void MergeFrom(const Sprite& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated int32 original = 2;
  inline int original_size() const;
  inline void clear_original();
  static const int kOriginalFieldNumber = 2;
  inline ::google::protobuf::int32 original(int index) const;
  inline void set_original(int index, ::google::protobuf::int32 value);
  inline void add_original(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      original() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_original();
  
  // repeated int32 size = 3;
  inline int size_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size(int index) const;
  inline void set_size(int index, ::google::protobuf::int32 value);
  inline void add_size(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      size() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_size();
  
  // repeated float texcoords = 4;
  inline int texcoords_size() const;
  inline void clear_texcoords();
  static const int kTexcoordsFieldNumber = 4;
  inline float texcoords(int index) const;
  inline void set_texcoords(int index, float value);
  inline void add_texcoords(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      texcoords() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_texcoords();
  
  // repeated int32 split = 5;
  inline int split_size() const;
  inline void clear_split();
  static const int kSplitFieldNumber = 5;
  inline ::google::protobuf::int32 split(int index) const;
  inline void set_split(int index, ::google::protobuf::int32 value);
  inline void add_split(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      split() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_split();
  
  // repeated int32 pad = 6;
  inline int pad_size() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 6;
  inline ::google::protobuf::int32 pad(int index) const;
  inline void set_pad(int index, ::google::protobuf::int32 value);
  inline void add_pad(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pad() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pad();
  
  // optional bool rotate = 7;
  inline bool has_rotate() const;
  inline void clear_rotate();
  static const int kRotateFieldNumber = 7;
  inline bool rotate() const;
  inline void set_rotate(bool value);
  
  // @@protoc_insertion_point(class_scope:Serializer.Sprite)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rotate();
  inline void clear_has_rotate();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > original_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > size_;
  ::google::protobuf::RepeatedField< float > texcoords_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > split_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pad_;
  bool rotate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_TextureInfo_2eproto();
  friend void protobuf_AssignDesc_TextureInfo_2eproto();
  friend void protobuf_ShutdownFile_TextureInfo_2eproto();
  
  void InitAsDefaultInstance();
  static Sprite* default_instance_;
};
// -------------------------------------------------------------------

class Texture : public ::google::protobuf::MessageLite {
 public:
  Texture();
  virtual ~Texture();
  
  Texture(const Texture& from);
  
  inline Texture& operator=(const Texture& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Texture& default_instance();
  
  void Swap(Texture* other);
  
  // implements Message ----------------------------------------------
  
  Texture* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Texture& from);
  void MergeFrom(const Texture& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // optional bytes image_data = 2;
  inline bool has_image_data() const;
  inline void clear_image_data();
  static const int kImageDataFieldNumber = 2;
  inline const ::std::string& image_data() const;
  inline void set_image_data(const ::std::string& value);
  inline void set_image_data(const char* value);
  inline void set_image_data(const void* value, size_t size);
  inline ::std::string* mutable_image_data();
  inline ::std::string* release_image_data();
  
  // optional string guid = 3;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 3;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  
  // optional int32 min_filter = 4;
  inline bool has_min_filter() const;
  inline void clear_min_filter();
  static const int kMinFilterFieldNumber = 4;
  inline ::google::protobuf::int32 min_filter() const;
  inline void set_min_filter(::google::protobuf::int32 value);
  
  // optional int32 mag_filter = 5;
  inline bool has_mag_filter() const;
  inline void clear_mag_filter();
  static const int kMagFilterFieldNumber = 5;
  inline ::google::protobuf::int32 mag_filter() const;
  inline void set_mag_filter(::google::protobuf::int32 value);
  
  // optional int32 format = 6;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 6;
  inline ::google::protobuf::int32 format() const;
  inline void set_format(::google::protobuf::int32 value);
  
  // optional int32 width = 7;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 7;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 8;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 8;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional int32 wrap_mode_u = 9;
  inline bool has_wrap_mode_u() const;
  inline void clear_wrap_mode_u();
  static const int kWrapModeUFieldNumber = 9;
  inline ::google::protobuf::int32 wrap_mode_u() const;
  inline void set_wrap_mode_u(::google::protobuf::int32 value);
  
  // optional int32 wrap_mode_v = 10;
  inline bool has_wrap_mode_v() const;
  inline void clear_wrap_mode_v();
  static const int kWrapModeVFieldNumber = 10;
  inline ::google::protobuf::int32 wrap_mode_v() const;
  inline void set_wrap_mode_v(::google::protobuf::int32 value);
  
  // repeated .Serializer.Sprite sprites = 11;
  inline int sprites_size() const;
  inline void clear_sprites();
  static const int kSpritesFieldNumber = 11;
  inline const ::Serializer::Sprite& sprites(int index) const;
  inline ::Serializer::Sprite* mutable_sprites(int index);
  inline ::Serializer::Sprite* add_sprites();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Sprite >&
      sprites() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializer::Sprite >*
      mutable_sprites();
  
  // @@protoc_insertion_point(class_scope:Serializer.Texture)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_image_data();
  inline void clear_has_image_data();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_min_filter();
  inline void clear_has_min_filter();
  inline void set_has_mag_filter();
  inline void clear_has_mag_filter();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_wrap_mode_u();
  inline void clear_has_wrap_mode_u();
  inline void set_has_wrap_mode_v();
  inline void clear_has_wrap_mode_v();
  
  ::std::string* path_;
  ::std::string* image_data_;
  ::std::string* guid_;
  ::google::protobuf::int32 min_filter_;
  ::google::protobuf::int32 mag_filter_;
  ::google::protobuf::int32 format_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 wrap_mode_u_;
  ::google::protobuf::RepeatedPtrField< ::Serializer::Sprite > sprites_;
  ::google::protobuf::int32 wrap_mode_v_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_TextureInfo_2eproto();
  friend void protobuf_AssignDesc_TextureInfo_2eproto();
  friend void protobuf_ShutdownFile_TextureInfo_2eproto();
  
  void InitAsDefaultInstance();
  static Texture* default_instance_;
};
// -------------------------------------------------------------------

class TextureInfo : public ::google::protobuf::MessageLite {
 public:
  TextureInfo();
  virtual ~TextureInfo();
  
  TextureInfo(const TextureInfo& from);
  
  inline TextureInfo& operator=(const TextureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TextureInfo& default_instance();
  
  void Swap(TextureInfo* other);
  
  // implements Message ----------------------------------------------
  
  TextureInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextureInfo& from);
  void MergeFrom(const TextureInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // optional string guid = 2;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 2;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  
  // optional int32 wrapMode = 3;
  inline bool has_wrapmode() const;
  inline void clear_wrapmode();
  static const int kWrapModeFieldNumber = 3;
  inline ::google::protobuf::int32 wrapmode() const;
  inline void set_wrapmode(::google::protobuf::int32 value);
  
  // optional .Serializer.ImageCompressInfo Editor = 4;
  inline bool has_editor() const;
  inline void clear_editor();
  static const int kEditorFieldNumber = 4;
  inline const ::Serializer::ImageCompressInfo& editor() const;
  inline ::Serializer::ImageCompressInfo* mutable_editor();
  inline ::Serializer::ImageCompressInfo* release_editor();
  
  // optional .Serializer.ImageCompressInfo IOS = 5;
  inline bool has_ios() const;
  inline void clear_ios();
  static const int kIOSFieldNumber = 5;
  inline const ::Serializer::ImageCompressInfo& ios() const;
  inline ::Serializer::ImageCompressInfo* mutable_ios();
  inline ::Serializer::ImageCompressInfo* release_ios();
  
  // optional .Serializer.ImageCompressInfo Android = 6;
  inline bool has_android() const;
  inline void clear_android();
  static const int kAndroidFieldNumber = 6;
  inline const ::Serializer::ImageCompressInfo& android() const;
  inline ::Serializer::ImageCompressInfo* mutable_android();
  inline ::Serializer::ImageCompressInfo* release_android();
  
  // optional bytes imageData = 7;
  inline bool has_imagedata() const;
  inline void clear_imagedata();
  static const int kImageDataFieldNumber = 7;
  inline const ::std::string& imagedata() const;
  inline void set_imagedata(const ::std::string& value);
  inline void set_imagedata(const char* value);
  inline void set_imagedata(const void* value, size_t size);
  inline ::std::string* mutable_imagedata();
  inline ::std::string* release_imagedata();
  
  // optional int32 width = 8;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 8;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 9;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 9;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional fixed64 last_write_time = 10;
  inline bool has_last_write_time() const;
  inline void clear_last_write_time();
  static const int kLastWriteTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 last_write_time() const;
  inline void set_last_write_time(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:Serializer.TextureInfo)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_wrapmode();
  inline void clear_has_wrapmode();
  inline void set_has_editor();
  inline void clear_has_editor();
  inline void set_has_ios();
  inline void clear_has_ios();
  inline void set_has_android();
  inline void clear_has_android();
  inline void set_has_imagedata();
  inline void clear_has_imagedata();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_last_write_time();
  inline void clear_has_last_write_time();
  
  ::std::string* path_;
  ::std::string* guid_;
  ::Serializer::ImageCompressInfo* editor_;
  ::Serializer::ImageCompressInfo* ios_;
  ::google::protobuf::int32 wrapmode_;
  ::google::protobuf::int32 width_;
  ::Serializer::ImageCompressInfo* android_;
  ::std::string* imagedata_;
  ::google::protobuf::uint64 last_write_time_;
  ::google::protobuf::int32 height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_TextureInfo_2eproto();
  friend void protobuf_AssignDesc_TextureInfo_2eproto();
  friend void protobuf_ShutdownFile_TextureInfo_2eproto();
  
  void InitAsDefaultInstance();
  static TextureInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// ETC1Data

// optional bytes RGB = 1;
inline bool ETC1Data::has_rgb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ETC1Data::set_has_rgb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ETC1Data::clear_has_rgb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ETC1Data::clear_rgb() {
  if (rgb_ != &::google::protobuf::internal::kEmptyString) {
    rgb_->clear();
  }
  clear_has_rgb();
}
inline const ::std::string& ETC1Data::rgb() const {
  return *rgb_;
}
inline void ETC1Data::set_rgb(const ::std::string& value) {
  set_has_rgb();
  if (rgb_ == &::google::protobuf::internal::kEmptyString) {
    rgb_ = new ::std::string;
  }
  rgb_->assign(value);
}
inline void ETC1Data::set_rgb(const char* value) {
  set_has_rgb();
  if (rgb_ == &::google::protobuf::internal::kEmptyString) {
    rgb_ = new ::std::string;
  }
  rgb_->assign(value);
}
inline void ETC1Data::set_rgb(const void* value, size_t size) {
  set_has_rgb();
  if (rgb_ == &::google::protobuf::internal::kEmptyString) {
    rgb_ = new ::std::string;
  }
  rgb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETC1Data::mutable_rgb() {
  set_has_rgb();
  if (rgb_ == &::google::protobuf::internal::kEmptyString) {
    rgb_ = new ::std::string;
  }
  return rgb_;
}
inline ::std::string* ETC1Data::release_rgb() {
  clear_has_rgb();
  if (rgb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rgb_;
    rgb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Alpha = 2;
inline bool ETC1Data::has_alpha() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ETC1Data::set_has_alpha() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ETC1Data::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ETC1Data::clear_alpha() {
  if (alpha_ != &::google::protobuf::internal::kEmptyString) {
    alpha_->clear();
  }
  clear_has_alpha();
}
inline const ::std::string& ETC1Data::alpha() const {
  return *alpha_;
}
inline void ETC1Data::set_alpha(const ::std::string& value) {
  set_has_alpha();
  if (alpha_ == &::google::protobuf::internal::kEmptyString) {
    alpha_ = new ::std::string;
  }
  alpha_->assign(value);
}
inline void ETC1Data::set_alpha(const char* value) {
  set_has_alpha();
  if (alpha_ == &::google::protobuf::internal::kEmptyString) {
    alpha_ = new ::std::string;
  }
  alpha_->assign(value);
}
inline void ETC1Data::set_alpha(const void* value, size_t size) {
  set_has_alpha();
  if (alpha_ == &::google::protobuf::internal::kEmptyString) {
    alpha_ = new ::std::string;
  }
  alpha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETC1Data::mutable_alpha() {
  set_has_alpha();
  if (alpha_ == &::google::protobuf::internal::kEmptyString) {
    alpha_ = new ::std::string;
  }
  return alpha_;
}
inline ::std::string* ETC1Data::release_alpha() {
  clear_has_alpha();
  if (alpha_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alpha_;
    alpha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ImageCompressInfo

// optional int32 max_size = 1;
inline bool ImageCompressInfo::has_max_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageCompressInfo::set_has_max_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageCompressInfo::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageCompressInfo::clear_max_size() {
  max_size_ = 0;
  clear_has_max_size();
}
inline ::google::protobuf::int32 ImageCompressInfo::max_size() const {
  return max_size_;
}
inline void ImageCompressInfo::set_max_size(::google::protobuf::int32 value) {
  set_has_max_size();
  max_size_ = value;
}

// optional int32 format = 2;
inline bool ImageCompressInfo::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageCompressInfo::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageCompressInfo::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageCompressInfo::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::google::protobuf::int32 ImageCompressInfo::format() const {
  return format_;
}
inline void ImageCompressInfo::set_format(::google::protobuf::int32 value) {
  set_has_format();
  format_ = value;
}

// optional int32 quality = 3;
inline bool ImageCompressInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageCompressInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageCompressInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageCompressInfo::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 ImageCompressInfo::quality() const {
  return quality_;
}
inline void ImageCompressInfo::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// -------------------------------------------------------------------

// Sprite

// optional string name = 1;
inline bool Sprite::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sprite::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sprite::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sprite::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Sprite::name() const {
  return *name_;
}
inline void Sprite::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Sprite::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Sprite::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sprite::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Sprite::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 original = 2;
inline int Sprite::original_size() const {
  return original_.size();
}
inline void Sprite::clear_original() {
  original_.Clear();
}
inline ::google::protobuf::int32 Sprite::original(int index) const {
  return original_.Get(index);
}
inline void Sprite::set_original(int index, ::google::protobuf::int32 value) {
  original_.Set(index, value);
}
inline void Sprite::add_original(::google::protobuf::int32 value) {
  original_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Sprite::original() const {
  return original_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Sprite::mutable_original() {
  return &original_;
}

// repeated int32 size = 3;
inline int Sprite::size_size() const {
  return size_.size();
}
inline void Sprite::clear_size() {
  size_.Clear();
}
inline ::google::protobuf::int32 Sprite::size(int index) const {
  return size_.Get(index);
}
inline void Sprite::set_size(int index, ::google::protobuf::int32 value) {
  size_.Set(index, value);
}
inline void Sprite::add_size(::google::protobuf::int32 value) {
  size_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Sprite::size() const {
  return size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Sprite::mutable_size() {
  return &size_;
}

// repeated float texcoords = 4;
inline int Sprite::texcoords_size() const {
  return texcoords_.size();
}
inline void Sprite::clear_texcoords() {
  texcoords_.Clear();
}
inline float Sprite::texcoords(int index) const {
  return texcoords_.Get(index);
}
inline void Sprite::set_texcoords(int index, float value) {
  texcoords_.Set(index, value);
}
inline void Sprite::add_texcoords(float value) {
  texcoords_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Sprite::texcoords() const {
  return texcoords_;
}
inline ::google::protobuf::RepeatedField< float >*
Sprite::mutable_texcoords() {
  return &texcoords_;
}

// repeated int32 split = 5;
inline int Sprite::split_size() const {
  return split_.size();
}
inline void Sprite::clear_split() {
  split_.Clear();
}
inline ::google::protobuf::int32 Sprite::split(int index) const {
  return split_.Get(index);
}
inline void Sprite::set_split(int index, ::google::protobuf::int32 value) {
  split_.Set(index, value);
}
inline void Sprite::add_split(::google::protobuf::int32 value) {
  split_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Sprite::split() const {
  return split_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Sprite::mutable_split() {
  return &split_;
}

// repeated int32 pad = 6;
inline int Sprite::pad_size() const {
  return pad_.size();
}
inline void Sprite::clear_pad() {
  pad_.Clear();
}
inline ::google::protobuf::int32 Sprite::pad(int index) const {
  return pad_.Get(index);
}
inline void Sprite::set_pad(int index, ::google::protobuf::int32 value) {
  pad_.Set(index, value);
}
inline void Sprite::add_pad(::google::protobuf::int32 value) {
  pad_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Sprite::pad() const {
  return pad_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Sprite::mutable_pad() {
  return &pad_;
}

// optional bool rotate = 7;
inline bool Sprite::has_rotate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Sprite::set_has_rotate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Sprite::clear_has_rotate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Sprite::clear_rotate() {
  rotate_ = false;
  clear_has_rotate();
}
inline bool Sprite::rotate() const {
  return rotate_;
}
inline void Sprite::set_rotate(bool value) {
  set_has_rotate();
  rotate_ = value;
}

// -------------------------------------------------------------------

// Texture

// optional string path = 1;
inline bool Texture::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Texture::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Texture::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Texture::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Texture::path() const {
  return *path_;
}
inline void Texture::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Texture::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Texture::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Texture::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Texture::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes image_data = 2;
inline bool Texture::has_image_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Texture::set_has_image_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Texture::clear_has_image_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Texture::clear_image_data() {
  if (image_data_ != &::google::protobuf::internal::kEmptyString) {
    image_data_->clear();
  }
  clear_has_image_data();
}
inline const ::std::string& Texture::image_data() const {
  return *image_data_;
}
inline void Texture::set_image_data(const ::std::string& value) {
  set_has_image_data();
  if (image_data_ == &::google::protobuf::internal::kEmptyString) {
    image_data_ = new ::std::string;
  }
  image_data_->assign(value);
}
inline void Texture::set_image_data(const char* value) {
  set_has_image_data();
  if (image_data_ == &::google::protobuf::internal::kEmptyString) {
    image_data_ = new ::std::string;
  }
  image_data_->assign(value);
}
inline void Texture::set_image_data(const void* value, size_t size) {
  set_has_image_data();
  if (image_data_ == &::google::protobuf::internal::kEmptyString) {
    image_data_ = new ::std::string;
  }
  image_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Texture::mutable_image_data() {
  set_has_image_data();
  if (image_data_ == &::google::protobuf::internal::kEmptyString) {
    image_data_ = new ::std::string;
  }
  return image_data_;
}
inline ::std::string* Texture::release_image_data() {
  clear_has_image_data();
  if (image_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_data_;
    image_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string guid = 3;
inline bool Texture::has_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Texture::set_has_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Texture::clear_has_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Texture::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& Texture::guid() const {
  return *guid_;
}
inline void Texture::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Texture::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Texture::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Texture::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* Texture::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 min_filter = 4;
inline bool Texture::has_min_filter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Texture::set_has_min_filter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Texture::clear_has_min_filter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Texture::clear_min_filter() {
  min_filter_ = 0;
  clear_has_min_filter();
}
inline ::google::protobuf::int32 Texture::min_filter() const {
  return min_filter_;
}
inline void Texture::set_min_filter(::google::protobuf::int32 value) {
  set_has_min_filter();
  min_filter_ = value;
}

// optional int32 mag_filter = 5;
inline bool Texture::has_mag_filter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Texture::set_has_mag_filter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Texture::clear_has_mag_filter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Texture::clear_mag_filter() {
  mag_filter_ = 0;
  clear_has_mag_filter();
}
inline ::google::protobuf::int32 Texture::mag_filter() const {
  return mag_filter_;
}
inline void Texture::set_mag_filter(::google::protobuf::int32 value) {
  set_has_mag_filter();
  mag_filter_ = value;
}

// optional int32 format = 6;
inline bool Texture::has_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Texture::set_has_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Texture::clear_has_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Texture::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::google::protobuf::int32 Texture::format() const {
  return format_;
}
inline void Texture::set_format(::google::protobuf::int32 value) {
  set_has_format();
  format_ = value;
}

// optional int32 width = 7;
inline bool Texture::has_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Texture::set_has_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Texture::clear_has_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Texture::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Texture::width() const {
  return width_;
}
inline void Texture::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 8;
inline bool Texture::has_height() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Texture::set_has_height() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Texture::clear_has_height() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Texture::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Texture::height() const {
  return height_;
}
inline void Texture::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 wrap_mode_u = 9;
inline bool Texture::has_wrap_mode_u() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Texture::set_has_wrap_mode_u() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Texture::clear_has_wrap_mode_u() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Texture::clear_wrap_mode_u() {
  wrap_mode_u_ = 0;
  clear_has_wrap_mode_u();
}
inline ::google::protobuf::int32 Texture::wrap_mode_u() const {
  return wrap_mode_u_;
}
inline void Texture::set_wrap_mode_u(::google::protobuf::int32 value) {
  set_has_wrap_mode_u();
  wrap_mode_u_ = value;
}

// optional int32 wrap_mode_v = 10;
inline bool Texture::has_wrap_mode_v() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Texture::set_has_wrap_mode_v() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Texture::clear_has_wrap_mode_v() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Texture::clear_wrap_mode_v() {
  wrap_mode_v_ = 0;
  clear_has_wrap_mode_v();
}
inline ::google::protobuf::int32 Texture::wrap_mode_v() const {
  return wrap_mode_v_;
}
inline void Texture::set_wrap_mode_v(::google::protobuf::int32 value) {
  set_has_wrap_mode_v();
  wrap_mode_v_ = value;
}

// repeated .Serializer.Sprite sprites = 11;
inline int Texture::sprites_size() const {
  return sprites_.size();
}
inline void Texture::clear_sprites() {
  sprites_.Clear();
}
inline const ::Serializer::Sprite& Texture::sprites(int index) const {
  return sprites_.Get(index);
}
inline ::Serializer::Sprite* Texture::mutable_sprites(int index) {
  return sprites_.Mutable(index);
}
inline ::Serializer::Sprite* Texture::add_sprites() {
  return sprites_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializer::Sprite >&
Texture::sprites() const {
  return sprites_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializer::Sprite >*
Texture::mutable_sprites() {
  return &sprites_;
}

// -------------------------------------------------------------------

// TextureInfo

// optional string path = 1;
inline bool TextureInfo::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextureInfo::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextureInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextureInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TextureInfo::path() const {
  return *path_;
}
inline void TextureInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TextureInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void TextureInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextureInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* TextureInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string guid = 2;
inline bool TextureInfo::has_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextureInfo::set_has_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextureInfo::clear_has_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextureInfo::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& TextureInfo::guid() const {
  return *guid_;
}
inline void TextureInfo::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void TextureInfo::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void TextureInfo::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextureInfo::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* TextureInfo::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 wrapMode = 3;
inline bool TextureInfo::has_wrapmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextureInfo::set_has_wrapmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextureInfo::clear_has_wrapmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextureInfo::clear_wrapmode() {
  wrapmode_ = 0;
  clear_has_wrapmode();
}
inline ::google::protobuf::int32 TextureInfo::wrapmode() const {
  return wrapmode_;
}
inline void TextureInfo::set_wrapmode(::google::protobuf::int32 value) {
  set_has_wrapmode();
  wrapmode_ = value;
}

// optional .Serializer.ImageCompressInfo Editor = 4;
inline bool TextureInfo::has_editor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextureInfo::set_has_editor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextureInfo::clear_has_editor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextureInfo::clear_editor() {
  if (editor_ != NULL) editor_->::Serializer::ImageCompressInfo::Clear();
  clear_has_editor();
}
inline const ::Serializer::ImageCompressInfo& TextureInfo::editor() const {
  return editor_ != NULL ? *editor_ : *default_instance_->editor_;
}
inline ::Serializer::ImageCompressInfo* TextureInfo::mutable_editor() {
  set_has_editor();
  if (editor_ == NULL) editor_ = new ::Serializer::ImageCompressInfo;
  return editor_;
}
inline ::Serializer::ImageCompressInfo* TextureInfo::release_editor() {
  clear_has_editor();
  ::Serializer::ImageCompressInfo* temp = editor_;
  editor_ = NULL;
  return temp;
}

// optional .Serializer.ImageCompressInfo IOS = 5;
inline bool TextureInfo::has_ios() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextureInfo::set_has_ios() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextureInfo::clear_has_ios() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextureInfo::clear_ios() {
  if (ios_ != NULL) ios_->::Serializer::ImageCompressInfo::Clear();
  clear_has_ios();
}
inline const ::Serializer::ImageCompressInfo& TextureInfo::ios() const {
  return ios_ != NULL ? *ios_ : *default_instance_->ios_;
}
inline ::Serializer::ImageCompressInfo* TextureInfo::mutable_ios() {
  set_has_ios();
  if (ios_ == NULL) ios_ = new ::Serializer::ImageCompressInfo;
  return ios_;
}
inline ::Serializer::ImageCompressInfo* TextureInfo::release_ios() {
  clear_has_ios();
  ::Serializer::ImageCompressInfo* temp = ios_;
  ios_ = NULL;
  return temp;
}

// optional .Serializer.ImageCompressInfo Android = 6;
inline bool TextureInfo::has_android() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TextureInfo::set_has_android() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TextureInfo::clear_has_android() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TextureInfo::clear_android() {
  if (android_ != NULL) android_->::Serializer::ImageCompressInfo::Clear();
  clear_has_android();
}
inline const ::Serializer::ImageCompressInfo& TextureInfo::android() const {
  return android_ != NULL ? *android_ : *default_instance_->android_;
}
inline ::Serializer::ImageCompressInfo* TextureInfo::mutable_android() {
  set_has_android();
  if (android_ == NULL) android_ = new ::Serializer::ImageCompressInfo;
  return android_;
}
inline ::Serializer::ImageCompressInfo* TextureInfo::release_android() {
  clear_has_android();
  ::Serializer::ImageCompressInfo* temp = android_;
  android_ = NULL;
  return temp;
}

// optional bytes imageData = 7;
inline bool TextureInfo::has_imagedata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TextureInfo::set_has_imagedata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TextureInfo::clear_has_imagedata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TextureInfo::clear_imagedata() {
  if (imagedata_ != &::google::protobuf::internal::kEmptyString) {
    imagedata_->clear();
  }
  clear_has_imagedata();
}
inline const ::std::string& TextureInfo::imagedata() const {
  return *imagedata_;
}
inline void TextureInfo::set_imagedata(const ::std::string& value) {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  imagedata_->assign(value);
}
inline void TextureInfo::set_imagedata(const char* value) {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  imagedata_->assign(value);
}
inline void TextureInfo::set_imagedata(const void* value, size_t size) {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  imagedata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextureInfo::mutable_imagedata() {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  return imagedata_;
}
inline ::std::string* TextureInfo::release_imagedata() {
  clear_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagedata_;
    imagedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 width = 8;
inline bool TextureInfo::has_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TextureInfo::set_has_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TextureInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TextureInfo::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 TextureInfo::width() const {
  return width_;
}
inline void TextureInfo::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 9;
inline bool TextureInfo::has_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TextureInfo::set_has_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TextureInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TextureInfo::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 TextureInfo::height() const {
  return height_;
}
inline void TextureInfo::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional fixed64 last_write_time = 10;
inline bool TextureInfo::has_last_write_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TextureInfo::set_has_last_write_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TextureInfo::clear_has_last_write_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TextureInfo::clear_last_write_time() {
  last_write_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_write_time();
}
inline ::google::protobuf::uint64 TextureInfo::last_write_time() const {
  return last_write_time_;
}
inline void TextureInfo::set_last_write_time(::google::protobuf::uint64 value) {
  set_has_last_write_time();
  last_write_time_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TextureInfo_2eproto__INCLUDED
