// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "TextureInfo.serializer.h"

#include <algorithm>

#include "once.h"
#include "coded_stream.h"
#include "wire_format_lite_inl.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

void protobuf_ShutdownFile_TextureInfo_2eproto() {
  delete ETC1Data::default_instance_;
  delete ImageCompressInfo::default_instance_;
  delete Sprite::default_instance_;
  delete Texture::default_instance_;
  delete TextureInfo::default_instance_;
}

void protobuf_AddDesc_TextureInfo_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ETC1Data::default_instance_ = new ETC1Data();
  ImageCompressInfo::default_instance_ = new ImageCompressInfo();
  Sprite::default_instance_ = new Sprite();
  Texture::default_instance_ = new Texture();
  TextureInfo::default_instance_ = new TextureInfo();
  ETC1Data::default_instance_->InitAsDefaultInstance();
  ImageCompressInfo::default_instance_->InitAsDefaultInstance();
  Sprite::default_instance_->InitAsDefaultInstance();
  Texture::default_instance_->InitAsDefaultInstance();
  TextureInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_TextureInfo_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_TextureInfo_2eproto {
  StaticDescriptorInitializer_TextureInfo_2eproto() {
    protobuf_AddDesc_TextureInfo_2eproto();
  }
} static_descriptor_initializer_TextureInfo_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int ETC1Data::kRGBFieldNumber;
const int ETC1Data::kAlphaFieldNumber;
#endif  // !_MSC_VER

ETC1Data::ETC1Data()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ETC1Data::InitAsDefaultInstance() {
}

ETC1Data::ETC1Data(const ETC1Data& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ETC1Data::SharedCtor() {
  _cached_size_ = 0;
  rgb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  alpha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ETC1Data::~ETC1Data() {
  SharedDtor();
}

void ETC1Data::SharedDtor() {
  if (rgb_ != &::google::protobuf::internal::kEmptyString) {
    delete rgb_;
  }
  if (alpha_ != &::google::protobuf::internal::kEmptyString) {
    delete alpha_;
  }
  if (this != default_instance_) {
  }
}

void ETC1Data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ETC1Data& ETC1Data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureInfo_2eproto();  return *default_instance_;
}

ETC1Data* ETC1Data::default_instance_ = NULL;

ETC1Data* ETC1Data::New() const {
  return new ETC1Data;
}

void ETC1Data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_rgb()) {
      if (rgb_ != &::google::protobuf::internal::kEmptyString) {
        rgb_->clear();
      }
    }
    if (has_alpha()) {
      if (alpha_ != &::google::protobuf::internal::kEmptyString) {
        alpha_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ETC1Data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes RGB = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_rgb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Alpha;
        break;
      }
      
      // optional bytes Alpha = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Alpha:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_alpha()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ETC1Data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes RGB = 1;
  if (has_rgb()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->rgb(), output);
  }
  
  // optional bytes Alpha = 2;
  if (has_alpha()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->alpha(), output);
  }
  
}

int ETC1Data::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes RGB = 1;
    if (has_rgb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->rgb());
    }
    
    // optional bytes Alpha = 2;
    if (has_alpha()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->alpha());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ETC1Data::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ETC1Data*>(&from));
}

void ETC1Data::MergeFrom(const ETC1Data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rgb()) {
      set_rgb(from.rgb());
    }
    if (from.has_alpha()) {
      set_alpha(from.alpha());
    }
  }
}

void ETC1Data::CopyFrom(const ETC1Data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ETC1Data::IsInitialized() const {
  
  return true;
}

void ETC1Data::Swap(ETC1Data* other) {
  if (other != this) {
    std::swap(rgb_, other->rgb_);
    std::swap(alpha_, other->alpha_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ETC1Data::GetTypeName() const {
  return "Serializer.ETC1Data";
}


// ===================================================================

#ifndef _MSC_VER
const int ImageCompressInfo::kMaxSizeFieldNumber;
const int ImageCompressInfo::kFormatFieldNumber;
const int ImageCompressInfo::kQualityFieldNumber;
#endif  // !_MSC_VER

ImageCompressInfo::ImageCompressInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ImageCompressInfo::InitAsDefaultInstance() {
}

ImageCompressInfo::ImageCompressInfo(const ImageCompressInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ImageCompressInfo::SharedCtor() {
  _cached_size_ = 0;
  max_size_ = 0;
  format_ = 0;
  quality_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImageCompressInfo::~ImageCompressInfo() {
  SharedDtor();
}

void ImageCompressInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ImageCompressInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageCompressInfo& ImageCompressInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureInfo_2eproto();  return *default_instance_;
}

ImageCompressInfo* ImageCompressInfo::default_instance_ = NULL;

ImageCompressInfo* ImageCompressInfo::New() const {
  return new ImageCompressInfo;
}

void ImageCompressInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    max_size_ = 0;
    format_ = 0;
    quality_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ImageCompressInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 max_size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_size_)));
          set_has_max_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_format;
        break;
      }
      
      // optional int32 format = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &format_)));
          set_has_format();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_quality;
        break;
      }
      
      // optional int32 quality = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quality_)));
          set_has_quality();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImageCompressInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 max_size = 1;
  if (has_max_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->max_size(), output);
  }
  
  // optional int32 format = 2;
  if (has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->format(), output);
  }
  
  // optional int32 quality = 3;
  if (has_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->quality(), output);
  }
  
}

int ImageCompressInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 max_size = 1;
    if (has_max_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_size());
    }
    
    // optional int32 format = 2;
    if (has_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->format());
    }
    
    // optional int32 quality = 3;
    if (has_quality()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quality());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageCompressInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageCompressInfo*>(&from));
}

void ImageCompressInfo::MergeFrom(const ImageCompressInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_size()) {
      set_max_size(from.max_size());
    }
    if (from.has_format()) {
      set_format(from.format());
    }
    if (from.has_quality()) {
      set_quality(from.quality());
    }
  }
}

void ImageCompressInfo::CopyFrom(const ImageCompressInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageCompressInfo::IsInitialized() const {
  
  return true;
}

void ImageCompressInfo::Swap(ImageCompressInfo* other) {
  if (other != this) {
    std::swap(max_size_, other->max_size_);
    std::swap(format_, other->format_);
    std::swap(quality_, other->quality_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ImageCompressInfo::GetTypeName() const {
  return "Serializer.ImageCompressInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int Sprite::kNameFieldNumber;
const int Sprite::kOriginalFieldNumber;
const int Sprite::kSizeFieldNumber;
const int Sprite::kTexcoordsFieldNumber;
const int Sprite::kSplitFieldNumber;
const int Sprite::kPadFieldNumber;
const int Sprite::kRotateFieldNumber;
#endif  // !_MSC_VER

Sprite::Sprite()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Sprite::InitAsDefaultInstance() {
}

Sprite::Sprite(const Sprite& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Sprite::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  rotate_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sprite::~Sprite() {
  SharedDtor();
}

void Sprite::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Sprite::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Sprite& Sprite::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureInfo_2eproto();  return *default_instance_;
}

Sprite* Sprite::default_instance_ = NULL;

Sprite* Sprite::New() const {
  return new Sprite;
}

void Sprite::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    rotate_ = false;
  }
  original_.Clear();
  size_.Clear();
  texcoords_.Clear();
  split_.Clear();
  pad_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Sprite::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_original;
        break;
      }
      
      // repeated int32 original = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_original:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_original())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_original())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_original;
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }
      
      // repeated int32 size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_size())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_size())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_size;
        if (input->ExpectTag(37)) goto parse_texcoords;
        break;
      }
      
      // repeated float texcoords = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_texcoords:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_texcoords())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_texcoords())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_texcoords;
        if (input->ExpectTag(40)) goto parse_split;
        break;
      }
      
      // repeated int32 split = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_split:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 40, input, this->mutable_split())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_split())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_split;
        if (input->ExpectTag(48)) goto parse_pad;
        break;
      }
      
      // repeated int32 pad = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pad:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_pad())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_pad())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_pad;
        if (input->ExpectTag(56)) goto parse_rotate;
        break;
      }
      
      // optional bool rotate = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rotate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rotate_)));
          set_has_rotate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Sprite::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated int32 original = 2;
  for (int i = 0; i < this->original_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->original(i), output);
  }
  
  // repeated int32 size = 3;
  for (int i = 0; i < this->size_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->size(i), output);
  }
  
  // repeated float texcoords = 4;
  for (int i = 0; i < this->texcoords_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->texcoords(i), output);
  }
  
  // repeated int32 split = 5;
  for (int i = 0; i < this->split_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      5, this->split(i), output);
  }
  
  // repeated int32 pad = 6;
  for (int i = 0; i < this->pad_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->pad(i), output);
  }
  
  // optional bool rotate = 7;
  if (has_rotate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->rotate(), output);
  }
  
}

int Sprite::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional bool rotate = 7;
    if (has_rotate()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated int32 original = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->original_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->original(i));
    }
    total_size += 1 * this->original_size() + data_size;
  }
  
  // repeated int32 size = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->size_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->size(i));
    }
    total_size += 1 * this->size_size() + data_size;
  }
  
  // repeated float texcoords = 4;
  {
    int data_size = 0;
    data_size = 4 * this->texcoords_size();
    total_size += 1 * this->texcoords_size() + data_size;
  }
  
  // repeated int32 split = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->split_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->split(i));
    }
    total_size += 1 * this->split_size() + data_size;
  }
  
  // repeated int32 pad = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->pad_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->pad(i));
    }
    total_size += 1 * this->pad_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sprite::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Sprite*>(&from));
}

void Sprite::MergeFrom(const Sprite& from) {
  GOOGLE_CHECK_NE(&from, this);
  original_.MergeFrom(from.original_);
  size_.MergeFrom(from.size_);
  texcoords_.MergeFrom(from.texcoords_);
  split_.MergeFrom(from.split_);
  pad_.MergeFrom(from.pad_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_rotate()) {
      set_rotate(from.rotate());
    }
  }
}

void Sprite::CopyFrom(const Sprite& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sprite::IsInitialized() const {
  
  return true;
}

void Sprite::Swap(Sprite* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    original_.Swap(&other->original_);
    size_.Swap(&other->size_);
    texcoords_.Swap(&other->texcoords_);
    split_.Swap(&other->split_);
    pad_.Swap(&other->pad_);
    std::swap(rotate_, other->rotate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Sprite::GetTypeName() const {
  return "Serializer.Sprite";
}


// ===================================================================

#ifndef _MSC_VER
const int Texture::kPathFieldNumber;
const int Texture::kImageDataFieldNumber;
const int Texture::kGuidFieldNumber;
const int Texture::kMinFilterFieldNumber;
const int Texture::kMagFilterFieldNumber;
const int Texture::kFormatFieldNumber;
const int Texture::kWidthFieldNumber;
const int Texture::kHeightFieldNumber;
const int Texture::kWrapModeUFieldNumber;
const int Texture::kWrapModeVFieldNumber;
const int Texture::kSpritesFieldNumber;
#endif  // !_MSC_VER

Texture::Texture()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Texture::InitAsDefaultInstance() {
}

Texture::Texture(const Texture& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Texture::SharedCtor() {
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  min_filter_ = 0;
  mag_filter_ = 0;
  format_ = 0;
  width_ = 0;
  height_ = 0;
  wrap_mode_u_ = 0;
  wrap_mode_v_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Texture::~Texture() {
  SharedDtor();
}

void Texture::SharedDtor() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (image_data_ != &::google::protobuf::internal::kEmptyString) {
    delete image_data_;
  }
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (this != default_instance_) {
  }
}

void Texture::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Texture& Texture::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureInfo_2eproto();  return *default_instance_;
}

Texture* Texture::default_instance_ = NULL;

Texture* Texture::New() const {
  return new Texture;
}

void Texture::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    if (has_image_data()) {
      if (image_data_ != &::google::protobuf::internal::kEmptyString) {
        image_data_->clear();
      }
    }
    if (has_guid()) {
      if (guid_ != &::google::protobuf::internal::kEmptyString) {
        guid_->clear();
      }
    }
    min_filter_ = 0;
    mag_filter_ = 0;
    format_ = 0;
    width_ = 0;
    height_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    wrap_mode_u_ = 0;
    wrap_mode_v_ = 0;
  }
  sprites_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Texture::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string path = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_image_data;
        break;
      }
      
      // optional bytes image_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_image_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_guid;
        break;
      }
      
      // optional string guid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_min_filter;
        break;
      }
      
      // optional int32 min_filter = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_min_filter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_filter_)));
          set_has_min_filter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_mag_filter;
        break;
      }
      
      // optional int32 mag_filter = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mag_filter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mag_filter_)));
          set_has_mag_filter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_format;
        break;
      }
      
      // optional int32 format = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &format_)));
          set_has_format();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_width;
        break;
      }
      
      // optional int32 width = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_height;
        break;
      }
      
      // optional int32 height = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_wrap_mode_u;
        break;
      }
      
      // optional int32 wrap_mode_u = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_wrap_mode_u:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wrap_mode_u_)));
          set_has_wrap_mode_u();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_wrap_mode_v;
        break;
      }
      
      // optional int32 wrap_mode_v = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_wrap_mode_v:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wrap_mode_v_)));
          set_has_wrap_mode_v();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_sprites;
        break;
      }
      
      // repeated .Serializer.Sprite sprites = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sprites:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sprites()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_sprites;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Texture::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->path(), output);
  }
  
  // optional bytes image_data = 2;
  if (has_image_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->image_data(), output);
  }
  
  // optional string guid = 3;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->guid(), output);
  }
  
  // optional int32 min_filter = 4;
  if (has_min_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->min_filter(), output);
  }
  
  // optional int32 mag_filter = 5;
  if (has_mag_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->mag_filter(), output);
  }
  
  // optional int32 format = 6;
  if (has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->format(), output);
  }
  
  // optional int32 width = 7;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->width(), output);
  }
  
  // optional int32 height = 8;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->height(), output);
  }
  
  // optional int32 wrap_mode_u = 9;
  if (has_wrap_mode_u()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->wrap_mode_u(), output);
  }
  
  // optional int32 wrap_mode_v = 10;
  if (has_wrap_mode_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->wrap_mode_v(), output);
  }
  
  // repeated .Serializer.Sprite sprites = 11;
  for (int i = 0; i < this->sprites_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->sprites(i), output);
  }
  
}

int Texture::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
    // optional bytes image_data = 2;
    if (has_image_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->image_data());
    }
    
    // optional string guid = 3;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guid());
    }
    
    // optional int32 min_filter = 4;
    if (has_min_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min_filter());
    }
    
    // optional int32 mag_filter = 5;
    if (has_mag_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mag_filter());
    }
    
    // optional int32 format = 6;
    if (has_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->format());
    }
    
    // optional int32 width = 7;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // optional int32 height = 8;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 wrap_mode_u = 9;
    if (has_wrap_mode_u()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wrap_mode_u());
    }
    
    // optional int32 wrap_mode_v = 10;
    if (has_wrap_mode_v()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wrap_mode_v());
    }
    
  }
  // repeated .Serializer.Sprite sprites = 11;
  total_size += 1 * this->sprites_size();
  for (int i = 0; i < this->sprites_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sprites(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Texture::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Texture*>(&from));
}

void Texture::MergeFrom(const Texture& from) {
  GOOGLE_CHECK_NE(&from, this);
  sprites_.MergeFrom(from.sprites_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_image_data()) {
      set_image_data(from.image_data());
    }
    if (from.has_guid()) {
      set_guid(from.guid());
    }
    if (from.has_min_filter()) {
      set_min_filter(from.min_filter());
    }
    if (from.has_mag_filter()) {
      set_mag_filter(from.mag_filter());
    }
    if (from.has_format()) {
      set_format(from.format());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_wrap_mode_u()) {
      set_wrap_mode_u(from.wrap_mode_u());
    }
    if (from.has_wrap_mode_v()) {
      set_wrap_mode_v(from.wrap_mode_v());
    }
  }
}

void Texture::CopyFrom(const Texture& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Texture::IsInitialized() const {
  
  return true;
}

void Texture::Swap(Texture* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    std::swap(image_data_, other->image_data_);
    std::swap(guid_, other->guid_);
    std::swap(min_filter_, other->min_filter_);
    std::swap(mag_filter_, other->mag_filter_);
    std::swap(format_, other->format_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(wrap_mode_u_, other->wrap_mode_u_);
    std::swap(wrap_mode_v_, other->wrap_mode_v_);
    sprites_.Swap(&other->sprites_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Texture::GetTypeName() const {
  return "Serializer.Texture";
}


// ===================================================================

#ifndef _MSC_VER
const int TextureInfo::kPathFieldNumber;
const int TextureInfo::kGuidFieldNumber;
const int TextureInfo::kWrapModeFieldNumber;
const int TextureInfo::kEditorFieldNumber;
const int TextureInfo::kIOSFieldNumber;
const int TextureInfo::kAndroidFieldNumber;
const int TextureInfo::kImageDataFieldNumber;
const int TextureInfo::kWidthFieldNumber;
const int TextureInfo::kHeightFieldNumber;
const int TextureInfo::kLastWriteTimeFieldNumber;
#endif  // !_MSC_VER

TextureInfo::TextureInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TextureInfo::InitAsDefaultInstance() {
  editor_ = const_cast< ::Serializer::ImageCompressInfo*>(&::Serializer::ImageCompressInfo::default_instance());
  ios_ = const_cast< ::Serializer::ImageCompressInfo*>(&::Serializer::ImageCompressInfo::default_instance());
  android_ = const_cast< ::Serializer::ImageCompressInfo*>(&::Serializer::ImageCompressInfo::default_instance());
}

TextureInfo::TextureInfo(const TextureInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TextureInfo::SharedCtor() {
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  wrapmode_ = 0;
  editor_ = NULL;
  ios_ = NULL;
  android_ = NULL;
  imagedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  width_ = 0;
  height_ = 0;
  last_write_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TextureInfo::~TextureInfo() {
  SharedDtor();
}

void TextureInfo::SharedDtor() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (imagedata_ != &::google::protobuf::internal::kEmptyString) {
    delete imagedata_;
  }
  if (this != default_instance_) {
    delete editor_;
    delete ios_;
    delete android_;
  }
}

void TextureInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TextureInfo& TextureInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureInfo_2eproto();  return *default_instance_;
}

TextureInfo* TextureInfo::default_instance_ = NULL;

TextureInfo* TextureInfo::New() const {
  return new TextureInfo;
}

void TextureInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    if (has_guid()) {
      if (guid_ != &::google::protobuf::internal::kEmptyString) {
        guid_->clear();
      }
    }
    wrapmode_ = 0;
    if (has_editor()) {
      if (editor_ != NULL) editor_->::Serializer::ImageCompressInfo::Clear();
    }
    if (has_ios()) {
      if (ios_ != NULL) ios_->::Serializer::ImageCompressInfo::Clear();
    }
    if (has_android()) {
      if (android_ != NULL) android_->::Serializer::ImageCompressInfo::Clear();
    }
    if (has_imagedata()) {
      if (imagedata_ != &::google::protobuf::internal::kEmptyString) {
        imagedata_->clear();
      }
    }
    width_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    height_ = 0;
    last_write_time_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TextureInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string path = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_guid;
        break;
      }
      
      // optional string guid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_wrapMode;
        break;
      }
      
      // optional int32 wrapMode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_wrapMode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wrapmode_)));
          set_has_wrapmode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_Editor;
        break;
      }
      
      // optional .Serializer.ImageCompressInfo Editor = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Editor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_editor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_IOS;
        break;
      }
      
      // optional .Serializer.ImageCompressInfo IOS = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_IOS:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ios()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_Android;
        break;
      }
      
      // optional .Serializer.ImageCompressInfo Android = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Android:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_android()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_imageData;
        break;
      }
      
      // optional bytes imageData = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_imageData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_imagedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_width;
        break;
      }
      
      // optional int32 width = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_height;
        break;
      }
      
      // optional int32 height = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(81)) goto parse_last_write_time;
        break;
      }
      
      // optional fixed64 last_write_time = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_last_write_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &last_write_time_)));
          set_has_last_write_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TextureInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->path(), output);
  }
  
  // optional string guid = 2;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->guid(), output);
  }
  
  // optional int32 wrapMode = 3;
  if (has_wrapmode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->wrapmode(), output);
  }
  
  // optional .Serializer.ImageCompressInfo Editor = 4;
  if (has_editor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->editor(), output);
  }
  
  // optional .Serializer.ImageCompressInfo IOS = 5;
  if (has_ios()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->ios(), output);
  }
  
  // optional .Serializer.ImageCompressInfo Android = 6;
  if (has_android()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->android(), output);
  }
  
  // optional bytes imageData = 7;
  if (has_imagedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->imagedata(), output);
  }
  
  // optional int32 width = 8;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->width(), output);
  }
  
  // optional int32 height = 9;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->height(), output);
  }
  
  // optional fixed64 last_write_time = 10;
  if (has_last_write_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(10, this->last_write_time(), output);
  }
  
}

int TextureInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
    // optional string guid = 2;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guid());
    }
    
    // optional int32 wrapMode = 3;
    if (has_wrapmode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wrapmode());
    }
    
    // optional .Serializer.ImageCompressInfo Editor = 4;
    if (has_editor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->editor());
    }
    
    // optional .Serializer.ImageCompressInfo IOS = 5;
    if (has_ios()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ios());
    }
    
    // optional .Serializer.ImageCompressInfo Android = 6;
    if (has_android()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->android());
    }
    
    // optional bytes imageData = 7;
    if (has_imagedata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->imagedata());
    }
    
    // optional int32 width = 8;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 height = 9;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }
    
    // optional fixed64 last_write_time = 10;
    if (has_last_write_time()) {
      total_size += 1 + 8;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TextureInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TextureInfo*>(&from));
}

void TextureInfo::MergeFrom(const TextureInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_guid()) {
      set_guid(from.guid());
    }
    if (from.has_wrapmode()) {
      set_wrapmode(from.wrapmode());
    }
    if (from.has_editor()) {
      mutable_editor()->::Serializer::ImageCompressInfo::MergeFrom(from.editor());
    }
    if (from.has_ios()) {
      mutable_ios()->::Serializer::ImageCompressInfo::MergeFrom(from.ios());
    }
    if (from.has_android()) {
      mutable_android()->::Serializer::ImageCompressInfo::MergeFrom(from.android());
    }
    if (from.has_imagedata()) {
      set_imagedata(from.imagedata());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_last_write_time()) {
      set_last_write_time(from.last_write_time());
    }
  }
}

void TextureInfo::CopyFrom(const TextureInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextureInfo::IsInitialized() const {
  
  return true;
}

void TextureInfo::Swap(TextureInfo* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    std::swap(guid_, other->guid_);
    std::swap(wrapmode_, other->wrapmode_);
    std::swap(editor_, other->editor_);
    std::swap(ios_, other->ios_);
    std::swap(android_, other->android_);
    std::swap(imagedata_, other->imagedata_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(last_write_time_, other->last_write_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TextureInfo::GetTypeName() const {
  return "Serializer.TextureInfo";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)
