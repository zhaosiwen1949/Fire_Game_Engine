// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "TextureAtlas.serializer.h"

#include <algorithm>

#include "once.h"
#include "coded_stream.h"
#include "wire_format_lite_inl.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

void protobuf_ShutdownFile_TextureAtlas_2eproto() {
  delete ImageTile::default_instance_;
  delete TextureAtlas::default_instance_;
  delete AtlasInfo::default_instance_;
}

void protobuf_AddDesc_TextureAtlas_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Serializer::protobuf_AddDesc_TextureInfo_2eproto();
  ImageTile::default_instance_ = new ImageTile();
  TextureAtlas::default_instance_ = new TextureAtlas();
  AtlasInfo::default_instance_ = new AtlasInfo();
  ImageTile::default_instance_->InitAsDefaultInstance();
  TextureAtlas::default_instance_->InitAsDefaultInstance();
  AtlasInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_TextureAtlas_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_TextureAtlas_2eproto {
  StaticDescriptorInitializer_TextureAtlas_2eproto() {
    protobuf_AddDesc_TextureAtlas_2eproto();
  }
} static_descriptor_initializer_TextureAtlas_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int ImageTile::kNameFieldNumber;
const int ImageTile::kXFieldNumber;
const int ImageTile::kYFieldNumber;
const int ImageTile::kWidthFieldNumber;
const int ImageTile::kHeightFieldNumber;
const int ImageTile::kTextureAtlasPathFieldNumber;
const int ImageTile::kTexcoordLeftFieldNumber;
const int ImageTile::kTexcoordTopFieldNumber;
const int ImageTile::kTexcoordRightFieldNumber;
const int ImageTile::kTexcoordBottomFieldNumber;
const int ImageTile::kRotatedFieldNumber;
#endif  // !_MSC_VER

ImageTile::ImageTile()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ImageTile::InitAsDefaultInstance() {
}

ImageTile::ImageTile(const ImageTile& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ImageTile::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  x_ = 0;
  y_ = 0;
  width_ = 0;
  height_ = 0;
  textureatlaspath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  texcoordleft_ = 0;
  texcoordtop_ = 0;
  texcoordright_ = 0;
  texcoordbottom_ = 0;
  rotated_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImageTile::~ImageTile() {
  SharedDtor();
}

void ImageTile::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (textureatlaspath_ != &::google::protobuf::internal::kEmptyString) {
    delete textureatlaspath_;
  }
  if (this != default_instance_) {
  }
}

void ImageTile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageTile& ImageTile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureAtlas_2eproto();  return *default_instance_;
}

ImageTile* ImageTile::default_instance_ = NULL;

ImageTile* ImageTile::New() const {
  return new ImageTile;
}

void ImageTile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    x_ = 0;
    y_ = 0;
    width_ = 0;
    height_ = 0;
    if (has_textureatlaspath()) {
      if (textureatlaspath_ != &::google::protobuf::internal::kEmptyString) {
        textureatlaspath_->clear();
      }
    }
    texcoordleft_ = 0;
    texcoordtop_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    texcoordright_ = 0;
    texcoordbottom_ = 0;
    rotated_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ImageTile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }
      
      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }
      
      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_width;
        break;
      }
      
      // optional int32 width = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_height;
        break;
      }
      
      // optional int32 height = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_textureAtlasPath;
        break;
      }
      
      // optional string textureAtlasPath = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_textureAtlasPath:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_textureatlaspath()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_texcoordLeft;
        break;
      }
      
      // optional float texcoordLeft = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_texcoordLeft:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &texcoordleft_)));
          set_has_texcoordleft();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_texcoordTop;
        break;
      }
      
      // optional float texcoordTop = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_texcoordTop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &texcoordtop_)));
          set_has_texcoordtop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_texcoordRight;
        break;
      }
      
      // optional float texcoordRight = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_texcoordRight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &texcoordright_)));
          set_has_texcoordright();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_texcoordBottom;
        break;
      }
      
      // optional float texcoordBottom = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_texcoordBottom:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &texcoordbottom_)));
          set_has_texcoordbottom();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_rotated;
        break;
      }
      
      // optional bool rotated = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rotated:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rotated_)));
          set_has_rotated();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImageTile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }
  
  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }
  
  // optional int32 width = 4;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->width(), output);
  }
  
  // optional int32 height = 5;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->height(), output);
  }
  
  // optional string textureAtlasPath = 6;
  if (has_textureatlaspath()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->textureatlaspath(), output);
  }
  
  // optional float texcoordLeft = 7;
  if (has_texcoordleft()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->texcoordleft(), output);
  }
  
  // optional float texcoordTop = 8;
  if (has_texcoordtop()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->texcoordtop(), output);
  }
  
  // optional float texcoordRight = 9;
  if (has_texcoordright()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->texcoordright(), output);
  }
  
  // optional float texcoordBottom = 10;
  if (has_texcoordbottom()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->texcoordbottom(), output);
  }
  
  // optional bool rotated = 11;
  if (has_rotated()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->rotated(), output);
  }
  
}

int ImageTile::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }
    
    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }
    
    // optional int32 width = 4;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // optional int32 height = 5;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }
    
    // optional string textureAtlasPath = 6;
    if (has_textureatlaspath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->textureatlaspath());
    }
    
    // optional float texcoordLeft = 7;
    if (has_texcoordleft()) {
      total_size += 1 + 4;
    }
    
    // optional float texcoordTop = 8;
    if (has_texcoordtop()) {
      total_size += 1 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float texcoordRight = 9;
    if (has_texcoordright()) {
      total_size += 1 + 4;
    }
    
    // optional float texcoordBottom = 10;
    if (has_texcoordbottom()) {
      total_size += 1 + 4;
    }
    
    // optional bool rotated = 11;
    if (has_rotated()) {
      total_size += 1 + 1;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageTile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageTile*>(&from));
}

void ImageTile::MergeFrom(const ImageTile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_textureatlaspath()) {
      set_textureatlaspath(from.textureatlaspath());
    }
    if (from.has_texcoordleft()) {
      set_texcoordleft(from.texcoordleft());
    }
    if (from.has_texcoordtop()) {
      set_texcoordtop(from.texcoordtop());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_texcoordright()) {
      set_texcoordright(from.texcoordright());
    }
    if (from.has_texcoordbottom()) {
      set_texcoordbottom(from.texcoordbottom());
    }
    if (from.has_rotated()) {
      set_rotated(from.rotated());
    }
  }
}

void ImageTile::CopyFrom(const ImageTile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageTile::IsInitialized() const {
  
  return true;
}

void ImageTile::Swap(ImageTile* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(textureatlaspath_, other->textureatlaspath_);
    std::swap(texcoordleft_, other->texcoordleft_);
    std::swap(texcoordtop_, other->texcoordtop_);
    std::swap(texcoordright_, other->texcoordright_);
    std::swap(texcoordbottom_, other->texcoordbottom_);
    std::swap(rotated_, other->rotated_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ImageTile::GetTypeName() const {
  return "Serializer.ImageTile";
}


// ===================================================================

#ifndef _MSC_VER
const int TextureAtlas::kPathFieldNumber;
const int TextureAtlas::kImageTilesFieldNumber;
const int TextureAtlas::kTextureInfoFieldNumber;
const int TextureAtlas::kImportedAtlasFieldNumber;
const int TextureAtlas::kGuidFieldNumber;
#endif  // !_MSC_VER

TextureAtlas::TextureAtlas()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TextureAtlas::InitAsDefaultInstance() {
  textureinfo_ = const_cast< ::Serializer::TextureInfo*>(&::Serializer::TextureInfo::default_instance());
}

TextureAtlas::TextureAtlas(const TextureAtlas& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TextureAtlas::SharedCtor() {
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  textureinfo_ = NULL;
  importedatlas_ = false;
  guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TextureAtlas::~TextureAtlas() {
  SharedDtor();
}

void TextureAtlas::SharedDtor() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (this != default_instance_) {
    delete textureinfo_;
  }
}

void TextureAtlas::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TextureAtlas& TextureAtlas::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureAtlas_2eproto();  return *default_instance_;
}

TextureAtlas* TextureAtlas::default_instance_ = NULL;

TextureAtlas* TextureAtlas::New() const {
  return new TextureAtlas;
}

void TextureAtlas::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    if (has_textureinfo()) {
      if (textureinfo_ != NULL) textureinfo_->::Serializer::TextureInfo::Clear();
    }
    importedatlas_ = false;
    if (has_guid()) {
      if (guid_ != &::google::protobuf::internal::kEmptyString) {
        guid_->clear();
      }
    }
  }
  imagetiles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TextureAtlas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string path = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_imageTiles;
        break;
      }
      
      // repeated .Serializer.ImageTile imageTiles = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_imageTiles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_imagetiles()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_imageTiles;
        if (input->ExpectTag(26)) goto parse_textureInfo;
        break;
      }
      
      // optional .Serializer.TextureInfo textureInfo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_textureInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_textureinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_importedAtlas;
        break;
      }
      
      // optional bool importedAtlas = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_importedAtlas:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &importedatlas_)));
          set_has_importedatlas();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_guid;
        break;
      }
      
      // optional string guid = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TextureAtlas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->path(), output);
  }
  
  // repeated .Serializer.ImageTile imageTiles = 2;
  for (int i = 0; i < this->imagetiles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->imagetiles(i), output);
  }
  
  // optional .Serializer.TextureInfo textureInfo = 3;
  if (has_textureinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->textureinfo(), output);
  }
  
  // optional bool importedAtlas = 4;
  if (has_importedatlas()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->importedatlas(), output);
  }
  
  // optional string guid = 5;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->guid(), output);
  }
  
}

int TextureAtlas::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
    // optional .Serializer.TextureInfo textureInfo = 3;
    if (has_textureinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->textureinfo());
    }
    
    // optional bool importedAtlas = 4;
    if (has_importedatlas()) {
      total_size += 1 + 1;
    }
    
    // optional string guid = 5;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guid());
    }
    
  }
  // repeated .Serializer.ImageTile imageTiles = 2;
  total_size += 1 * this->imagetiles_size();
  for (int i = 0; i < this->imagetiles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->imagetiles(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TextureAtlas::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TextureAtlas*>(&from));
}

void TextureAtlas::MergeFrom(const TextureAtlas& from) {
  GOOGLE_CHECK_NE(&from, this);
  imagetiles_.MergeFrom(from.imagetiles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_textureinfo()) {
      mutable_textureinfo()->::Serializer::TextureInfo::MergeFrom(from.textureinfo());
    }
    if (from.has_importedatlas()) {
      set_importedatlas(from.importedatlas());
    }
    if (from.has_guid()) {
      set_guid(from.guid());
    }
  }
}

void TextureAtlas::CopyFrom(const TextureAtlas& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextureAtlas::IsInitialized() const {
  
  return true;
}

void TextureAtlas::Swap(TextureAtlas* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    imagetiles_.Swap(&other->imagetiles_);
    std::swap(textureinfo_, other->textureinfo_);
    std::swap(importedatlas_, other->importedatlas_);
    std::swap(guid_, other->guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TextureAtlas::GetTypeName() const {
  return "Serializer.TextureAtlas";
}


// ===================================================================

#ifndef _MSC_VER
const int AtlasInfo::kPathFieldNumber;
const int AtlasInfo::kImageTilesFieldNumber;
const int AtlasInfo::kImportedAtlasFieldNumber;
const int AtlasInfo::kGuidFieldNumber;
const int AtlasInfo::kLastWriteTimeFieldNumber;
const int AtlasInfo::kIosFieldNumber;
const int AtlasInfo::kAndroidFieldNumber;
const int AtlasInfo::kWindowsFieldNumber;
#endif  // !_MSC_VER

AtlasInfo::AtlasInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AtlasInfo::InitAsDefaultInstance() {
  ios_ = const_cast< ::Serializer::ImageCompressInfo*>(&::Serializer::ImageCompressInfo::default_instance());
  android_ = const_cast< ::Serializer::ImageCompressInfo*>(&::Serializer::ImageCompressInfo::default_instance());
  windows_ = const_cast< ::Serializer::ImageCompressInfo*>(&::Serializer::ImageCompressInfo::default_instance());
}

AtlasInfo::AtlasInfo(const AtlasInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AtlasInfo::SharedCtor() {
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  importedatlas_ = false;
  guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  last_write_time_ = GOOGLE_ULONGLONG(0);
  ios_ = NULL;
  android_ = NULL;
  windows_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AtlasInfo::~AtlasInfo() {
  SharedDtor();
}

void AtlasInfo::SharedDtor() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (this != default_instance_) {
    delete ios_;
    delete android_;
    delete windows_;
  }
}

void AtlasInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AtlasInfo& AtlasInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_TextureAtlas_2eproto();  return *default_instance_;
}

AtlasInfo* AtlasInfo::default_instance_ = NULL;

AtlasInfo* AtlasInfo::New() const {
  return new AtlasInfo;
}

void AtlasInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    importedatlas_ = false;
    if (has_guid()) {
      if (guid_ != &::google::protobuf::internal::kEmptyString) {
        guid_->clear();
      }
    }
    last_write_time_ = GOOGLE_ULONGLONG(0);
    if (has_ios()) {
      if (ios_ != NULL) ios_->::Serializer::ImageCompressInfo::Clear();
    }
    if (has_android()) {
      if (android_ != NULL) android_->::Serializer::ImageCompressInfo::Clear();
    }
    if (has_windows()) {
      if (windows_ != NULL) windows_->::Serializer::ImageCompressInfo::Clear();
    }
  }
  imagetiles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AtlasInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string path = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_imageTiles;
        break;
      }
      
      // repeated .Serializer.ImageTile imageTiles = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_imageTiles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_imagetiles()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_imageTiles;
        if (input->ExpectTag(24)) goto parse_importedAtlas;
        break;
      }
      
      // optional bool importedAtlas = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_importedAtlas:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &importedatlas_)));
          set_has_importedatlas();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_guid;
        break;
      }
      
      // optional string guid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_last_write_time;
        break;
      }
      
      // optional fixed64 last_write_time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_last_write_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &last_write_time_)));
          set_has_last_write_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ios;
        break;
      }
      
      // optional .Serializer.ImageCompressInfo ios = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ios:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ios()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_android;
        break;
      }
      
      // optional .Serializer.ImageCompressInfo android = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_android:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_android()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_windows;
        break;
      }
      
      // optional .Serializer.ImageCompressInfo windows = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_windows:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_windows()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AtlasInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->path(), output);
  }
  
  // repeated .Serializer.ImageTile imageTiles = 2;
  for (int i = 0; i < this->imagetiles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->imagetiles(i), output);
  }
  
  // optional bool importedAtlas = 3;
  if (has_importedatlas()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->importedatlas(), output);
  }
  
  // optional string guid = 4;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->guid(), output);
  }
  
  // optional fixed64 last_write_time = 5;
  if (has_last_write_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(5, this->last_write_time(), output);
  }
  
  // optional .Serializer.ImageCompressInfo ios = 6;
  if (has_ios()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->ios(), output);
  }
  
  // optional .Serializer.ImageCompressInfo android = 7;
  if (has_android()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->android(), output);
  }
  
  // optional .Serializer.ImageCompressInfo windows = 8;
  if (has_windows()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->windows(), output);
  }
  
}

int AtlasInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
    // optional bool importedAtlas = 3;
    if (has_importedatlas()) {
      total_size += 1 + 1;
    }
    
    // optional string guid = 4;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guid());
    }
    
    // optional fixed64 last_write_time = 5;
    if (has_last_write_time()) {
      total_size += 1 + 8;
    }
    
    // optional .Serializer.ImageCompressInfo ios = 6;
    if (has_ios()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ios());
    }
    
    // optional .Serializer.ImageCompressInfo android = 7;
    if (has_android()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->android());
    }
    
    // optional .Serializer.ImageCompressInfo windows = 8;
    if (has_windows()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->windows());
    }
    
  }
  // repeated .Serializer.ImageTile imageTiles = 2;
  total_size += 1 * this->imagetiles_size();
  for (int i = 0; i < this->imagetiles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->imagetiles(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AtlasInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AtlasInfo*>(&from));
}

void AtlasInfo::MergeFrom(const AtlasInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  imagetiles_.MergeFrom(from.imagetiles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_importedatlas()) {
      set_importedatlas(from.importedatlas());
    }
    if (from.has_guid()) {
      set_guid(from.guid());
    }
    if (from.has_last_write_time()) {
      set_last_write_time(from.last_write_time());
    }
    if (from.has_ios()) {
      mutable_ios()->::Serializer::ImageCompressInfo::MergeFrom(from.ios());
    }
    if (from.has_android()) {
      mutable_android()->::Serializer::ImageCompressInfo::MergeFrom(from.android());
    }
    if (from.has_windows()) {
      mutable_windows()->::Serializer::ImageCompressInfo::MergeFrom(from.windows());
    }
  }
}

void AtlasInfo::CopyFrom(const AtlasInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AtlasInfo::IsInitialized() const {
  
  return true;
}

void AtlasInfo::Swap(AtlasInfo* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    imagetiles_.Swap(&other->imagetiles_);
    std::swap(importedatlas_, other->importedatlas_);
    std::swap(guid_, other->guid_);
    std::swap(last_write_time_, other->last_write_time_);
    std::swap(ios_, other->ios_);
    std::swap(android_, other->android_);
    std::swap(windows_, other->windows_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AtlasInfo::GetTypeName() const {
  return "Serializer.AtlasInfo";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)
