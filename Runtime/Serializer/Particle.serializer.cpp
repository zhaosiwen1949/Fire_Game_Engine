// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Particle.serializer.h"

#include <algorithm>

#include "once.h"
#include "coded_stream.h"
#include "wire_format_lite_inl.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

void protobuf_ShutdownFile_Particle_2eproto() {
  delete OldParticleEmitter::default_instance_;
  delete BoxParticleEmitter::default_instance_;
  delete DiscParticleEmitter::default_instance_;
  delete Particle::default_instance_;
}

void protobuf_AddDesc_Particle_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Serializer::protobuf_AddDesc_Color_2eproto();
  ::Serializer::protobuf_AddDesc_Vector_2eproto();
  OldParticleEmitter::default_instance_ = new OldParticleEmitter();
  BoxParticleEmitter::default_instance_ = new BoxParticleEmitter();
  DiscParticleEmitter::default_instance_ = new DiscParticleEmitter();
  Particle::default_instance_ = new Particle();
  OldParticleEmitter::default_instance_->InitAsDefaultInstance();
  BoxParticleEmitter::default_instance_->InitAsDefaultInstance();
  DiscParticleEmitter::default_instance_->InitAsDefaultInstance();
  Particle::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Particle_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Particle_2eproto {
  StaticDescriptorInitializer_Particle_2eproto() {
    protobuf_AddDesc_Particle_2eproto();
  }
} static_descriptor_initializer_Particle_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int OldParticleEmitter::kMaxParticleCountFieldNumber;
const int OldParticleEmitter::kMaxDelayTimeFieldNumber;
const int OldParticleEmitter::kMaxLifeTimeFieldNumber;
const int OldParticleEmitter::kMinStartColorFieldNumber;
const int OldParticleEmitter::kMaxStartColorFieldNumber;
const int OldParticleEmitter::kMinEmitRangeFieldNumber;
const int OldParticleEmitter::kMaxEmitRangeFieldNumber;
const int OldParticleEmitter::kMinSpeedFieldNumber;
const int OldParticleEmitter::kMaxSpeedFieldNumber;
#endif  // !_MSC_VER

OldParticleEmitter::OldParticleEmitter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OldParticleEmitter::InitAsDefaultInstance() {
  min_start_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
  max_start_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
  min_emit_range_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  max_emit_range_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  min_speed_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  max_speed_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
}

OldParticleEmitter::OldParticleEmitter(const OldParticleEmitter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OldParticleEmitter::SharedCtor() {
  _cached_size_ = 0;
  max_particle_count_ = 0;
  max_delay_time_ = 0;
  max_life_time_ = 0;
  min_start_color_ = NULL;
  max_start_color_ = NULL;
  min_emit_range_ = NULL;
  max_emit_range_ = NULL;
  min_speed_ = NULL;
  max_speed_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OldParticleEmitter::~OldParticleEmitter() {
  SharedDtor();
}

void OldParticleEmitter::SharedDtor() {
  if (this != default_instance_) {
    delete min_start_color_;
    delete max_start_color_;
    delete min_emit_range_;
    delete max_emit_range_;
    delete min_speed_;
    delete max_speed_;
  }
}

void OldParticleEmitter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OldParticleEmitter& OldParticleEmitter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Particle_2eproto();  return *default_instance_;
}

OldParticleEmitter* OldParticleEmitter::default_instance_ = NULL;

OldParticleEmitter* OldParticleEmitter::New() const {
  return new OldParticleEmitter;
}

void OldParticleEmitter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    max_particle_count_ = 0;
    max_delay_time_ = 0;
    max_life_time_ = 0;
    if (has_min_start_color()) {
      if (min_start_color_ != NULL) min_start_color_->::Serializer::Color4B::Clear();
    }
    if (has_max_start_color()) {
      if (max_start_color_ != NULL) max_start_color_->::Serializer::Color4B::Clear();
    }
    if (has_min_emit_range()) {
      if (min_emit_range_ != NULL) min_emit_range_->::Serializer::Vector4f::Clear();
    }
    if (has_max_emit_range()) {
      if (max_emit_range_ != NULL) max_emit_range_->::Serializer::Vector4f::Clear();
    }
    if (has_min_speed()) {
      if (min_speed_ != NULL) min_speed_->::Serializer::Vector4f::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_max_speed()) {
      if (max_speed_ != NULL) max_speed_->::Serializer::Vector4f::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OldParticleEmitter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 max_particle_count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_particle_count_)));
          set_has_max_particle_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_max_delay_time;
        break;
      }
      
      // optional float max_delay_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_delay_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_delay_time_)));
          set_has_max_delay_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_max_life_time;
        break;
      }
      
      // optional float max_life_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_life_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_life_time_)));
          set_has_max_life_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_min_start_color;
        break;
      }
      
      // optional .Serializer.Color4B min_start_color = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_start_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_start_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_max_start_color;
        break;
      }
      
      // optional .Serializer.Color4B max_start_color = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_start_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_start_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_min_emit_range;
        break;
      }
      
      // optional .Serializer.Vector4f min_emit_range = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_emit_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_emit_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_max_emit_range;
        break;
      }
      
      // optional .Serializer.Vector4f max_emit_range = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_emit_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_emit_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_min_speed;
        break;
      }
      
      // optional .Serializer.Vector4f min_speed = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_speed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_max_speed;
        break;
      }
      
      // optional .Serializer.Vector4f max_speed = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_speed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OldParticleEmitter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 max_particle_count = 1;
  if (has_max_particle_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->max_particle_count(), output);
  }
  
  // optional float max_delay_time = 2;
  if (has_max_delay_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->max_delay_time(), output);
  }
  
  // optional float max_life_time = 3;
  if (has_max_life_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->max_life_time(), output);
  }
  
  // optional .Serializer.Color4B min_start_color = 4;
  if (has_min_start_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->min_start_color(), output);
  }
  
  // optional .Serializer.Color4B max_start_color = 5;
  if (has_max_start_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->max_start_color(), output);
  }
  
  // optional .Serializer.Vector4f min_emit_range = 6;
  if (has_min_emit_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->min_emit_range(), output);
  }
  
  // optional .Serializer.Vector4f max_emit_range = 7;
  if (has_max_emit_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->max_emit_range(), output);
  }
  
  // optional .Serializer.Vector4f min_speed = 8;
  if (has_min_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->min_speed(), output);
  }
  
  // optional .Serializer.Vector4f max_speed = 9;
  if (has_max_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->max_speed(), output);
  }
  
}

int OldParticleEmitter::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 max_particle_count = 1;
    if (has_max_particle_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_particle_count());
    }
    
    // optional float max_delay_time = 2;
    if (has_max_delay_time()) {
      total_size += 1 + 4;
    }
    
    // optional float max_life_time = 3;
    if (has_max_life_time()) {
      total_size += 1 + 4;
    }
    
    // optional .Serializer.Color4B min_start_color = 4;
    if (has_min_start_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_start_color());
    }
    
    // optional .Serializer.Color4B max_start_color = 5;
    if (has_max_start_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_start_color());
    }
    
    // optional .Serializer.Vector4f min_emit_range = 6;
    if (has_min_emit_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_emit_range());
    }
    
    // optional .Serializer.Vector4f max_emit_range = 7;
    if (has_max_emit_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_emit_range());
    }
    
    // optional .Serializer.Vector4f min_speed = 8;
    if (has_min_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_speed());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .Serializer.Vector4f max_speed = 9;
    if (has_max_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_speed());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OldParticleEmitter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OldParticleEmitter*>(&from));
}

void OldParticleEmitter::MergeFrom(const OldParticleEmitter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_particle_count()) {
      set_max_particle_count(from.max_particle_count());
    }
    if (from.has_max_delay_time()) {
      set_max_delay_time(from.max_delay_time());
    }
    if (from.has_max_life_time()) {
      set_max_life_time(from.max_life_time());
    }
    if (from.has_min_start_color()) {
      mutable_min_start_color()->::Serializer::Color4B::MergeFrom(from.min_start_color());
    }
    if (from.has_max_start_color()) {
      mutable_max_start_color()->::Serializer::Color4B::MergeFrom(from.max_start_color());
    }
    if (from.has_min_emit_range()) {
      mutable_min_emit_range()->::Serializer::Vector4f::MergeFrom(from.min_emit_range());
    }
    if (from.has_max_emit_range()) {
      mutable_max_emit_range()->::Serializer::Vector4f::MergeFrom(from.max_emit_range());
    }
    if (from.has_min_speed()) {
      mutable_min_speed()->::Serializer::Vector4f::MergeFrom(from.min_speed());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_max_speed()) {
      mutable_max_speed()->::Serializer::Vector4f::MergeFrom(from.max_speed());
    }
  }
}

void OldParticleEmitter::CopyFrom(const OldParticleEmitter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OldParticleEmitter::IsInitialized() const {
  
  if (has_min_start_color()) {
    if (!this->min_start_color().IsInitialized()) return false;
  }
  if (has_max_start_color()) {
    if (!this->max_start_color().IsInitialized()) return false;
  }
  if (has_min_emit_range()) {
    if (!this->min_emit_range().IsInitialized()) return false;
  }
  if (has_max_emit_range()) {
    if (!this->max_emit_range().IsInitialized()) return false;
  }
  if (has_min_speed()) {
    if (!this->min_speed().IsInitialized()) return false;
  }
  if (has_max_speed()) {
    if (!this->max_speed().IsInitialized()) return false;
  }
  return true;
}

void OldParticleEmitter::Swap(OldParticleEmitter* other) {
  if (other != this) {
    std::swap(max_particle_count_, other->max_particle_count_);
    std::swap(max_delay_time_, other->max_delay_time_);
    std::swap(max_life_time_, other->max_life_time_);
    std::swap(min_start_color_, other->min_start_color_);
    std::swap(max_start_color_, other->max_start_color_);
    std::swap(min_emit_range_, other->min_emit_range_);
    std::swap(max_emit_range_, other->max_emit_range_);
    std::swap(min_speed_, other->min_speed_);
    std::swap(max_speed_, other->max_speed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OldParticleEmitter::GetTypeName() const {
  return "Serializer.OldParticleEmitter";
}


// ===================================================================

#ifndef _MSC_VER
const int BoxParticleEmitter::kMinParticleCountPerSecondFieldNumber;
const int BoxParticleEmitter::kMaxParticleCountPerSecondFieldNumber;
const int BoxParticleEmitter::kMinDelayTimeFieldNumber;
const int BoxParticleEmitter::kMinLifeTimeFieldNumber;
const int BoxParticleEmitter::kMaxDelayTimeFieldNumber;
const int BoxParticleEmitter::kMaxLifeTimeFieldNumber;
const int BoxParticleEmitter::kMinStartColorFieldNumber;
const int BoxParticleEmitter::kMaxStartColorFieldNumber;
const int BoxParticleEmitter::kMinEmitRangeFieldNumber;
const int BoxParticleEmitter::kMaxEmitRangeFieldNumber;
const int BoxParticleEmitter::kMinSpeedFieldNumber;
const int BoxParticleEmitter::kMaxSpeedFieldNumber;
const int BoxParticleEmitter::kUseGravityFieldNumber;
const int BoxParticleEmitter::kMinEndColorFieldNumber;
const int BoxParticleEmitter::kMaxEndColorFieldNumber;
const int BoxParticleEmitter::kImageGuidFieldNumber;
#endif  // !_MSC_VER

BoxParticleEmitter::BoxParticleEmitter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BoxParticleEmitter::InitAsDefaultInstance() {
  min_start_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
  max_start_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
  min_emit_range_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  max_emit_range_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  min_speed_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  max_speed_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  min_end_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
  max_end_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
}

BoxParticleEmitter::BoxParticleEmitter(const BoxParticleEmitter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BoxParticleEmitter::SharedCtor() {
  _cached_size_ = 0;
  min_particle_count_per_second_ = 0;
  max_particle_count_per_second_ = 0;
  min_delay_time_ = 0;
  min_life_time_ = 0;
  max_delay_time_ = 0;
  max_life_time_ = 0;
  min_start_color_ = NULL;
  max_start_color_ = NULL;
  min_emit_range_ = NULL;
  max_emit_range_ = NULL;
  min_speed_ = NULL;
  max_speed_ = NULL;
  use_gravity_ = false;
  min_end_color_ = NULL;
  max_end_color_ = NULL;
  image_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BoxParticleEmitter::~BoxParticleEmitter() {
  SharedDtor();
}

void BoxParticleEmitter::SharedDtor() {
  if (image_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete image_guid_;
  }
  if (this != default_instance_) {
    delete min_start_color_;
    delete max_start_color_;
    delete min_emit_range_;
    delete max_emit_range_;
    delete min_speed_;
    delete max_speed_;
    delete min_end_color_;
    delete max_end_color_;
  }
}

void BoxParticleEmitter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BoxParticleEmitter& BoxParticleEmitter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Particle_2eproto();  return *default_instance_;
}

BoxParticleEmitter* BoxParticleEmitter::default_instance_ = NULL;

BoxParticleEmitter* BoxParticleEmitter::New() const {
  return new BoxParticleEmitter;
}

void BoxParticleEmitter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    min_particle_count_per_second_ = 0;
    max_particle_count_per_second_ = 0;
    min_delay_time_ = 0;
    min_life_time_ = 0;
    max_delay_time_ = 0;
    max_life_time_ = 0;
    if (has_min_start_color()) {
      if (min_start_color_ != NULL) min_start_color_->::Serializer::Color4B::Clear();
    }
    if (has_max_start_color()) {
      if (max_start_color_ != NULL) max_start_color_->::Serializer::Color4B::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_min_emit_range()) {
      if (min_emit_range_ != NULL) min_emit_range_->::Serializer::Vector4f::Clear();
    }
    if (has_max_emit_range()) {
      if (max_emit_range_ != NULL) max_emit_range_->::Serializer::Vector4f::Clear();
    }
    if (has_min_speed()) {
      if (min_speed_ != NULL) min_speed_->::Serializer::Vector4f::Clear();
    }
    if (has_max_speed()) {
      if (max_speed_ != NULL) max_speed_->::Serializer::Vector4f::Clear();
    }
    use_gravity_ = false;
    if (has_min_end_color()) {
      if (min_end_color_ != NULL) min_end_color_->::Serializer::Color4B::Clear();
    }
    if (has_max_end_color()) {
      if (max_end_color_ != NULL) max_end_color_->::Serializer::Color4B::Clear();
    }
    if (has_image_guid()) {
      if (image_guid_ != &::google::protobuf::internal::kEmptyString) {
        image_guid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BoxParticleEmitter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 min_particle_count_per_second = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_particle_count_per_second_)));
          set_has_min_particle_count_per_second();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_max_particle_count_per_second;
        break;
      }
      
      // optional int32 max_particle_count_per_second = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_particle_count_per_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_particle_count_per_second_)));
          set_has_max_particle_count_per_second();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_min_delay_time;
        break;
      }
      
      // optional float min_delay_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min_delay_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_delay_time_)));
          set_has_min_delay_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_min_life_time;
        break;
      }
      
      // optional float min_life_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min_life_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_life_time_)));
          set_has_min_life_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_max_delay_time;
        break;
      }
      
      // optional float max_delay_time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_delay_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_delay_time_)));
          set_has_max_delay_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_max_life_time;
        break;
      }
      
      // optional float max_life_time = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_life_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_life_time_)));
          set_has_max_life_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_min_start_color;
        break;
      }
      
      // optional .Serializer.Color4B min_start_color = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_start_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_start_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_max_start_color;
        break;
      }
      
      // optional .Serializer.Color4B max_start_color = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_start_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_start_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_min_emit_range;
        break;
      }
      
      // optional .Serializer.Vector4f min_emit_range = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_emit_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_emit_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_max_emit_range;
        break;
      }
      
      // optional .Serializer.Vector4f max_emit_range = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_emit_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_emit_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_min_speed;
        break;
      }
      
      // optional .Serializer.Vector4f min_speed = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_speed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_max_speed;
        break;
      }
      
      // optional .Serializer.Vector4f max_speed = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_speed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_use_gravity;
        break;
      }
      
      // optional bool use_gravity = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_use_gravity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_gravity_)));
          set_has_use_gravity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_min_end_color;
        break;
      }
      
      // optional .Serializer.Color4B min_end_color = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_end_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_end_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_max_end_color;
        break;
      }
      
      // optional .Serializer.Color4B max_end_color = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_end_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_end_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_image_guid;
        break;
      }
      
      // optional string image_guid = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image_guid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image_guid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BoxParticleEmitter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 min_particle_count_per_second = 1;
  if (has_min_particle_count_per_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->min_particle_count_per_second(), output);
  }
  
  // optional int32 max_particle_count_per_second = 2;
  if (has_max_particle_count_per_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_particle_count_per_second(), output);
  }
  
  // optional float min_delay_time = 3;
  if (has_min_delay_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->min_delay_time(), output);
  }
  
  // optional float min_life_time = 4;
  if (has_min_life_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->min_life_time(), output);
  }
  
  // optional float max_delay_time = 5;
  if (has_max_delay_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->max_delay_time(), output);
  }
  
  // optional float max_life_time = 6;
  if (has_max_life_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->max_life_time(), output);
  }
  
  // optional .Serializer.Color4B min_start_color = 7;
  if (has_min_start_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->min_start_color(), output);
  }
  
  // optional .Serializer.Color4B max_start_color = 8;
  if (has_max_start_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->max_start_color(), output);
  }
  
  // optional .Serializer.Vector4f min_emit_range = 9;
  if (has_min_emit_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->min_emit_range(), output);
  }
  
  // optional .Serializer.Vector4f max_emit_range = 10;
  if (has_max_emit_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->max_emit_range(), output);
  }
  
  // optional .Serializer.Vector4f min_speed = 11;
  if (has_min_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->min_speed(), output);
  }
  
  // optional .Serializer.Vector4f max_speed = 12;
  if (has_max_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->max_speed(), output);
  }
  
  // optional bool use_gravity = 13;
  if (has_use_gravity()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->use_gravity(), output);
  }
  
  // optional .Serializer.Color4B min_end_color = 14;
  if (has_min_end_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->min_end_color(), output);
  }
  
  // optional .Serializer.Color4B max_end_color = 15;
  if (has_max_end_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->max_end_color(), output);
  }
  
  // optional string image_guid = 16;
  if (has_image_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->image_guid(), output);
  }
  
}

int BoxParticleEmitter::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 min_particle_count_per_second = 1;
    if (has_min_particle_count_per_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min_particle_count_per_second());
    }
    
    // optional int32 max_particle_count_per_second = 2;
    if (has_max_particle_count_per_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_particle_count_per_second());
    }
    
    // optional float min_delay_time = 3;
    if (has_min_delay_time()) {
      total_size += 1 + 4;
    }
    
    // optional float min_life_time = 4;
    if (has_min_life_time()) {
      total_size += 1 + 4;
    }
    
    // optional float max_delay_time = 5;
    if (has_max_delay_time()) {
      total_size += 1 + 4;
    }
    
    // optional float max_life_time = 6;
    if (has_max_life_time()) {
      total_size += 1 + 4;
    }
    
    // optional .Serializer.Color4B min_start_color = 7;
    if (has_min_start_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_start_color());
    }
    
    // optional .Serializer.Color4B max_start_color = 8;
    if (has_max_start_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_start_color());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .Serializer.Vector4f min_emit_range = 9;
    if (has_min_emit_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_emit_range());
    }
    
    // optional .Serializer.Vector4f max_emit_range = 10;
    if (has_max_emit_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_emit_range());
    }
    
    // optional .Serializer.Vector4f min_speed = 11;
    if (has_min_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_speed());
    }
    
    // optional .Serializer.Vector4f max_speed = 12;
    if (has_max_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_speed());
    }
    
    // optional bool use_gravity = 13;
    if (has_use_gravity()) {
      total_size += 1 + 1;
    }
    
    // optional .Serializer.Color4B min_end_color = 14;
    if (has_min_end_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_end_color());
    }
    
    // optional .Serializer.Color4B max_end_color = 15;
    if (has_max_end_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_end_color());
    }
    
    // optional string image_guid = 16;
    if (has_image_guid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->image_guid());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BoxParticleEmitter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BoxParticleEmitter*>(&from));
}

void BoxParticleEmitter::MergeFrom(const BoxParticleEmitter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_min_particle_count_per_second()) {
      set_min_particle_count_per_second(from.min_particle_count_per_second());
    }
    if (from.has_max_particle_count_per_second()) {
      set_max_particle_count_per_second(from.max_particle_count_per_second());
    }
    if (from.has_min_delay_time()) {
      set_min_delay_time(from.min_delay_time());
    }
    if (from.has_min_life_time()) {
      set_min_life_time(from.min_life_time());
    }
    if (from.has_max_delay_time()) {
      set_max_delay_time(from.max_delay_time());
    }
    if (from.has_max_life_time()) {
      set_max_life_time(from.max_life_time());
    }
    if (from.has_min_start_color()) {
      mutable_min_start_color()->::Serializer::Color4B::MergeFrom(from.min_start_color());
    }
    if (from.has_max_start_color()) {
      mutable_max_start_color()->::Serializer::Color4B::MergeFrom(from.max_start_color());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_min_emit_range()) {
      mutable_min_emit_range()->::Serializer::Vector4f::MergeFrom(from.min_emit_range());
    }
    if (from.has_max_emit_range()) {
      mutable_max_emit_range()->::Serializer::Vector4f::MergeFrom(from.max_emit_range());
    }
    if (from.has_min_speed()) {
      mutable_min_speed()->::Serializer::Vector4f::MergeFrom(from.min_speed());
    }
    if (from.has_max_speed()) {
      mutable_max_speed()->::Serializer::Vector4f::MergeFrom(from.max_speed());
    }
    if (from.has_use_gravity()) {
      set_use_gravity(from.use_gravity());
    }
    if (from.has_min_end_color()) {
      mutable_min_end_color()->::Serializer::Color4B::MergeFrom(from.min_end_color());
    }
    if (from.has_max_end_color()) {
      mutable_max_end_color()->::Serializer::Color4B::MergeFrom(from.max_end_color());
    }
    if (from.has_image_guid()) {
      set_image_guid(from.image_guid());
    }
  }
}

void BoxParticleEmitter::CopyFrom(const BoxParticleEmitter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoxParticleEmitter::IsInitialized() const {
  
  if (has_min_start_color()) {
    if (!this->min_start_color().IsInitialized()) return false;
  }
  if (has_max_start_color()) {
    if (!this->max_start_color().IsInitialized()) return false;
  }
  if (has_min_emit_range()) {
    if (!this->min_emit_range().IsInitialized()) return false;
  }
  if (has_max_emit_range()) {
    if (!this->max_emit_range().IsInitialized()) return false;
  }
  if (has_min_speed()) {
    if (!this->min_speed().IsInitialized()) return false;
  }
  if (has_max_speed()) {
    if (!this->max_speed().IsInitialized()) return false;
  }
  if (has_min_end_color()) {
    if (!this->min_end_color().IsInitialized()) return false;
  }
  if (has_max_end_color()) {
    if (!this->max_end_color().IsInitialized()) return false;
  }
  return true;
}

void BoxParticleEmitter::Swap(BoxParticleEmitter* other) {
  if (other != this) {
    std::swap(min_particle_count_per_second_, other->min_particle_count_per_second_);
    std::swap(max_particle_count_per_second_, other->max_particle_count_per_second_);
    std::swap(min_delay_time_, other->min_delay_time_);
    std::swap(min_life_time_, other->min_life_time_);
    std::swap(max_delay_time_, other->max_delay_time_);
    std::swap(max_life_time_, other->max_life_time_);
    std::swap(min_start_color_, other->min_start_color_);
    std::swap(max_start_color_, other->max_start_color_);
    std::swap(min_emit_range_, other->min_emit_range_);
    std::swap(max_emit_range_, other->max_emit_range_);
    std::swap(min_speed_, other->min_speed_);
    std::swap(max_speed_, other->max_speed_);
    std::swap(use_gravity_, other->use_gravity_);
    std::swap(min_end_color_, other->min_end_color_);
    std::swap(max_end_color_, other->max_end_color_);
    std::swap(image_guid_, other->image_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BoxParticleEmitter::GetTypeName() const {
  return "Serializer.BoxParticleEmitter";
}


// ===================================================================

#ifndef _MSC_VER
const int DiscParticleEmitter::kMinParticleCountPerSecondFieldNumber;
const int DiscParticleEmitter::kMaxParticleCountPerSecondFieldNumber;
const int DiscParticleEmitter::kMinDelayTimeFieldNumber;
const int DiscParticleEmitter::kMinLifeTimeFieldNumber;
const int DiscParticleEmitter::kMaxDelayTimeFieldNumber;
const int DiscParticleEmitter::kMaxLifeTimeFieldNumber;
const int DiscParticleEmitter::kMinColorFieldNumber;
const int DiscParticleEmitter::kMaxColorFieldNumber;
const int DiscParticleEmitter::kMinEmitRangeFieldNumber;
const int DiscParticleEmitter::kMaxEmitRangeFieldNumber;
const int DiscParticleEmitter::kMinSpeedFieldNumber;
const int DiscParticleEmitter::kMaxSpeedFieldNumber;
const int DiscParticleEmitter::kUseGravityFieldNumber;
#endif  // !_MSC_VER

DiscParticleEmitter::DiscParticleEmitter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DiscParticleEmitter::InitAsDefaultInstance() {
  min_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
  max_color_ = const_cast< ::Serializer::Color4B*>(&::Serializer::Color4B::default_instance());
  min_emit_range_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  max_emit_range_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  min_speed_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
  max_speed_ = const_cast< ::Serializer::Vector4f*>(&::Serializer::Vector4f::default_instance());
}

DiscParticleEmitter::DiscParticleEmitter(const DiscParticleEmitter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DiscParticleEmitter::SharedCtor() {
  _cached_size_ = 0;
  min_particle_count_per_second_ = 0;
  max_particle_count_per_second_ = 0;
  min_delay_time_ = 0;
  min_life_time_ = 0;
  max_delay_time_ = 0;
  max_life_time_ = 0;
  min_color_ = NULL;
  max_color_ = NULL;
  min_emit_range_ = NULL;
  max_emit_range_ = NULL;
  min_speed_ = NULL;
  max_speed_ = NULL;
  use_gravity_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiscParticleEmitter::~DiscParticleEmitter() {
  SharedDtor();
}

void DiscParticleEmitter::SharedDtor() {
  if (this != default_instance_) {
    delete min_color_;
    delete max_color_;
    delete min_emit_range_;
    delete max_emit_range_;
    delete min_speed_;
    delete max_speed_;
  }
}

void DiscParticleEmitter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DiscParticleEmitter& DiscParticleEmitter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Particle_2eproto();  return *default_instance_;
}

DiscParticleEmitter* DiscParticleEmitter::default_instance_ = NULL;

DiscParticleEmitter* DiscParticleEmitter::New() const {
  return new DiscParticleEmitter;
}

void DiscParticleEmitter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    min_particle_count_per_second_ = 0;
    max_particle_count_per_second_ = 0;
    min_delay_time_ = 0;
    min_life_time_ = 0;
    max_delay_time_ = 0;
    max_life_time_ = 0;
    if (has_min_color()) {
      if (min_color_ != NULL) min_color_->::Serializer::Color4B::Clear();
    }
    if (has_max_color()) {
      if (max_color_ != NULL) max_color_->::Serializer::Color4B::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_min_emit_range()) {
      if (min_emit_range_ != NULL) min_emit_range_->::Serializer::Vector4f::Clear();
    }
    if (has_max_emit_range()) {
      if (max_emit_range_ != NULL) max_emit_range_->::Serializer::Vector4f::Clear();
    }
    if (has_min_speed()) {
      if (min_speed_ != NULL) min_speed_->::Serializer::Vector4f::Clear();
    }
    if (has_max_speed()) {
      if (max_speed_ != NULL) max_speed_->::Serializer::Vector4f::Clear();
    }
    use_gravity_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DiscParticleEmitter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 min_particle_count_per_second = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_particle_count_per_second_)));
          set_has_min_particle_count_per_second();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_max_particle_count_per_second;
        break;
      }
      
      // optional int32 max_particle_count_per_second = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_particle_count_per_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_particle_count_per_second_)));
          set_has_max_particle_count_per_second();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_min_delay_time;
        break;
      }
      
      // optional float min_delay_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min_delay_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_delay_time_)));
          set_has_min_delay_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_min_life_time;
        break;
      }
      
      // optional float min_life_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min_life_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_life_time_)));
          set_has_min_life_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_max_delay_time;
        break;
      }
      
      // optional float max_delay_time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_delay_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_delay_time_)));
          set_has_max_delay_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_max_life_time;
        break;
      }
      
      // optional float max_life_time = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_life_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_life_time_)));
          set_has_max_life_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_min_color;
        break;
      }
      
      // optional .Serializer.Color4B min_color = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_max_color;
        break;
      }
      
      // optional .Serializer.Color4B max_color = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_min_emit_range;
        break;
      }
      
      // optional .Serializer.Vector4f min_emit_range = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_emit_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_emit_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_max_emit_range;
        break;
      }
      
      // optional .Serializer.Vector4f max_emit_range = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_emit_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_emit_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_min_speed;
        break;
      }
      
      // optional .Serializer.Vector4f min_speed = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_speed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_max_speed;
        break;
      }
      
      // optional .Serializer.Vector4f max_speed = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_speed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_use_gravity;
        break;
      }
      
      // optional bool use_gravity = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_use_gravity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_gravity_)));
          set_has_use_gravity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DiscParticleEmitter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 min_particle_count_per_second = 1;
  if (has_min_particle_count_per_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->min_particle_count_per_second(), output);
  }
  
  // optional int32 max_particle_count_per_second = 2;
  if (has_max_particle_count_per_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_particle_count_per_second(), output);
  }
  
  // optional float min_delay_time = 3;
  if (has_min_delay_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->min_delay_time(), output);
  }
  
  // optional float min_life_time = 4;
  if (has_min_life_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->min_life_time(), output);
  }
  
  // optional float max_delay_time = 5;
  if (has_max_delay_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->max_delay_time(), output);
  }
  
  // optional float max_life_time = 6;
  if (has_max_life_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->max_life_time(), output);
  }
  
  // optional .Serializer.Color4B min_color = 7;
  if (has_min_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->min_color(), output);
  }
  
  // optional .Serializer.Color4B max_color = 8;
  if (has_max_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->max_color(), output);
  }
  
  // optional .Serializer.Vector4f min_emit_range = 9;
  if (has_min_emit_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->min_emit_range(), output);
  }
  
  // optional .Serializer.Vector4f max_emit_range = 10;
  if (has_max_emit_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->max_emit_range(), output);
  }
  
  // optional .Serializer.Vector4f min_speed = 11;
  if (has_min_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->min_speed(), output);
  }
  
  // optional .Serializer.Vector4f max_speed = 12;
  if (has_max_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->max_speed(), output);
  }
  
  // optional bool use_gravity = 13;
  if (has_use_gravity()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->use_gravity(), output);
  }
  
}

int DiscParticleEmitter::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 min_particle_count_per_second = 1;
    if (has_min_particle_count_per_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min_particle_count_per_second());
    }
    
    // optional int32 max_particle_count_per_second = 2;
    if (has_max_particle_count_per_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_particle_count_per_second());
    }
    
    // optional float min_delay_time = 3;
    if (has_min_delay_time()) {
      total_size += 1 + 4;
    }
    
    // optional float min_life_time = 4;
    if (has_min_life_time()) {
      total_size += 1 + 4;
    }
    
    // optional float max_delay_time = 5;
    if (has_max_delay_time()) {
      total_size += 1 + 4;
    }
    
    // optional float max_life_time = 6;
    if (has_max_life_time()) {
      total_size += 1 + 4;
    }
    
    // optional .Serializer.Color4B min_color = 7;
    if (has_min_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_color());
    }
    
    // optional .Serializer.Color4B max_color = 8;
    if (has_max_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_color());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .Serializer.Vector4f min_emit_range = 9;
    if (has_min_emit_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_emit_range());
    }
    
    // optional .Serializer.Vector4f max_emit_range = 10;
    if (has_max_emit_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_emit_range());
    }
    
    // optional .Serializer.Vector4f min_speed = 11;
    if (has_min_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min_speed());
    }
    
    // optional .Serializer.Vector4f max_speed = 12;
    if (has_max_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max_speed());
    }
    
    // optional bool use_gravity = 13;
    if (has_use_gravity()) {
      total_size += 1 + 1;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiscParticleEmitter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DiscParticleEmitter*>(&from));
}

void DiscParticleEmitter::MergeFrom(const DiscParticleEmitter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_min_particle_count_per_second()) {
      set_min_particle_count_per_second(from.min_particle_count_per_second());
    }
    if (from.has_max_particle_count_per_second()) {
      set_max_particle_count_per_second(from.max_particle_count_per_second());
    }
    if (from.has_min_delay_time()) {
      set_min_delay_time(from.min_delay_time());
    }
    if (from.has_min_life_time()) {
      set_min_life_time(from.min_life_time());
    }
    if (from.has_max_delay_time()) {
      set_max_delay_time(from.max_delay_time());
    }
    if (from.has_max_life_time()) {
      set_max_life_time(from.max_life_time());
    }
    if (from.has_min_color()) {
      mutable_min_color()->::Serializer::Color4B::MergeFrom(from.min_color());
    }
    if (from.has_max_color()) {
      mutable_max_color()->::Serializer::Color4B::MergeFrom(from.max_color());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_min_emit_range()) {
      mutable_min_emit_range()->::Serializer::Vector4f::MergeFrom(from.min_emit_range());
    }
    if (from.has_max_emit_range()) {
      mutable_max_emit_range()->::Serializer::Vector4f::MergeFrom(from.max_emit_range());
    }
    if (from.has_min_speed()) {
      mutable_min_speed()->::Serializer::Vector4f::MergeFrom(from.min_speed());
    }
    if (from.has_max_speed()) {
      mutable_max_speed()->::Serializer::Vector4f::MergeFrom(from.max_speed());
    }
    if (from.has_use_gravity()) {
      set_use_gravity(from.use_gravity());
    }
  }
}

void DiscParticleEmitter::CopyFrom(const DiscParticleEmitter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiscParticleEmitter::IsInitialized() const {
  
  if (has_min_color()) {
    if (!this->min_color().IsInitialized()) return false;
  }
  if (has_max_color()) {
    if (!this->max_color().IsInitialized()) return false;
  }
  if (has_min_emit_range()) {
    if (!this->min_emit_range().IsInitialized()) return false;
  }
  if (has_max_emit_range()) {
    if (!this->max_emit_range().IsInitialized()) return false;
  }
  if (has_min_speed()) {
    if (!this->min_speed().IsInitialized()) return false;
  }
  if (has_max_speed()) {
    if (!this->max_speed().IsInitialized()) return false;
  }
  return true;
}

void DiscParticleEmitter::Swap(DiscParticleEmitter* other) {
  if (other != this) {
    std::swap(min_particle_count_per_second_, other->min_particle_count_per_second_);
    std::swap(max_particle_count_per_second_, other->max_particle_count_per_second_);
    std::swap(min_delay_time_, other->min_delay_time_);
    std::swap(min_life_time_, other->min_life_time_);
    std::swap(max_delay_time_, other->max_delay_time_);
    std::swap(max_life_time_, other->max_life_time_);
    std::swap(min_color_, other->min_color_);
    std::swap(max_color_, other->max_color_);
    std::swap(min_emit_range_, other->min_emit_range_);
    std::swap(max_emit_range_, other->max_emit_range_);
    std::swap(min_speed_, other->min_speed_);
    std::swap(max_speed_, other->max_speed_);
    std::swap(use_gravity_, other->use_gravity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DiscParticleEmitter::GetTypeName() const {
  return "Serializer.DiscParticleEmitter";
}


// ===================================================================

#ifndef _MSC_VER
const int Particle::kEmitterTypeFieldNumber;
const int Particle::kBoxEmitterFieldNumber;
const int Particle::kDiscEmitterFieldNumber;
const int Particle::kVersionFieldNumber;
const int Particle::kOldEmitterFieldNumber;
#endif  // !_MSC_VER

Particle::Particle()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Particle::InitAsDefaultInstance() {
  box_emitter_ = const_cast< ::Serializer::BoxParticleEmitter*>(&::Serializer::BoxParticleEmitter::default_instance());
  disc_emitter_ = const_cast< ::Serializer::DiscParticleEmitter*>(&::Serializer::DiscParticleEmitter::default_instance());
  old_emitter_ = const_cast< ::Serializer::OldParticleEmitter*>(&::Serializer::OldParticleEmitter::default_instance());
}

Particle::Particle(const Particle& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Particle::SharedCtor() {
  _cached_size_ = 0;
  emitter_type_ = 0;
  box_emitter_ = NULL;
  disc_emitter_ = NULL;
  version_ = 0;
  old_emitter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Particle::~Particle() {
  SharedDtor();
}

void Particle::SharedDtor() {
  if (this != default_instance_) {
    delete box_emitter_;
    delete disc_emitter_;
    delete old_emitter_;
  }
}

void Particle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Particle& Particle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Particle_2eproto();  return *default_instance_;
}

Particle* Particle::default_instance_ = NULL;

Particle* Particle::New() const {
  return new Particle;
}

void Particle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    emitter_type_ = 0;
    if (has_box_emitter()) {
      if (box_emitter_ != NULL) box_emitter_->::Serializer::BoxParticleEmitter::Clear();
    }
    if (has_disc_emitter()) {
      if (disc_emitter_ != NULL) disc_emitter_->::Serializer::DiscParticleEmitter::Clear();
    }
    version_ = 0;
    if (has_old_emitter()) {
      if (old_emitter_ != NULL) old_emitter_->::Serializer::OldParticleEmitter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Particle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 emitter_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &emitter_type_)));
          set_has_emitter_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_box_emitter;
        break;
      }
      
      // optional .Serializer.BoxParticleEmitter box_emitter = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_box_emitter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box_emitter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_disc_emitter;
        break;
      }
      
      // optional .Serializer.DiscParticleEmitter disc_emitter = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_disc_emitter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_disc_emitter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_version;
        break;
      }
      
      // optional int32 version = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_old_emitter;
        break;
      }
      
      // optional .Serializer.OldParticleEmitter old_emitter = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_old_emitter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_old_emitter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Particle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 emitter_type = 1;
  if (has_emitter_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->emitter_type(), output);
  }
  
  // optional .Serializer.BoxParticleEmitter box_emitter = 2;
  if (has_box_emitter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->box_emitter(), output);
  }
  
  // optional .Serializer.DiscParticleEmitter disc_emitter = 3;
  if (has_disc_emitter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->disc_emitter(), output);
  }
  
  // optional int32 version = 4;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->version(), output);
  }
  
  // optional .Serializer.OldParticleEmitter old_emitter = 5;
  if (has_old_emitter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->old_emitter(), output);
  }
  
}

int Particle::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 emitter_type = 1;
    if (has_emitter_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->emitter_type());
    }
    
    // optional .Serializer.BoxParticleEmitter box_emitter = 2;
    if (has_box_emitter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->box_emitter());
    }
    
    // optional .Serializer.DiscParticleEmitter disc_emitter = 3;
    if (has_disc_emitter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->disc_emitter());
    }
    
    // optional int32 version = 4;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }
    
    // optional .Serializer.OldParticleEmitter old_emitter = 5;
    if (has_old_emitter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->old_emitter());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Particle::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Particle*>(&from));
}

void Particle::MergeFrom(const Particle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_emitter_type()) {
      set_emitter_type(from.emitter_type());
    }
    if (from.has_box_emitter()) {
      mutable_box_emitter()->::Serializer::BoxParticleEmitter::MergeFrom(from.box_emitter());
    }
    if (from.has_disc_emitter()) {
      mutable_disc_emitter()->::Serializer::DiscParticleEmitter::MergeFrom(from.disc_emitter());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_old_emitter()) {
      mutable_old_emitter()->::Serializer::OldParticleEmitter::MergeFrom(from.old_emitter());
    }
  }
}

void Particle::CopyFrom(const Particle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Particle::IsInitialized() const {
  
  if (has_box_emitter()) {
    if (!this->box_emitter().IsInitialized()) return false;
  }
  if (has_disc_emitter()) {
    if (!this->disc_emitter().IsInitialized()) return false;
  }
  if (has_old_emitter()) {
    if (!this->old_emitter().IsInitialized()) return false;
  }
  return true;
}

void Particle::Swap(Particle* other) {
  if (other != this) {
    std::swap(emitter_type_, other->emitter_type_);
    std::swap(box_emitter_, other->box_emitter_);
    std::swap(disc_emitter_, other->disc_emitter_);
    std::swap(version_, other->version_);
    std::swap(old_emitter_, other->old_emitter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Particle::GetTypeName() const {
  return "Serializer.Particle";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)
