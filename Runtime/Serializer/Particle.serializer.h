// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Particle.proto

#ifndef PROTOBUF_Particle_2eproto__INCLUDED
#define PROTOBUF_Particle_2eproto__INCLUDED

#include <string>

#include "common.h"

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "generated_message_util.h"
#include "repeated_field.h"
#include "extension_set.h"
#include "Color.serializer.h"
#include "Vector.serializer.h"
// @@protoc_insertion_point(includes)

namespace Serializer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Particle_2eproto();
void protobuf_AssignDesc_Particle_2eproto();
void protobuf_ShutdownFile_Particle_2eproto();

class OldParticleEmitter;
class BoxParticleEmitter;
class DiscParticleEmitter;
class Particle;

// ===================================================================

class OldParticleEmitter : public ::google::protobuf::MessageLite {
 public:
  OldParticleEmitter();
  virtual ~OldParticleEmitter();
  
  OldParticleEmitter(const OldParticleEmitter& from);
  
  inline OldParticleEmitter& operator=(const OldParticleEmitter& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const OldParticleEmitter& default_instance();
  
  void Swap(OldParticleEmitter* other);
  
  // implements Message ----------------------------------------------
  
  OldParticleEmitter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OldParticleEmitter& from);
  void MergeFrom(const OldParticleEmitter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 max_particle_count = 1;
  inline bool has_max_particle_count() const;
  inline void clear_max_particle_count();
  static const int kMaxParticleCountFieldNumber = 1;
  inline ::google::protobuf::int32 max_particle_count() const;
  inline void set_max_particle_count(::google::protobuf::int32 value);
  
  // optional float max_delay_time = 2;
  inline bool has_max_delay_time() const;
  inline void clear_max_delay_time();
  static const int kMaxDelayTimeFieldNumber = 2;
  inline float max_delay_time() const;
  inline void set_max_delay_time(float value);
  
  // optional float max_life_time = 3;
  inline bool has_max_life_time() const;
  inline void clear_max_life_time();
  static const int kMaxLifeTimeFieldNumber = 3;
  inline float max_life_time() const;
  inline void set_max_life_time(float value);
  
  // optional .Serializer.Color4B min_start_color = 4;
  inline bool has_min_start_color() const;
  inline void clear_min_start_color();
  static const int kMinStartColorFieldNumber = 4;
  inline const ::Serializer::Color4B& min_start_color() const;
  inline ::Serializer::Color4B* mutable_min_start_color();
  inline ::Serializer::Color4B* release_min_start_color();
  
  // optional .Serializer.Color4B max_start_color = 5;
  inline bool has_max_start_color() const;
  inline void clear_max_start_color();
  static const int kMaxStartColorFieldNumber = 5;
  inline const ::Serializer::Color4B& max_start_color() const;
  inline ::Serializer::Color4B* mutable_max_start_color();
  inline ::Serializer::Color4B* release_max_start_color();
  
  // optional .Serializer.Vector4f min_emit_range = 6;
  inline bool has_min_emit_range() const;
  inline void clear_min_emit_range();
  static const int kMinEmitRangeFieldNumber = 6;
  inline const ::Serializer::Vector4f& min_emit_range() const;
  inline ::Serializer::Vector4f* mutable_min_emit_range();
  inline ::Serializer::Vector4f* release_min_emit_range();
  
  // optional .Serializer.Vector4f max_emit_range = 7;
  inline bool has_max_emit_range() const;
  inline void clear_max_emit_range();
  static const int kMaxEmitRangeFieldNumber = 7;
  inline const ::Serializer::Vector4f& max_emit_range() const;
  inline ::Serializer::Vector4f* mutable_max_emit_range();
  inline ::Serializer::Vector4f* release_max_emit_range();
  
  // optional .Serializer.Vector4f min_speed = 8;
  inline bool has_min_speed() const;
  inline void clear_min_speed();
  static const int kMinSpeedFieldNumber = 8;
  inline const ::Serializer::Vector4f& min_speed() const;
  inline ::Serializer::Vector4f* mutable_min_speed();
  inline ::Serializer::Vector4f* release_min_speed();
  
  // optional .Serializer.Vector4f max_speed = 9;
  inline bool has_max_speed() const;
  inline void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 9;
  inline const ::Serializer::Vector4f& max_speed() const;
  inline ::Serializer::Vector4f* mutable_max_speed();
  inline ::Serializer::Vector4f* release_max_speed();
  
  // @@protoc_insertion_point(class_scope:Serializer.OldParticleEmitter)
 private:
  inline void set_has_max_particle_count();
  inline void clear_has_max_particle_count();
  inline void set_has_max_delay_time();
  inline void clear_has_max_delay_time();
  inline void set_has_max_life_time();
  inline void clear_has_max_life_time();
  inline void set_has_min_start_color();
  inline void clear_has_min_start_color();
  inline void set_has_max_start_color();
  inline void clear_has_max_start_color();
  inline void set_has_min_emit_range();
  inline void clear_has_min_emit_range();
  inline void set_has_max_emit_range();
  inline void clear_has_max_emit_range();
  inline void set_has_min_speed();
  inline void clear_has_min_speed();
  inline void set_has_max_speed();
  inline void clear_has_max_speed();
  
  ::google::protobuf::int32 max_particle_count_;
  float max_delay_time_;
  ::Serializer::Color4B* min_start_color_;
  ::Serializer::Color4B* max_start_color_;
  ::Serializer::Vector4f* min_emit_range_;
  ::Serializer::Vector4f* max_emit_range_;
  ::Serializer::Vector4f* min_speed_;
  ::Serializer::Vector4f* max_speed_;
  float max_life_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Particle_2eproto();
  friend void protobuf_AssignDesc_Particle_2eproto();
  friend void protobuf_ShutdownFile_Particle_2eproto();
  
  void InitAsDefaultInstance();
  static OldParticleEmitter* default_instance_;
};
// -------------------------------------------------------------------

class BoxParticleEmitter : public ::google::protobuf::MessageLite {
 public:
  BoxParticleEmitter();
  virtual ~BoxParticleEmitter();
  
  BoxParticleEmitter(const BoxParticleEmitter& from);
  
  inline BoxParticleEmitter& operator=(const BoxParticleEmitter& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BoxParticleEmitter& default_instance();
  
  void Swap(BoxParticleEmitter* other);
  
  // implements Message ----------------------------------------------
  
  BoxParticleEmitter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BoxParticleEmitter& from);
  void MergeFrom(const BoxParticleEmitter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 min_particle_count_per_second = 1;
  inline bool has_min_particle_count_per_second() const;
  inline void clear_min_particle_count_per_second();
  static const int kMinParticleCountPerSecondFieldNumber = 1;
  inline ::google::protobuf::int32 min_particle_count_per_second() const;
  inline void set_min_particle_count_per_second(::google::protobuf::int32 value);
  
  // optional int32 max_particle_count_per_second = 2;
  inline bool has_max_particle_count_per_second() const;
  inline void clear_max_particle_count_per_second();
  static const int kMaxParticleCountPerSecondFieldNumber = 2;
  inline ::google::protobuf::int32 max_particle_count_per_second() const;
  inline void set_max_particle_count_per_second(::google::protobuf::int32 value);
  
  // optional float min_delay_time = 3;
  inline bool has_min_delay_time() const;
  inline void clear_min_delay_time();
  static const int kMinDelayTimeFieldNumber = 3;
  inline float min_delay_time() const;
  inline void set_min_delay_time(float value);
  
  // optional float min_life_time = 4;
  inline bool has_min_life_time() const;
  inline void clear_min_life_time();
  static const int kMinLifeTimeFieldNumber = 4;
  inline float min_life_time() const;
  inline void set_min_life_time(float value);
  
  // optional float max_delay_time = 5;
  inline bool has_max_delay_time() const;
  inline void clear_max_delay_time();
  static const int kMaxDelayTimeFieldNumber = 5;
  inline float max_delay_time() const;
  inline void set_max_delay_time(float value);
  
  // optional float max_life_time = 6;
  inline bool has_max_life_time() const;
  inline void clear_max_life_time();
  static const int kMaxLifeTimeFieldNumber = 6;
  inline float max_life_time() const;
  inline void set_max_life_time(float value);
  
  // optional .Serializer.Color4B min_start_color = 7;
  inline bool has_min_start_color() const;
  inline void clear_min_start_color();
  static const int kMinStartColorFieldNumber = 7;
  inline const ::Serializer::Color4B& min_start_color() const;
  inline ::Serializer::Color4B* mutable_min_start_color();
  inline ::Serializer::Color4B* release_min_start_color();
  
  // optional .Serializer.Color4B max_start_color = 8;
  inline bool has_max_start_color() const;
  inline void clear_max_start_color();
  static const int kMaxStartColorFieldNumber = 8;
  inline const ::Serializer::Color4B& max_start_color() const;
  inline ::Serializer::Color4B* mutable_max_start_color();
  inline ::Serializer::Color4B* release_max_start_color();
  
  // optional .Serializer.Vector4f min_emit_range = 9;
  inline bool has_min_emit_range() const;
  inline void clear_min_emit_range();
  static const int kMinEmitRangeFieldNumber = 9;
  inline const ::Serializer::Vector4f& min_emit_range() const;
  inline ::Serializer::Vector4f* mutable_min_emit_range();
  inline ::Serializer::Vector4f* release_min_emit_range();
  
  // optional .Serializer.Vector4f max_emit_range = 10;
  inline bool has_max_emit_range() const;
  inline void clear_max_emit_range();
  static const int kMaxEmitRangeFieldNumber = 10;
  inline const ::Serializer::Vector4f& max_emit_range() const;
  inline ::Serializer::Vector4f* mutable_max_emit_range();
  inline ::Serializer::Vector4f* release_max_emit_range();
  
  // optional .Serializer.Vector4f min_speed = 11;
  inline bool has_min_speed() const;
  inline void clear_min_speed();
  static const int kMinSpeedFieldNumber = 11;
  inline const ::Serializer::Vector4f& min_speed() const;
  inline ::Serializer::Vector4f* mutable_min_speed();
  inline ::Serializer::Vector4f* release_min_speed();
  
  // optional .Serializer.Vector4f max_speed = 12;
  inline bool has_max_speed() const;
  inline void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 12;
  inline const ::Serializer::Vector4f& max_speed() const;
  inline ::Serializer::Vector4f* mutable_max_speed();
  inline ::Serializer::Vector4f* release_max_speed();
  
  // optional bool use_gravity = 13;
  inline bool has_use_gravity() const;
  inline void clear_use_gravity();
  static const int kUseGravityFieldNumber = 13;
  inline bool use_gravity() const;
  inline void set_use_gravity(bool value);
  
  // optional .Serializer.Color4B min_end_color = 14;
  inline bool has_min_end_color() const;
  inline void clear_min_end_color();
  static const int kMinEndColorFieldNumber = 14;
  inline const ::Serializer::Color4B& min_end_color() const;
  inline ::Serializer::Color4B* mutable_min_end_color();
  inline ::Serializer::Color4B* release_min_end_color();
  
  // optional .Serializer.Color4B max_end_color = 15;
  inline bool has_max_end_color() const;
  inline void clear_max_end_color();
  static const int kMaxEndColorFieldNumber = 15;
  inline const ::Serializer::Color4B& max_end_color() const;
  inline ::Serializer::Color4B* mutable_max_end_color();
  inline ::Serializer::Color4B* release_max_end_color();
  
  // optional string image_guid = 16;
  inline bool has_image_guid() const;
  inline void clear_image_guid();
  static const int kImageGuidFieldNumber = 16;
  inline const ::std::string& image_guid() const;
  inline void set_image_guid(const ::std::string& value);
  inline void set_image_guid(const char* value);
  inline void set_image_guid(const char* value, size_t size);
  inline ::std::string* mutable_image_guid();
  inline ::std::string* release_image_guid();
  
  // @@protoc_insertion_point(class_scope:Serializer.BoxParticleEmitter)
 private:
  inline void set_has_min_particle_count_per_second();
  inline void clear_has_min_particle_count_per_second();
  inline void set_has_max_particle_count_per_second();
  inline void clear_has_max_particle_count_per_second();
  inline void set_has_min_delay_time();
  inline void clear_has_min_delay_time();
  inline void set_has_min_life_time();
  inline void clear_has_min_life_time();
  inline void set_has_max_delay_time();
  inline void clear_has_max_delay_time();
  inline void set_has_max_life_time();
  inline void clear_has_max_life_time();
  inline void set_has_min_start_color();
  inline void clear_has_min_start_color();
  inline void set_has_max_start_color();
  inline void clear_has_max_start_color();
  inline void set_has_min_emit_range();
  inline void clear_has_min_emit_range();
  inline void set_has_max_emit_range();
  inline void clear_has_max_emit_range();
  inline void set_has_min_speed();
  inline void clear_has_min_speed();
  inline void set_has_max_speed();
  inline void clear_has_max_speed();
  inline void set_has_use_gravity();
  inline void clear_has_use_gravity();
  inline void set_has_min_end_color();
  inline void clear_has_min_end_color();
  inline void set_has_max_end_color();
  inline void clear_has_max_end_color();
  inline void set_has_image_guid();
  inline void clear_has_image_guid();
  
  ::google::protobuf::int32 min_particle_count_per_second_;
  ::google::protobuf::int32 max_particle_count_per_second_;
  float min_delay_time_;
  float min_life_time_;
  float max_delay_time_;
  float max_life_time_;
  ::Serializer::Color4B* min_start_color_;
  ::Serializer::Color4B* max_start_color_;
  ::Serializer::Vector4f* min_emit_range_;
  ::Serializer::Vector4f* max_emit_range_;
  ::Serializer::Vector4f* min_speed_;
  ::Serializer::Vector4f* max_speed_;
  ::Serializer::Color4B* min_end_color_;
  ::Serializer::Color4B* max_end_color_;
  ::std::string* image_guid_;
  bool use_gravity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_Particle_2eproto();
  friend void protobuf_AssignDesc_Particle_2eproto();
  friend void protobuf_ShutdownFile_Particle_2eproto();
  
  void InitAsDefaultInstance();
  static BoxParticleEmitter* default_instance_;
};
// -------------------------------------------------------------------

class DiscParticleEmitter : public ::google::protobuf::MessageLite {
 public:
  DiscParticleEmitter();
  virtual ~DiscParticleEmitter();
  
  DiscParticleEmitter(const DiscParticleEmitter& from);
  
  inline DiscParticleEmitter& operator=(const DiscParticleEmitter& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DiscParticleEmitter& default_instance();
  
  void Swap(DiscParticleEmitter* other);
  
  // implements Message ----------------------------------------------
  
  DiscParticleEmitter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DiscParticleEmitter& from);
  void MergeFrom(const DiscParticleEmitter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 min_particle_count_per_second = 1;
  inline bool has_min_particle_count_per_second() const;
  inline void clear_min_particle_count_per_second();
  static const int kMinParticleCountPerSecondFieldNumber = 1;
  inline ::google::protobuf::int32 min_particle_count_per_second() const;
  inline void set_min_particle_count_per_second(::google::protobuf::int32 value);
  
  // optional int32 max_particle_count_per_second = 2;
  inline bool has_max_particle_count_per_second() const;
  inline void clear_max_particle_count_per_second();
  static const int kMaxParticleCountPerSecondFieldNumber = 2;
  inline ::google::protobuf::int32 max_particle_count_per_second() const;
  inline void set_max_particle_count_per_second(::google::protobuf::int32 value);
  
  // optional float min_delay_time = 3;
  inline bool has_min_delay_time() const;
  inline void clear_min_delay_time();
  static const int kMinDelayTimeFieldNumber = 3;
  inline float min_delay_time() const;
  inline void set_min_delay_time(float value);
  
  // optional float min_life_time = 4;
  inline bool has_min_life_time() const;
  inline void clear_min_life_time();
  static const int kMinLifeTimeFieldNumber = 4;
  inline float min_life_time() const;
  inline void set_min_life_time(float value);
  
  // optional float max_delay_time = 5;
  inline bool has_max_delay_time() const;
  inline void clear_max_delay_time();
  static const int kMaxDelayTimeFieldNumber = 5;
  inline float max_delay_time() const;
  inline void set_max_delay_time(float value);
  
  // optional float max_life_time = 6;
  inline bool has_max_life_time() const;
  inline void clear_max_life_time();
  static const int kMaxLifeTimeFieldNumber = 6;
  inline float max_life_time() const;
  inline void set_max_life_time(float value);
  
  // optional .Serializer.Color4B min_color = 7;
  inline bool has_min_color() const;
  inline void clear_min_color();
  static const int kMinColorFieldNumber = 7;
  inline const ::Serializer::Color4B& min_color() const;
  inline ::Serializer::Color4B* mutable_min_color();
  inline ::Serializer::Color4B* release_min_color();
  
  // optional .Serializer.Color4B max_color = 8;
  inline bool has_max_color() const;
  inline void clear_max_color();
  static const int kMaxColorFieldNumber = 8;
  inline const ::Serializer::Color4B& max_color() const;
  inline ::Serializer::Color4B* mutable_max_color();
  inline ::Serializer::Color4B* release_max_color();
  
  // optional .Serializer.Vector4f min_emit_range = 9;
  inline bool has_min_emit_range() const;
  inline void clear_min_emit_range();
  static const int kMinEmitRangeFieldNumber = 9;
  inline const ::Serializer::Vector4f& min_emit_range() const;
  inline ::Serializer::Vector4f* mutable_min_emit_range();
  inline ::Serializer::Vector4f* release_min_emit_range();
  
  // optional .Serializer.Vector4f max_emit_range = 10;
  inline bool has_max_emit_range() const;
  inline void clear_max_emit_range();
  static const int kMaxEmitRangeFieldNumber = 10;
  inline const ::Serializer::Vector4f& max_emit_range() const;
  inline ::Serializer::Vector4f* mutable_max_emit_range();
  inline ::Serializer::Vector4f* release_max_emit_range();
  
  // optional .Serializer.Vector4f min_speed = 11;
  inline bool has_min_speed() const;
  inline void clear_min_speed();
  static const int kMinSpeedFieldNumber = 11;
  inline const ::Serializer::Vector4f& min_speed() const;
  inline ::Serializer::Vector4f* mutable_min_speed();
  inline ::Serializer::Vector4f* release_min_speed();
  
  // optional .Serializer.Vector4f max_speed = 12;
  inline bool has_max_speed() const;
  inline void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 12;
  inline const ::Serializer::Vector4f& max_speed() const;
  inline ::Serializer::Vector4f* mutable_max_speed();
  inline ::Serializer::Vector4f* release_max_speed();
  
  // optional bool use_gravity = 13;
  inline bool has_use_gravity() const;
  inline void clear_use_gravity();
  static const int kUseGravityFieldNumber = 13;
  inline bool use_gravity() const;
  inline void set_use_gravity(bool value);
  
  // @@protoc_insertion_point(class_scope:Serializer.DiscParticleEmitter)
 private:
  inline void set_has_min_particle_count_per_second();
  inline void clear_has_min_particle_count_per_second();
  inline void set_has_max_particle_count_per_second();
  inline void clear_has_max_particle_count_per_second();
  inline void set_has_min_delay_time();
  inline void clear_has_min_delay_time();
  inline void set_has_min_life_time();
  inline void clear_has_min_life_time();
  inline void set_has_max_delay_time();
  inline void clear_has_max_delay_time();
  inline void set_has_max_life_time();
  inline void clear_has_max_life_time();
  inline void set_has_min_color();
  inline void clear_has_min_color();
  inline void set_has_max_color();
  inline void clear_has_max_color();
  inline void set_has_min_emit_range();
  inline void clear_has_min_emit_range();
  inline void set_has_max_emit_range();
  inline void clear_has_max_emit_range();
  inline void set_has_min_speed();
  inline void clear_has_min_speed();
  inline void set_has_max_speed();
  inline void clear_has_max_speed();
  inline void set_has_use_gravity();
  inline void clear_has_use_gravity();
  
  ::google::protobuf::int32 min_particle_count_per_second_;
  ::google::protobuf::int32 max_particle_count_per_second_;
  float min_delay_time_;
  float min_life_time_;
  float max_delay_time_;
  float max_life_time_;
  ::Serializer::Color4B* min_color_;
  ::Serializer::Color4B* max_color_;
  ::Serializer::Vector4f* min_emit_range_;
  ::Serializer::Vector4f* max_emit_range_;
  ::Serializer::Vector4f* min_speed_;
  ::Serializer::Vector4f* max_speed_;
  bool use_gravity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_Particle_2eproto();
  friend void protobuf_AssignDesc_Particle_2eproto();
  friend void protobuf_ShutdownFile_Particle_2eproto();
  
  void InitAsDefaultInstance();
  static DiscParticleEmitter* default_instance_;
};
// -------------------------------------------------------------------

class Particle : public ::google::protobuf::MessageLite {
 public:
  Particle();
  virtual ~Particle();
  
  Particle(const Particle& from);
  
  inline Particle& operator=(const Particle& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Particle& default_instance();
  
  void Swap(Particle* other);
  
  // implements Message ----------------------------------------------
  
  Particle* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Particle& from);
  void MergeFrom(const Particle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 emitter_type = 1;
  inline bool has_emitter_type() const;
  inline void clear_emitter_type();
  static const int kEmitterTypeFieldNumber = 1;
  inline ::google::protobuf::int32 emitter_type() const;
  inline void set_emitter_type(::google::protobuf::int32 value);
  
  // optional .Serializer.BoxParticleEmitter box_emitter = 2;
  inline bool has_box_emitter() const;
  inline void clear_box_emitter();
  static const int kBoxEmitterFieldNumber = 2;
  inline const ::Serializer::BoxParticleEmitter& box_emitter() const;
  inline ::Serializer::BoxParticleEmitter* mutable_box_emitter();
  inline ::Serializer::BoxParticleEmitter* release_box_emitter();
  
  // optional .Serializer.DiscParticleEmitter disc_emitter = 3;
  inline bool has_disc_emitter() const;
  inline void clear_disc_emitter();
  static const int kDiscEmitterFieldNumber = 3;
  inline const ::Serializer::DiscParticleEmitter& disc_emitter() const;
  inline ::Serializer::DiscParticleEmitter* mutable_disc_emitter();
  inline ::Serializer::DiscParticleEmitter* release_disc_emitter();
  
  // optional int32 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // optional .Serializer.OldParticleEmitter old_emitter = 5;
  inline bool has_old_emitter() const;
  inline void clear_old_emitter();
  static const int kOldEmitterFieldNumber = 5;
  inline const ::Serializer::OldParticleEmitter& old_emitter() const;
  inline ::Serializer::OldParticleEmitter* mutable_old_emitter();
  inline ::Serializer::OldParticleEmitter* release_old_emitter();
  
  // @@protoc_insertion_point(class_scope:Serializer.Particle)
 private:
  inline void set_has_emitter_type();
  inline void clear_has_emitter_type();
  inline void set_has_box_emitter();
  inline void clear_has_box_emitter();
  inline void set_has_disc_emitter();
  inline void clear_has_disc_emitter();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_old_emitter();
  inline void clear_has_old_emitter();
  
  ::Serializer::BoxParticleEmitter* box_emitter_;
  ::google::protobuf::int32 emitter_type_;
  ::google::protobuf::int32 version_;
  ::Serializer::DiscParticleEmitter* disc_emitter_;
  ::Serializer::OldParticleEmitter* old_emitter_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Particle_2eproto();
  friend void protobuf_AssignDesc_Particle_2eproto();
  friend void protobuf_ShutdownFile_Particle_2eproto();
  
  void InitAsDefaultInstance();
  static Particle* default_instance_;
};
// ===================================================================


// ===================================================================

// OldParticleEmitter

// optional int32 max_particle_count = 1;
inline bool OldParticleEmitter::has_max_particle_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OldParticleEmitter::set_has_max_particle_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OldParticleEmitter::clear_has_max_particle_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OldParticleEmitter::clear_max_particle_count() {
  max_particle_count_ = 0;
  clear_has_max_particle_count();
}
inline ::google::protobuf::int32 OldParticleEmitter::max_particle_count() const {
  return max_particle_count_;
}
inline void OldParticleEmitter::set_max_particle_count(::google::protobuf::int32 value) {
  set_has_max_particle_count();
  max_particle_count_ = value;
}

// optional float max_delay_time = 2;
inline bool OldParticleEmitter::has_max_delay_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OldParticleEmitter::set_has_max_delay_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OldParticleEmitter::clear_has_max_delay_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OldParticleEmitter::clear_max_delay_time() {
  max_delay_time_ = 0;
  clear_has_max_delay_time();
}
inline float OldParticleEmitter::max_delay_time() const {
  return max_delay_time_;
}
inline void OldParticleEmitter::set_max_delay_time(float value) {
  set_has_max_delay_time();
  max_delay_time_ = value;
}

// optional float max_life_time = 3;
inline bool OldParticleEmitter::has_max_life_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OldParticleEmitter::set_has_max_life_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OldParticleEmitter::clear_has_max_life_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OldParticleEmitter::clear_max_life_time() {
  max_life_time_ = 0;
  clear_has_max_life_time();
}
inline float OldParticleEmitter::max_life_time() const {
  return max_life_time_;
}
inline void OldParticleEmitter::set_max_life_time(float value) {
  set_has_max_life_time();
  max_life_time_ = value;
}

// optional .Serializer.Color4B min_start_color = 4;
inline bool OldParticleEmitter::has_min_start_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OldParticleEmitter::set_has_min_start_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OldParticleEmitter::clear_has_min_start_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OldParticleEmitter::clear_min_start_color() {
  if (min_start_color_ != NULL) min_start_color_->::Serializer::Color4B::Clear();
  clear_has_min_start_color();
}
inline const ::Serializer::Color4B& OldParticleEmitter::min_start_color() const {
  return min_start_color_ != NULL ? *min_start_color_ : *default_instance_->min_start_color_;
}
inline ::Serializer::Color4B* OldParticleEmitter::mutable_min_start_color() {
  set_has_min_start_color();
  if (min_start_color_ == NULL) min_start_color_ = new ::Serializer::Color4B;
  return min_start_color_;
}
inline ::Serializer::Color4B* OldParticleEmitter::release_min_start_color() {
  clear_has_min_start_color();
  ::Serializer::Color4B* temp = min_start_color_;
  min_start_color_ = NULL;
  return temp;
}

// optional .Serializer.Color4B max_start_color = 5;
inline bool OldParticleEmitter::has_max_start_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OldParticleEmitter::set_has_max_start_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OldParticleEmitter::clear_has_max_start_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OldParticleEmitter::clear_max_start_color() {
  if (max_start_color_ != NULL) max_start_color_->::Serializer::Color4B::Clear();
  clear_has_max_start_color();
}
inline const ::Serializer::Color4B& OldParticleEmitter::max_start_color() const {
  return max_start_color_ != NULL ? *max_start_color_ : *default_instance_->max_start_color_;
}
inline ::Serializer::Color4B* OldParticleEmitter::mutable_max_start_color() {
  set_has_max_start_color();
  if (max_start_color_ == NULL) max_start_color_ = new ::Serializer::Color4B;
  return max_start_color_;
}
inline ::Serializer::Color4B* OldParticleEmitter::release_max_start_color() {
  clear_has_max_start_color();
  ::Serializer::Color4B* temp = max_start_color_;
  max_start_color_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f min_emit_range = 6;
inline bool OldParticleEmitter::has_min_emit_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OldParticleEmitter::set_has_min_emit_range() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OldParticleEmitter::clear_has_min_emit_range() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OldParticleEmitter::clear_min_emit_range() {
  if (min_emit_range_ != NULL) min_emit_range_->::Serializer::Vector4f::Clear();
  clear_has_min_emit_range();
}
inline const ::Serializer::Vector4f& OldParticleEmitter::min_emit_range() const {
  return min_emit_range_ != NULL ? *min_emit_range_ : *default_instance_->min_emit_range_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::mutable_min_emit_range() {
  set_has_min_emit_range();
  if (min_emit_range_ == NULL) min_emit_range_ = new ::Serializer::Vector4f;
  return min_emit_range_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::release_min_emit_range() {
  clear_has_min_emit_range();
  ::Serializer::Vector4f* temp = min_emit_range_;
  min_emit_range_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f max_emit_range = 7;
inline bool OldParticleEmitter::has_max_emit_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OldParticleEmitter::set_has_max_emit_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OldParticleEmitter::clear_has_max_emit_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OldParticleEmitter::clear_max_emit_range() {
  if (max_emit_range_ != NULL) max_emit_range_->::Serializer::Vector4f::Clear();
  clear_has_max_emit_range();
}
inline const ::Serializer::Vector4f& OldParticleEmitter::max_emit_range() const {
  return max_emit_range_ != NULL ? *max_emit_range_ : *default_instance_->max_emit_range_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::mutable_max_emit_range() {
  set_has_max_emit_range();
  if (max_emit_range_ == NULL) max_emit_range_ = new ::Serializer::Vector4f;
  return max_emit_range_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::release_max_emit_range() {
  clear_has_max_emit_range();
  ::Serializer::Vector4f* temp = max_emit_range_;
  max_emit_range_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f min_speed = 8;
inline bool OldParticleEmitter::has_min_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OldParticleEmitter::set_has_min_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OldParticleEmitter::clear_has_min_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OldParticleEmitter::clear_min_speed() {
  if (min_speed_ != NULL) min_speed_->::Serializer::Vector4f::Clear();
  clear_has_min_speed();
}
inline const ::Serializer::Vector4f& OldParticleEmitter::min_speed() const {
  return min_speed_ != NULL ? *min_speed_ : *default_instance_->min_speed_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::mutable_min_speed() {
  set_has_min_speed();
  if (min_speed_ == NULL) min_speed_ = new ::Serializer::Vector4f;
  return min_speed_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::release_min_speed() {
  clear_has_min_speed();
  ::Serializer::Vector4f* temp = min_speed_;
  min_speed_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f max_speed = 9;
inline bool OldParticleEmitter::has_max_speed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OldParticleEmitter::set_has_max_speed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OldParticleEmitter::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OldParticleEmitter::clear_max_speed() {
  if (max_speed_ != NULL) max_speed_->::Serializer::Vector4f::Clear();
  clear_has_max_speed();
}
inline const ::Serializer::Vector4f& OldParticleEmitter::max_speed() const {
  return max_speed_ != NULL ? *max_speed_ : *default_instance_->max_speed_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::mutable_max_speed() {
  set_has_max_speed();
  if (max_speed_ == NULL) max_speed_ = new ::Serializer::Vector4f;
  return max_speed_;
}
inline ::Serializer::Vector4f* OldParticleEmitter::release_max_speed() {
  clear_has_max_speed();
  ::Serializer::Vector4f* temp = max_speed_;
  max_speed_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// BoxParticleEmitter

// optional int32 min_particle_count_per_second = 1;
inline bool BoxParticleEmitter::has_min_particle_count_per_second() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxParticleEmitter::set_has_min_particle_count_per_second() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxParticleEmitter::clear_has_min_particle_count_per_second() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxParticleEmitter::clear_min_particle_count_per_second() {
  min_particle_count_per_second_ = 0;
  clear_has_min_particle_count_per_second();
}
inline ::google::protobuf::int32 BoxParticleEmitter::min_particle_count_per_second() const {
  return min_particle_count_per_second_;
}
inline void BoxParticleEmitter::set_min_particle_count_per_second(::google::protobuf::int32 value) {
  set_has_min_particle_count_per_second();
  min_particle_count_per_second_ = value;
}

// optional int32 max_particle_count_per_second = 2;
inline bool BoxParticleEmitter::has_max_particle_count_per_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxParticleEmitter::set_has_max_particle_count_per_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxParticleEmitter::clear_has_max_particle_count_per_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxParticleEmitter::clear_max_particle_count_per_second() {
  max_particle_count_per_second_ = 0;
  clear_has_max_particle_count_per_second();
}
inline ::google::protobuf::int32 BoxParticleEmitter::max_particle_count_per_second() const {
  return max_particle_count_per_second_;
}
inline void BoxParticleEmitter::set_max_particle_count_per_second(::google::protobuf::int32 value) {
  set_has_max_particle_count_per_second();
  max_particle_count_per_second_ = value;
}

// optional float min_delay_time = 3;
inline bool BoxParticleEmitter::has_min_delay_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoxParticleEmitter::set_has_min_delay_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoxParticleEmitter::clear_has_min_delay_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoxParticleEmitter::clear_min_delay_time() {
  min_delay_time_ = 0;
  clear_has_min_delay_time();
}
inline float BoxParticleEmitter::min_delay_time() const {
  return min_delay_time_;
}
inline void BoxParticleEmitter::set_min_delay_time(float value) {
  set_has_min_delay_time();
  min_delay_time_ = value;
}

// optional float min_life_time = 4;
inline bool BoxParticleEmitter::has_min_life_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoxParticleEmitter::set_has_min_life_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoxParticleEmitter::clear_has_min_life_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoxParticleEmitter::clear_min_life_time() {
  min_life_time_ = 0;
  clear_has_min_life_time();
}
inline float BoxParticleEmitter::min_life_time() const {
  return min_life_time_;
}
inline void BoxParticleEmitter::set_min_life_time(float value) {
  set_has_min_life_time();
  min_life_time_ = value;
}

// optional float max_delay_time = 5;
inline bool BoxParticleEmitter::has_max_delay_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BoxParticleEmitter::set_has_max_delay_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BoxParticleEmitter::clear_has_max_delay_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BoxParticleEmitter::clear_max_delay_time() {
  max_delay_time_ = 0;
  clear_has_max_delay_time();
}
inline float BoxParticleEmitter::max_delay_time() const {
  return max_delay_time_;
}
inline void BoxParticleEmitter::set_max_delay_time(float value) {
  set_has_max_delay_time();
  max_delay_time_ = value;
}

// optional float max_life_time = 6;
inline bool BoxParticleEmitter::has_max_life_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BoxParticleEmitter::set_has_max_life_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BoxParticleEmitter::clear_has_max_life_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BoxParticleEmitter::clear_max_life_time() {
  max_life_time_ = 0;
  clear_has_max_life_time();
}
inline float BoxParticleEmitter::max_life_time() const {
  return max_life_time_;
}
inline void BoxParticleEmitter::set_max_life_time(float value) {
  set_has_max_life_time();
  max_life_time_ = value;
}

// optional .Serializer.Color4B min_start_color = 7;
inline bool BoxParticleEmitter::has_min_start_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BoxParticleEmitter::set_has_min_start_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BoxParticleEmitter::clear_has_min_start_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BoxParticleEmitter::clear_min_start_color() {
  if (min_start_color_ != NULL) min_start_color_->::Serializer::Color4B::Clear();
  clear_has_min_start_color();
}
inline const ::Serializer::Color4B& BoxParticleEmitter::min_start_color() const {
  return min_start_color_ != NULL ? *min_start_color_ : *default_instance_->min_start_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::mutable_min_start_color() {
  set_has_min_start_color();
  if (min_start_color_ == NULL) min_start_color_ = new ::Serializer::Color4B;
  return min_start_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::release_min_start_color() {
  clear_has_min_start_color();
  ::Serializer::Color4B* temp = min_start_color_;
  min_start_color_ = NULL;
  return temp;
}

// optional .Serializer.Color4B max_start_color = 8;
inline bool BoxParticleEmitter::has_max_start_color() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BoxParticleEmitter::set_has_max_start_color() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BoxParticleEmitter::clear_has_max_start_color() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BoxParticleEmitter::clear_max_start_color() {
  if (max_start_color_ != NULL) max_start_color_->::Serializer::Color4B::Clear();
  clear_has_max_start_color();
}
inline const ::Serializer::Color4B& BoxParticleEmitter::max_start_color() const {
  return max_start_color_ != NULL ? *max_start_color_ : *default_instance_->max_start_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::mutable_max_start_color() {
  set_has_max_start_color();
  if (max_start_color_ == NULL) max_start_color_ = new ::Serializer::Color4B;
  return max_start_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::release_max_start_color() {
  clear_has_max_start_color();
  ::Serializer::Color4B* temp = max_start_color_;
  max_start_color_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f min_emit_range = 9;
inline bool BoxParticleEmitter::has_min_emit_range() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BoxParticleEmitter::set_has_min_emit_range() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BoxParticleEmitter::clear_has_min_emit_range() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BoxParticleEmitter::clear_min_emit_range() {
  if (min_emit_range_ != NULL) min_emit_range_->::Serializer::Vector4f::Clear();
  clear_has_min_emit_range();
}
inline const ::Serializer::Vector4f& BoxParticleEmitter::min_emit_range() const {
  return min_emit_range_ != NULL ? *min_emit_range_ : *default_instance_->min_emit_range_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::mutable_min_emit_range() {
  set_has_min_emit_range();
  if (min_emit_range_ == NULL) min_emit_range_ = new ::Serializer::Vector4f;
  return min_emit_range_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::release_min_emit_range() {
  clear_has_min_emit_range();
  ::Serializer::Vector4f* temp = min_emit_range_;
  min_emit_range_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f max_emit_range = 10;
inline bool BoxParticleEmitter::has_max_emit_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BoxParticleEmitter::set_has_max_emit_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BoxParticleEmitter::clear_has_max_emit_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BoxParticleEmitter::clear_max_emit_range() {
  if (max_emit_range_ != NULL) max_emit_range_->::Serializer::Vector4f::Clear();
  clear_has_max_emit_range();
}
inline const ::Serializer::Vector4f& BoxParticleEmitter::max_emit_range() const {
  return max_emit_range_ != NULL ? *max_emit_range_ : *default_instance_->max_emit_range_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::mutable_max_emit_range() {
  set_has_max_emit_range();
  if (max_emit_range_ == NULL) max_emit_range_ = new ::Serializer::Vector4f;
  return max_emit_range_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::release_max_emit_range() {
  clear_has_max_emit_range();
  ::Serializer::Vector4f* temp = max_emit_range_;
  max_emit_range_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f min_speed = 11;
inline bool BoxParticleEmitter::has_min_speed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BoxParticleEmitter::set_has_min_speed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BoxParticleEmitter::clear_has_min_speed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BoxParticleEmitter::clear_min_speed() {
  if (min_speed_ != NULL) min_speed_->::Serializer::Vector4f::Clear();
  clear_has_min_speed();
}
inline const ::Serializer::Vector4f& BoxParticleEmitter::min_speed() const {
  return min_speed_ != NULL ? *min_speed_ : *default_instance_->min_speed_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::mutable_min_speed() {
  set_has_min_speed();
  if (min_speed_ == NULL) min_speed_ = new ::Serializer::Vector4f;
  return min_speed_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::release_min_speed() {
  clear_has_min_speed();
  ::Serializer::Vector4f* temp = min_speed_;
  min_speed_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f max_speed = 12;
inline bool BoxParticleEmitter::has_max_speed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BoxParticleEmitter::set_has_max_speed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BoxParticleEmitter::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BoxParticleEmitter::clear_max_speed() {
  if (max_speed_ != NULL) max_speed_->::Serializer::Vector4f::Clear();
  clear_has_max_speed();
}
inline const ::Serializer::Vector4f& BoxParticleEmitter::max_speed() const {
  return max_speed_ != NULL ? *max_speed_ : *default_instance_->max_speed_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::mutable_max_speed() {
  set_has_max_speed();
  if (max_speed_ == NULL) max_speed_ = new ::Serializer::Vector4f;
  return max_speed_;
}
inline ::Serializer::Vector4f* BoxParticleEmitter::release_max_speed() {
  clear_has_max_speed();
  ::Serializer::Vector4f* temp = max_speed_;
  max_speed_ = NULL;
  return temp;
}

// optional bool use_gravity = 13;
inline bool BoxParticleEmitter::has_use_gravity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BoxParticleEmitter::set_has_use_gravity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BoxParticleEmitter::clear_has_use_gravity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BoxParticleEmitter::clear_use_gravity() {
  use_gravity_ = false;
  clear_has_use_gravity();
}
inline bool BoxParticleEmitter::use_gravity() const {
  return use_gravity_;
}
inline void BoxParticleEmitter::set_use_gravity(bool value) {
  set_has_use_gravity();
  use_gravity_ = value;
}

// optional .Serializer.Color4B min_end_color = 14;
inline bool BoxParticleEmitter::has_min_end_color() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BoxParticleEmitter::set_has_min_end_color() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BoxParticleEmitter::clear_has_min_end_color() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BoxParticleEmitter::clear_min_end_color() {
  if (min_end_color_ != NULL) min_end_color_->::Serializer::Color4B::Clear();
  clear_has_min_end_color();
}
inline const ::Serializer::Color4B& BoxParticleEmitter::min_end_color() const {
  return min_end_color_ != NULL ? *min_end_color_ : *default_instance_->min_end_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::mutable_min_end_color() {
  set_has_min_end_color();
  if (min_end_color_ == NULL) min_end_color_ = new ::Serializer::Color4B;
  return min_end_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::release_min_end_color() {
  clear_has_min_end_color();
  ::Serializer::Color4B* temp = min_end_color_;
  min_end_color_ = NULL;
  return temp;
}

// optional .Serializer.Color4B max_end_color = 15;
inline bool BoxParticleEmitter::has_max_end_color() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BoxParticleEmitter::set_has_max_end_color() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BoxParticleEmitter::clear_has_max_end_color() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BoxParticleEmitter::clear_max_end_color() {
  if (max_end_color_ != NULL) max_end_color_->::Serializer::Color4B::Clear();
  clear_has_max_end_color();
}
inline const ::Serializer::Color4B& BoxParticleEmitter::max_end_color() const {
  return max_end_color_ != NULL ? *max_end_color_ : *default_instance_->max_end_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::mutable_max_end_color() {
  set_has_max_end_color();
  if (max_end_color_ == NULL) max_end_color_ = new ::Serializer::Color4B;
  return max_end_color_;
}
inline ::Serializer::Color4B* BoxParticleEmitter::release_max_end_color() {
  clear_has_max_end_color();
  ::Serializer::Color4B* temp = max_end_color_;
  max_end_color_ = NULL;
  return temp;
}

// optional string image_guid = 16;
inline bool BoxParticleEmitter::has_image_guid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BoxParticleEmitter::set_has_image_guid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BoxParticleEmitter::clear_has_image_guid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BoxParticleEmitter::clear_image_guid() {
  if (image_guid_ != &::google::protobuf::internal::kEmptyString) {
    image_guid_->clear();
  }
  clear_has_image_guid();
}
inline const ::std::string& BoxParticleEmitter::image_guid() const {
  return *image_guid_;
}
inline void BoxParticleEmitter::set_image_guid(const ::std::string& value) {
  set_has_image_guid();
  if (image_guid_ == &::google::protobuf::internal::kEmptyString) {
    image_guid_ = new ::std::string;
  }
  image_guid_->assign(value);
}
inline void BoxParticleEmitter::set_image_guid(const char* value) {
  set_has_image_guid();
  if (image_guid_ == &::google::protobuf::internal::kEmptyString) {
    image_guid_ = new ::std::string;
  }
  image_guid_->assign(value);
}
inline void BoxParticleEmitter::set_image_guid(const char* value, size_t size) {
  set_has_image_guid();
  if (image_guid_ == &::google::protobuf::internal::kEmptyString) {
    image_guid_ = new ::std::string;
  }
  image_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxParticleEmitter::mutable_image_guid() {
  set_has_image_guid();
  if (image_guid_ == &::google::protobuf::internal::kEmptyString) {
    image_guid_ = new ::std::string;
  }
  return image_guid_;
}
inline ::std::string* BoxParticleEmitter::release_image_guid() {
  clear_has_image_guid();
  if (image_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_guid_;
    image_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DiscParticleEmitter

// optional int32 min_particle_count_per_second = 1;
inline bool DiscParticleEmitter::has_min_particle_count_per_second() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscParticleEmitter::set_has_min_particle_count_per_second() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscParticleEmitter::clear_has_min_particle_count_per_second() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscParticleEmitter::clear_min_particle_count_per_second() {
  min_particle_count_per_second_ = 0;
  clear_has_min_particle_count_per_second();
}
inline ::google::protobuf::int32 DiscParticleEmitter::min_particle_count_per_second() const {
  return min_particle_count_per_second_;
}
inline void DiscParticleEmitter::set_min_particle_count_per_second(::google::protobuf::int32 value) {
  set_has_min_particle_count_per_second();
  min_particle_count_per_second_ = value;
}

// optional int32 max_particle_count_per_second = 2;
inline bool DiscParticleEmitter::has_max_particle_count_per_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscParticleEmitter::set_has_max_particle_count_per_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscParticleEmitter::clear_has_max_particle_count_per_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscParticleEmitter::clear_max_particle_count_per_second() {
  max_particle_count_per_second_ = 0;
  clear_has_max_particle_count_per_second();
}
inline ::google::protobuf::int32 DiscParticleEmitter::max_particle_count_per_second() const {
  return max_particle_count_per_second_;
}
inline void DiscParticleEmitter::set_max_particle_count_per_second(::google::protobuf::int32 value) {
  set_has_max_particle_count_per_second();
  max_particle_count_per_second_ = value;
}

// optional float min_delay_time = 3;
inline bool DiscParticleEmitter::has_min_delay_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscParticleEmitter::set_has_min_delay_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscParticleEmitter::clear_has_min_delay_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscParticleEmitter::clear_min_delay_time() {
  min_delay_time_ = 0;
  clear_has_min_delay_time();
}
inline float DiscParticleEmitter::min_delay_time() const {
  return min_delay_time_;
}
inline void DiscParticleEmitter::set_min_delay_time(float value) {
  set_has_min_delay_time();
  min_delay_time_ = value;
}

// optional float min_life_time = 4;
inline bool DiscParticleEmitter::has_min_life_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscParticleEmitter::set_has_min_life_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscParticleEmitter::clear_has_min_life_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscParticleEmitter::clear_min_life_time() {
  min_life_time_ = 0;
  clear_has_min_life_time();
}
inline float DiscParticleEmitter::min_life_time() const {
  return min_life_time_;
}
inline void DiscParticleEmitter::set_min_life_time(float value) {
  set_has_min_life_time();
  min_life_time_ = value;
}

// optional float max_delay_time = 5;
inline bool DiscParticleEmitter::has_max_delay_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscParticleEmitter::set_has_max_delay_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscParticleEmitter::clear_has_max_delay_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscParticleEmitter::clear_max_delay_time() {
  max_delay_time_ = 0;
  clear_has_max_delay_time();
}
inline float DiscParticleEmitter::max_delay_time() const {
  return max_delay_time_;
}
inline void DiscParticleEmitter::set_max_delay_time(float value) {
  set_has_max_delay_time();
  max_delay_time_ = value;
}

// optional float max_life_time = 6;
inline bool DiscParticleEmitter::has_max_life_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiscParticleEmitter::set_has_max_life_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiscParticleEmitter::clear_has_max_life_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiscParticleEmitter::clear_max_life_time() {
  max_life_time_ = 0;
  clear_has_max_life_time();
}
inline float DiscParticleEmitter::max_life_time() const {
  return max_life_time_;
}
inline void DiscParticleEmitter::set_max_life_time(float value) {
  set_has_max_life_time();
  max_life_time_ = value;
}

// optional .Serializer.Color4B min_color = 7;
inline bool DiscParticleEmitter::has_min_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiscParticleEmitter::set_has_min_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiscParticleEmitter::clear_has_min_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiscParticleEmitter::clear_min_color() {
  if (min_color_ != NULL) min_color_->::Serializer::Color4B::Clear();
  clear_has_min_color();
}
inline const ::Serializer::Color4B& DiscParticleEmitter::min_color() const {
  return min_color_ != NULL ? *min_color_ : *default_instance_->min_color_;
}
inline ::Serializer::Color4B* DiscParticleEmitter::mutable_min_color() {
  set_has_min_color();
  if (min_color_ == NULL) min_color_ = new ::Serializer::Color4B;
  return min_color_;
}
inline ::Serializer::Color4B* DiscParticleEmitter::release_min_color() {
  clear_has_min_color();
  ::Serializer::Color4B* temp = min_color_;
  min_color_ = NULL;
  return temp;
}

// optional .Serializer.Color4B max_color = 8;
inline bool DiscParticleEmitter::has_max_color() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DiscParticleEmitter::set_has_max_color() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DiscParticleEmitter::clear_has_max_color() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DiscParticleEmitter::clear_max_color() {
  if (max_color_ != NULL) max_color_->::Serializer::Color4B::Clear();
  clear_has_max_color();
}
inline const ::Serializer::Color4B& DiscParticleEmitter::max_color() const {
  return max_color_ != NULL ? *max_color_ : *default_instance_->max_color_;
}
inline ::Serializer::Color4B* DiscParticleEmitter::mutable_max_color() {
  set_has_max_color();
  if (max_color_ == NULL) max_color_ = new ::Serializer::Color4B;
  return max_color_;
}
inline ::Serializer::Color4B* DiscParticleEmitter::release_max_color() {
  clear_has_max_color();
  ::Serializer::Color4B* temp = max_color_;
  max_color_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f min_emit_range = 9;
inline bool DiscParticleEmitter::has_min_emit_range() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DiscParticleEmitter::set_has_min_emit_range() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DiscParticleEmitter::clear_has_min_emit_range() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DiscParticleEmitter::clear_min_emit_range() {
  if (min_emit_range_ != NULL) min_emit_range_->::Serializer::Vector4f::Clear();
  clear_has_min_emit_range();
}
inline const ::Serializer::Vector4f& DiscParticleEmitter::min_emit_range() const {
  return min_emit_range_ != NULL ? *min_emit_range_ : *default_instance_->min_emit_range_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::mutable_min_emit_range() {
  set_has_min_emit_range();
  if (min_emit_range_ == NULL) min_emit_range_ = new ::Serializer::Vector4f;
  return min_emit_range_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::release_min_emit_range() {
  clear_has_min_emit_range();
  ::Serializer::Vector4f* temp = min_emit_range_;
  min_emit_range_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f max_emit_range = 10;
inline bool DiscParticleEmitter::has_max_emit_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DiscParticleEmitter::set_has_max_emit_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DiscParticleEmitter::clear_has_max_emit_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DiscParticleEmitter::clear_max_emit_range() {
  if (max_emit_range_ != NULL) max_emit_range_->::Serializer::Vector4f::Clear();
  clear_has_max_emit_range();
}
inline const ::Serializer::Vector4f& DiscParticleEmitter::max_emit_range() const {
  return max_emit_range_ != NULL ? *max_emit_range_ : *default_instance_->max_emit_range_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::mutable_max_emit_range() {
  set_has_max_emit_range();
  if (max_emit_range_ == NULL) max_emit_range_ = new ::Serializer::Vector4f;
  return max_emit_range_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::release_max_emit_range() {
  clear_has_max_emit_range();
  ::Serializer::Vector4f* temp = max_emit_range_;
  max_emit_range_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f min_speed = 11;
inline bool DiscParticleEmitter::has_min_speed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DiscParticleEmitter::set_has_min_speed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DiscParticleEmitter::clear_has_min_speed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DiscParticleEmitter::clear_min_speed() {
  if (min_speed_ != NULL) min_speed_->::Serializer::Vector4f::Clear();
  clear_has_min_speed();
}
inline const ::Serializer::Vector4f& DiscParticleEmitter::min_speed() const {
  return min_speed_ != NULL ? *min_speed_ : *default_instance_->min_speed_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::mutable_min_speed() {
  set_has_min_speed();
  if (min_speed_ == NULL) min_speed_ = new ::Serializer::Vector4f;
  return min_speed_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::release_min_speed() {
  clear_has_min_speed();
  ::Serializer::Vector4f* temp = min_speed_;
  min_speed_ = NULL;
  return temp;
}

// optional .Serializer.Vector4f max_speed = 12;
inline bool DiscParticleEmitter::has_max_speed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DiscParticleEmitter::set_has_max_speed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DiscParticleEmitter::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DiscParticleEmitter::clear_max_speed() {
  if (max_speed_ != NULL) max_speed_->::Serializer::Vector4f::Clear();
  clear_has_max_speed();
}
inline const ::Serializer::Vector4f& DiscParticleEmitter::max_speed() const {
  return max_speed_ != NULL ? *max_speed_ : *default_instance_->max_speed_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::mutable_max_speed() {
  set_has_max_speed();
  if (max_speed_ == NULL) max_speed_ = new ::Serializer::Vector4f;
  return max_speed_;
}
inline ::Serializer::Vector4f* DiscParticleEmitter::release_max_speed() {
  clear_has_max_speed();
  ::Serializer::Vector4f* temp = max_speed_;
  max_speed_ = NULL;
  return temp;
}

// optional bool use_gravity = 13;
inline bool DiscParticleEmitter::has_use_gravity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DiscParticleEmitter::set_has_use_gravity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DiscParticleEmitter::clear_has_use_gravity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DiscParticleEmitter::clear_use_gravity() {
  use_gravity_ = false;
  clear_has_use_gravity();
}
inline bool DiscParticleEmitter::use_gravity() const {
  return use_gravity_;
}
inline void DiscParticleEmitter::set_use_gravity(bool value) {
  set_has_use_gravity();
  use_gravity_ = value;
}

// -------------------------------------------------------------------

// Particle

// optional int32 emitter_type = 1;
inline bool Particle::has_emitter_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particle::set_has_emitter_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particle::clear_has_emitter_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particle::clear_emitter_type() {
  emitter_type_ = 0;
  clear_has_emitter_type();
}
inline ::google::protobuf::int32 Particle::emitter_type() const {
  return emitter_type_;
}
inline void Particle::set_emitter_type(::google::protobuf::int32 value) {
  set_has_emitter_type();
  emitter_type_ = value;
}

// optional .Serializer.BoxParticleEmitter box_emitter = 2;
inline bool Particle::has_box_emitter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Particle::set_has_box_emitter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Particle::clear_has_box_emitter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Particle::clear_box_emitter() {
  if (box_emitter_ != NULL) box_emitter_->::Serializer::BoxParticleEmitter::Clear();
  clear_has_box_emitter();
}
inline const ::Serializer::BoxParticleEmitter& Particle::box_emitter() const {
  return box_emitter_ != NULL ? *box_emitter_ : *default_instance_->box_emitter_;
}
inline ::Serializer::BoxParticleEmitter* Particle::mutable_box_emitter() {
  set_has_box_emitter();
  if (box_emitter_ == NULL) box_emitter_ = new ::Serializer::BoxParticleEmitter;
  return box_emitter_;
}
inline ::Serializer::BoxParticleEmitter* Particle::release_box_emitter() {
  clear_has_box_emitter();
  ::Serializer::BoxParticleEmitter* temp = box_emitter_;
  box_emitter_ = NULL;
  return temp;
}

// optional .Serializer.DiscParticleEmitter disc_emitter = 3;
inline bool Particle::has_disc_emitter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Particle::set_has_disc_emitter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Particle::clear_has_disc_emitter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Particle::clear_disc_emitter() {
  if (disc_emitter_ != NULL) disc_emitter_->::Serializer::DiscParticleEmitter::Clear();
  clear_has_disc_emitter();
}
inline const ::Serializer::DiscParticleEmitter& Particle::disc_emitter() const {
  return disc_emitter_ != NULL ? *disc_emitter_ : *default_instance_->disc_emitter_;
}
inline ::Serializer::DiscParticleEmitter* Particle::mutable_disc_emitter() {
  set_has_disc_emitter();
  if (disc_emitter_ == NULL) disc_emitter_ = new ::Serializer::DiscParticleEmitter;
  return disc_emitter_;
}
inline ::Serializer::DiscParticleEmitter* Particle::release_disc_emitter() {
  clear_has_disc_emitter();
  ::Serializer::DiscParticleEmitter* temp = disc_emitter_;
  disc_emitter_ = NULL;
  return temp;
}

// optional int32 version = 4;
inline bool Particle::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Particle::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Particle::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Particle::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Particle::version() const {
  return version_;
}
inline void Particle::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .Serializer.OldParticleEmitter old_emitter = 5;
inline bool Particle::has_old_emitter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Particle::set_has_old_emitter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Particle::clear_has_old_emitter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Particle::clear_old_emitter() {
  if (old_emitter_ != NULL) old_emitter_->::Serializer::OldParticleEmitter::Clear();
  clear_has_old_emitter();
}
inline const ::Serializer::OldParticleEmitter& Particle::old_emitter() const {
  return old_emitter_ != NULL ? *old_emitter_ : *default_instance_->old_emitter_;
}
inline ::Serializer::OldParticleEmitter* Particle::mutable_old_emitter() {
  set_has_old_emitter();
  if (old_emitter_ == NULL) old_emitter_ = new ::Serializer::OldParticleEmitter;
  return old_emitter_;
}
inline ::Serializer::OldParticleEmitter* Particle::release_old_emitter() {
  clear_has_old_emitter();
  ::Serializer::OldParticleEmitter* temp = old_emitter_;
  old_emitter_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Particle_2eproto__INCLUDED
